проблемы подключения и проектирования сетей играют важную роль в комбинаторной оптимизации и алгоритмах как из-за их теоретической привлекательности, так и из-за их многочисленных применений в реальном мире. интересный и большой класс задач следующего типа: учитывая граф @ xmath5 со стоимостью ребер или узлов, найдите подграф @xmath6 с минимальной стоимостью из @xmath2, который удовлетворяет определенным свойствам связности. например, учитывая целое число @xmath7, можно запросить охватывающий подграф с минимальной стоимостью, который связан с @xmath8-ребром или @xmath8-вершиной. если @xmath9, то это классическая задача о минимальном связующем дереве (mst). для @ xmath10 задача является np - трудной, а также apx - трудной для аппроксимации. более общие версии проблем с подключением получаются, если искать подграф, в котором подмножество узлов @xmath11, называемых _ terminals _, подключено к @xmath8. хорошо известная задача дерева Штайнера заключается в поиске подграфа с минимальной стоимостью, который (@xmath12-) соединяет заданный набор @xmath13. многие из этих задач являются частными случаями задачи проектирования устойчивой сети (sndp). в sndp каждая пара узлов @xmath14 определяет требование к подключению @xmath15, и цель состоит в том, чтобы найти подграф с минимальной стоимостью, который имеет @xmath15 непересекающихся путей для каждой пары @xmath16. учитывая неразрешимость этих проблем с подключением, был проделан большой объем работы над алгоритмами аппроксимации. за прошедшие годы был разработан ряд элегантных и мощных методов и результатов (см. @xcite). в частности, метод primal - dual @xcite и итеративное округление @xcite привели к некоторым замечательным результатам, включая аппроксимацию @xmath1 для sndp с граничной связью @xcite. интересный класс проблем, связанных с некоторыми из проблем подключения, описанных выше, возникает при требовании, чтобы были подключены только @xmath0 из данных терминалов. эти проблемы частично мотивированы приложениями, в которых человек стремится максимизировать прибыль, учитывая верхнюю границу (бюджет) затрат. например, полезной задачей в приложениях для маршрутизации транспортных средств является поиск пути, который максимизирует количество вершин в нем при соблюдении бюджета @xmath17 на длину пути. в настройках точной оптимизации задача максимизации прибыли эквивалентна задаче минимизации стоимости / длины пути при условии соблюдения ограничения на включение по крайней мере вершин @xmath0. конечно, эти две версии не обязательно должны быть приблизительно эквивалентны, тем не менее, понимание одной часто бывает плодотворным или необходимым для понимания другой. наиболее хорошо изученной из этих задач является задача @ xmath0-mst; цель здесь - найти подграф с минимальной стоимостью данного графа @xmath2, который содержит по крайней мере @xmath0 вершин (или терминалов). эта проблема привлекла значительное внимание в литературе по алгоритмам аппроксимации, и ее изучение привело к появлению нескольких новых алгоритмических идей и приложений @xcite. отметим, что задача дерева Штайнера может быть относительно легко сведена с сохранением аппроксимации к задаче @ xmath0-mst. совсем недавно lau _ et al. _ @xcite рассмотрели естественное обобщение @xmath0-mst для более высокой связности. в частности, они определили задачу с подграфом @xmath18 следующим образом: найдите подграф с минимальной стоимостью данного графа @xmath2, который содержит по крайней мере вершины @xmath0 и связан ребром @xmath8. мы используем обозначения @xmath0-@xmath8ec для обозначения этой задачи. в @xcite для задачи @xmath0-@xmath1ec было заявлено приближение @xmath19. однако алгоритм и доказательство в @xcite неверны. совсем недавно, в независимой от нашей работе, авторы @xcite получили другой алгоритм для @xmath0-@xmath1ec, который дает приближение @xmath20. позже мы приведем более подробное сравнение между их подходом и нашим. также показано в @xcite, что хорошее приближение для @ xmath0-@xmath8ec, когда @ xmath8 велико, дало бы улучшенный алгоритм для задачи с @ xmath0-самым плотным подграфом @xcite; в этой задаче ищется подграф с @xmath0 вершинами данного графа @xmath2, который имеет максимальное число вершин. из краев. задача о подграфе с наибольшей плотностью @xmath0 допускает аппроксимацию @xmath21 для некоторой фиксированной константы @xmath22 @xcite, но уже несколько лет сопротивляется попыткам улучшить аппроксимацию. в этой статье мы рассмотрим обобщение вершинной связности задачи @ xmath0-mst. мы определяем задачу @xmath0-@xmath8vc следующим образом: учитывая целое число @xmath0 и граф @ xmath2 с реберными затратами, найдите подграф с минимальной стоимостью @xmath8, связанный с вершинами @xmath2, который содержит по крайней мере @xmath0 вершин. мы также рассматриваем версию задачи _ terminal _, в которой подграф должен содержать терминалы @xmath0 из заданного набора терминалов @xmath3. можно легко показать, что проблема @xmath0-@xmath8ec сводится к проблеме @xmath0-@xmath8vc для любого @xmath23. мы также наблюдаем, что проблема @xmath0-@xmath8ec с терминалами может быть легко сведена следующим образом к однородной задаче, где каждая вершина является терминалом: для каждого терминала @xmath24 создайте фиктивные вершины @xmath25 @xmath26 и присоедините @xmath27 к @xmath28 с параллельными ребрами @xmath8 нулевой стоимости. теперь установите @xmath29 в новом графе. можно избежать использования параллельных ребер, создав клику на @xmath26 с использованием ребер с нулевой стоимостью и соединив @xmath8 этих вершин с @xmath28. Обратите внимание, однако, что это сокращение работает только для подключения ребер. мы не знаем о сокращении, которое сводит проблему @xmath0-@xmath8vc с заданным набором терминалов к проблеме @xmath0-@xmath8vc, даже когда @xmath30. в этой статье мы рассматриваем проблему @xmath0-@xmath1vc; наш основной результат заключается в следующем. [ thm : kv ] существует приближение @xmath31 для задачи @xmath0-@xmath1vc, где @xmath32 - это количество терминалов. [ cor : ke ] существует приближение @xmath31 для задачи @xmath0-@xmath1ec, где @xmath32 - это количество терминалов. одним из технических компонентов, которые мы разрабатываем, является приведенная ниже теорема, которая может представлять самостоятельный интерес. учитывая график @xmath2 со стоимостью ребер и весами на терминалах @xmath3, мы определяем @xmath33 для подграфа @xmath6 как отношение стоимости ребер в @xmath6 к общему весу терминалов в @xmath6. [ thm : cycle ] пусть @xmath2 - граф, связанный с вершиной @xmath1, со стоимостью ребер, и пусть @xmath34 - набор терминалов. затем существует простой цикл @xmath35, содержащий по меньшей мере терминалы @xmath1 (нетривиальный цикл), так что плотность @xmath35 не более плотности @xmath2. более того, такой цикл может быть найден за полиномиальное время.    используя приведенную выше теорему и подход lp, мы получаем следующее. [ cor : cycle ] учитывая график @xmath5 с граничными затратами и @xmath32 терминалами @xmath36, существует приближение @ xmath37 для задачи нахождения нетривиального цикла с минимальной плотностью. обратите внимание, что теорема [ thm : цикл ] и следствие [ cor : цикл ] представляют интерес, потому что мы ищем цикл по крайней мере с _ двумя _ терминалами. цикл минимальной плотности, содержащий только один терминал, может быть найден с помощью хорошо известного алгоритма минимального среднего цикла в ориентированных графах @ xcite. однако мы замечаем, что, хотя мы подозреваем, что задача нахождения нетривиального цикла с минимальной плотностью является np - сложной, в настоящее время у нас нет доказательств. теорема [ thm: цикл ] показывает, что задача эквивалентна задаче dens-@xmath1vc, определенной в следующем разделе. * примечание: * читатель может задаться вопросом, допускают ли @xmath0-@xmath1ec или @xmath0-@xmath1vc аппроксимацию с постоянным коэффициентом, поскольку задача @xmath0-mst допускает один. мы отмечаем, что основным техническим инструментом, лежащим в основе аппроксимаций @xmath38 для задачи @xmath0-mst @xcite, является специальное свойство, которое выполняется для lp-релаксации задачи о дереве Штайнера для сбора призов @ xcite, которая является лагранжевой релаксацией задачи о дереве Штайнера. известно, что такое свойство не выполняется для обобщений @xmath0-mst, включая @xmath0-@xmath1ec и @xmath0-@xmath1vc и проблему леса @xmath0-steiner @xcite. таким образом, человек вынужден полагаться на альтернативные методы, ориентированные на конкретные проблемы. мы рассматриваем корневую версию @xmath0-@xmath1vc: цель состоит в том, чтобы найти подграф с минимальной стоимостью, который @xmath1-соединяет по крайней мере терминалы @xmath0 с указанной корневой вершиной @xmath39. относительно просто уменьшить @xmath0-@xmath1vc до его рутированной версии (подробности смотрите в разделе [ sec : k2vc ]. ) мы черпаем вдохновение из алгоритмических идей, которые привели к полилогарифмическим приближениям для задачи @xmath0-mst. чтобы описать наш подход к коренной задаче @xmath0-@xmath1vc, мы определяем тесно связанную проблему. для подграфа @xmath6, содержащего @xmath39, пусть @xmath40 - это количество терминалов, которые @xmath1 подключены к @xmath39 в @xmath6. тогда _ плотность _ @xmath6 - это просто отношение стоимости @xmath6 к @xmath40. задача dens-@xmath1vc состоит в том, чтобы найти 2-связный подграф минимальной плотности. аппроксимация @xmath37 для задачи dens-@xmath1vc (где @xmath32 - количество терминалов) может быть получена каким-либо стандартным способом, используя трюк с объединением и масштабированием в релаксации линейного программирования для задачи. мы используем известную оценку @ xmath1 для разрыва интегральности естественного lp для задачи sndp с требованиями к связности вершин в @xmath41 @ xcite. трюк с группированием и масштабированием неоднократно применялся в прошлом и недавно был освещен в нескольких приложениях @xcite. наш алгоритм для @xmath0-@xmath1vc использует жадный подход на высоком уровне. мы начинаем с пустого подграфа @xmath42 и используем алгоритм аппроксимации для dens-@xmath1vc итеративным способом, чтобы жадно добавлять терминалы в @xmath42, пока по крайней мере терминалы @xmath43 не окажутся в @xmath42. этот подход дал бы приближение @xmath44, если @xmath45. однако последняя итерация алгоритма dens-@xmath1vc может добавить гораздо больше терминалов, чем хотелось бы, в результате чего @xmath46. в этом случае мы можем не влияет на качество решения, получаемого алгоритмом. чтобы преодолеть эту проблему, можно попытаться _ обрезать _ подграф @xmath6, добавленный на последней итерации, чтобы иметь только желаемое количество терминалов. для задачи @xmath0-mst @xmath6 - это дерево, и обрезка довольно проста. мы отмечаем, что это дает довольно простое приближение @xmath20 для @xmath0-mst и могло быть обнаружено намного раньше более умного анализа, приведенного в @xcite. одним из наших технических вкладов является предоставление шага сокращения для задачи @xmath0-@xmath1vc. для достижения этой цели мы используем две алгоритмические идеи. первый инкапсулирован в алгоритм поиска циклов теоремы [ thm : cycle ]. Во-вторых, мы используем этот алгоритм поиска циклов для многократного объединения подграфов, пока не получим желаемое количество терминалов в одном подграфе. этот последний шаг требует осторожности. схема объединения циклов вдохновлена аналогичным подходом из работы lau _ и др. _ @ xcite по задаче @ xmath0-@ xmath1ec и в @ xcite по задаче направленного ориентирования. эти идеи дают приближение @xmath47. мы приводим слегка модифицированный алгоритм объединения циклов с более сложным и нетривиальным анализом, чтобы получить улучшенное приближение @xmath31. некоторые замечания сделаны для того, чтобы сравнить нашу работу с работой @xcite над задачей @xmath0-@xmath1ec. комбинаторный алгоритм в @xcite основан на поиске цикла с низкой плотностью или связанной структуры, называемой двухциклом. алгоритм в @xcite для поиска такой структуры неверен. кроме того, циклы сокращаются по пути, что ограничивает подход к проблеме @xmath0-@xmath1ec (сокращение цикла в графе, связанном с @xmath1-узлом, может привести к тому, что результирующий граф не будет связан с @xmath1-узлом). в нашем алгоритме мы не сокращаем циклы и вместо этого вводим фиктивные терминалы с весами, чтобы зафиксировать количество терминалов в уже сформированном компоненте. это требует от нас теперь решения нетривиальной задачи о простом цикле с минимальной плотностью, которую мы решаем с помощью теоремы [ thm : цикл ] и следствия [ cor : цикл ]. в независимой работе lau _ et al. _ @xcite получили новое и правильное @xmath48-приближение для @xmath0-@xmath1ec. они также следуют тому же подходу, что и мы при использовании lp для поиска плотных подграфов с последующим этапом обрезки. однако на этапе обрезки они используют совершенно другой подход; они используют сложную идею отсутствия нулевых @xmath49-потоков @xcite. хотя использование этой идеи элегантно, подход работает только для задачи @xmath0-@xmath1ec, в то время как наш подход менее сложен и приводит к алгоритму для более общей задачи @xmath0-@xmath1vc. мы работаем с графами, в которых некоторые вершины обозначены как _ terminals_. учитывая график @xmath2 с затратами на ребра и весами терминалов, мы определяем _ плотность _ подграфа @xmath6 как сумму затрат на ребра в @xmath6, деленную на сумму весов терминалов в @xmath6. отныне мы используем @xmath1-связный граф для обозначения @xmath1-вершинно-связного графа. цель задачи @xmath0-@xmath1vc состоит в том, чтобы найти двухсвязный подграф с минимальной стоимостью, по крайней мере, на терминалах @xmath0 .. однако для простоты изложения мы придерживаемся более ограниченной версии. ] напомним, что в задаче root @xmath0-@xmath1vc цель состоит в том, чтобы найти подграф с минимальной стоимостью, по крайней мере, на терминалах @xmath0, в котором каждый терминал подключен по 2 к указанному корневому @xmath39. проблема (некорневая) @xmath0-@xmath1vc может быть сведена к рутированной версии путем _ угадывания _ 2 вершин @xmath16, которые находятся в оптимальном решении, создания новой корневой вершины @xmath39 и соединения ее ребрами с нулевой стоимостью с @xmath50 и @xmath28. нетрудно показать, что любое решение корневой задачи в модифицированном графе может быть преобразовано в решение некорневой задачи путем добавления 2 минимальных по стоимости вершинно - непересекающихся путей между @xmath50 и @xmath28. (поскольку @xmath50 и @xmath28 находятся в оптимальном решении, стоимость этих добавленных путей не может быть больше, чем @xmath51. ) мы опускаем дальнейшие подробности из этого расширенного резюме.    в задаче dens-@xmath1vc цель состоит в том, чтобы найти подграф @xmath6 минимальной плотности, в котором все терминалы @xmath6 2-соединены с корнем. следующая лемма доказана в разделе [подраздел : lp ] ниже. он основан на @ xmath1-аппроксимации с помощью естественного lp для решения проблемы минимальной стоимости @ xmath1-подключения, возникшей из-за Флейшера, Джейн и Уильямсона @ xcite, и некоторых стандартных методов. [ lem : densv ] существует алгоритм аппроксимации @xmath37 для задачи dens-@xmath1vc, где @xmath32 - это количество терминалов в данном экземпляре. пусть @xmath51 - стоимость оптимального решения задачи @xmath0-@xmath1vc. мы предполагаем знание @xmath51; без этого можно обойтись, используя стандартные методы. мы предварительно обрабатываем график, удаляя любой терминал, у которого нет 2-х непересекающихся путей к корню @xmath39 общей стоимости не более @xmath51. высокоуровневое описание алгоритма для корневой задачи @xmath0-@xmath1vc приведено ниже. @xmath52, @xmath53 - пустой граф. + while ( @xmath54 ) : + используйте алгоритм аппроксимации для dens-@xmath1vc, чтобы найти подграф @xmath6 в @xmath2. + if ( @xmath55 ) : + @xmath56, @xmath57 + пометьте все терминалы в @xmath6 как нетерминалы. + else : + _ обрезать _ @xmath6, чтобы получить @xmath58, содержащий терминалы @xmath59. + @xmath60, @xmath61 + вывод @xmath42 в начале любой итерации цикла while график содержит решение проблемы dens-@xmath1vc с плотностью не более @xmath62. следовательно, возвращаемый график @xmath6 всегда имеет плотность не более @xmath63. если @xmath55, мы добавляем @xmath6 к @xmath42 и уменьшаем @xmath59; мы называем это шагом _ augmentation _. в противном случае у нас есть график @xmath6 хорошей плотности, но со слишком большим количеством терминалов. в этом случае мы обрезаем @xmath6, чтобы найти график с требуемым количеством терминалов; это шаг обрезки. простой аргумент типа set - cover показывает следующую лемму: [ lem : greedy ] если на каждом шаге увеличения мы добавляем график плотности не более @xmath64 (где @xmath59 - количество дополнительных терминалов, которые необходимо выбрать), общая стоимость всех шагов увеличения составляет не менее большинство @xmath65. следовательно, теперь нам нужно только привязать стоимость графа @xmath58, добавленного на этапе обрезки; мы докажем следующую теорему в разделе [sec : обрезка]. [ thm : avekv ] пусть @xmath66 является экземпляром проблемы root @xmath0-@xmath1vc с root @xmath39, такой, что каждая вершина @xmath2 имеет @xmath1 непересекающиеся пути к @xmath39 общей стоимостью не более @xmath67, и такой, что @xmath68. существует алгоритм за полиномиальное время, позволяющий найти решение для этого экземпляра cost не более @xmath69. теперь мы можем доказать наш основной результат для задачи @ xmath0-@xmath1vc, теорему [ thm : kv ]. теорема [ thm : kv ] пусть @xmath51 - стоимость оптимального решения (корневой) задачи @xmath0-@xmath1vc. согласно лемме [ lem : greedy ], общая стоимость шагов увеличения нашего жадного алгоритма составляет @xmath70. чтобы ограничить стоимость шага обрезки, пусть @xmath59 - количество дополнительных терминалов, которые должны быть охвачены непосредственно перед этим шагом. алгоритм для задачи dens-@xmath1vc возвращает график @xmath6 с терминалами @xmath71 и плотностью не более @xmath72. в результате нашего этапа предварительной обработки каждая вершина имеет 2 непересекающихся пути к @xmath39 общей стоимостью не более @xmath51. теперь мы используем теорему [ thm : avekv ], чтобы сократить @xmath6 и найти график @xmath58 с терминалами @xmath59 и стоимостью не более @xmath73. таким образом, общая стоимость нашего решения составляет @xmath74. остается только доказать лемму [ lem: densv ], что существует @ xmath75-аппроксимация для задачи dens-@ xmath1vc, и теорему [ thm: avekv ], ограничивающую стоимость шага обрезки. мы докажем первое в разделе [подраздел : lp ] ниже. прежде чем последнее будет доказано в разделе [sec : обрезка], мы разработаем некоторые инструменты в разделе [ sec : циклы ]; главным из этих инструментов является теорема [ thm : цикл].      напомним, что задача dens-@xmath1vc была определена следующим образом: учитывая граф @xmath5 с реберными затратами, набор @xmath76 терминалов и корень @xmath77, найдите подграф @xmath6 минимальной плотности, в котором каждый терминал @xmath6 2-соединен с @xmath39. (здесь плотность @xmath6 определяется как стоимость @xmath6, деленная на количество терминалов, которые она содержит, не включая @xmath39. ) мы описываем алгоритм для dens-@xmath1vc, который дает приближение @xmath37, и набросаем его доказательство. мы используем подход, основанный на lp, и трюк с группированием и масштабированием (см. @xcite для применения этой идеи), а также привязку постоянного коэффициента к разрыву в интегральности lp для sndp с требованиями к подключению к вершинам в @xmath41 @xcite. мы определяем * lp - dens * как следующую lp-релаксацию dens-@xmath1vc. для каждого терминала @xmath78 переменная @xmath79 указывает, выбран ли @xmath28 в решении. (нормализуя @xmath80 к 1 и минимизируя сумму граничных затрат, мы минимизируем плотность. ) @xmath81 - это набор всех простых циклов, содержащих @xmath78 и корневой @xmath39; для любого @xmath82 @xmath83 указывает, какой объем `потока\" отправляется из @xmath28 в @xmath39 через @xmath35. (обратите внимание, что пара вершинно- непересекающихся путей - это цикл; поток вдоль цикла равен 1, если мы можем 2-соединить @xmath78 с @xmath39, используя ребра цикла. ) переменная @xmath84 указывает, используется ли решением ребро @xmath85. @xmath86 @xmath87 нетрудно видеть, что оптимальное решение для * lp - dens * имеет стоимость, не превышающую плотность оптимального решения для dens-@xmath1vc. теперь мы покажем, как получить интегральное решение с плотностью не более @xmath88, где @xmath89 - стоимость оптимального решения для dens-@xmath1vc. оптимальное решение для * lp - dens *. линейная программа * lp - dens * имеет экспоненциальное число переменных, но полиномиальное число нетривиальных ограничений; однако она может быть решена за полиномиальное время. исправьте оптимальное решение для * lp - значений * стоимости @xmath89, и для каждого @xmath90 (для простоты обозначения предположим, что @xmath91 - целое число ), пусть @xmath92 - набор терминалов @xmath78 такой, что @xmath93. поскольку @xmath94, существует некоторый индекс @xmath95 такой, что это @xmath96. поскольку у каждого терминала @xmath97 есть @xmath98, количество терминалов в @xmath92 равно, по крайней мере, @xmath99. мы утверждаем, что существует подграф @xmath6 из @xmath2 со стоимостью не более @xmath100, в котором каждый терминал @xmath92 подключен к корню на 2. если это верно, то плотность @xmath6 составляет не более @xmath101, и, следовательно, у нас есть приближение @xmath37 для задачи dens-@xmath1vc.    чтобы доказать наше утверждение о стоимости подграфа @xmath6, в котором каждый терминал @xmath92 подключен по 2 к @xmath39, рассмотрим увеличение данного оптимального решения * lp - dens * в разы @xmath102. для каждого терминала @xmath103 поток от @xmath78 до @xmath39 в этом масштабируемом решении ] равен как минимум 1, а стоимость масштабируемого решения равна @xmath104.    в @xcite авторы описывают линейную программу @xmath105 для поиска подграфа с минимальной стоимостью, в котором данный набор терминалов подключен к корню на 2, и показывают, что эта линейная программа имеет разрыв в интегральности, равный 2. переменные @xmath84 в \"масштабированном решении\" равны * lp - значения * соответствуют возможному решению @xmath105 с @xmath92 в качестве набора терминалов; разрыв в интегральности, равный 2, подразумевает, что существует подграф @xmath6, в котором каждый терминал @xmath92 подключен к корню в 2 раза, со стоимостью не более @xmath106.    следовательно, алгоритм для dens-@xmath1vc таков: 1. найдите оптимальное дробное решение для * lp - dens *. 2. найдите набор терминалов @xmath92 такой, что @xmath107. 3. найдите подграф с минимальной стоимостью @xmath6, в котором каждый терминал в @xmath92 имеет 2 соединения к @xmath39, используя алгоритм @xcite. Плотность @xmath6 не более чем в @xmath37 раз превышает оптимальное решение для dens-@xmath1vc. цикл @xmath108 является _ нетривиальным _, если он содержит по крайней мере 2 терминала. мы определяем нетривиальную задачу цикла минимальной плотности: учитывая график @ xmath5 с @ xmath3, помеченным как терминалы, стоимость ребер и веса терминалов, найдите цикл минимальной плотности, содержащий по крайней мере 2 терминала. обратите внимание, что если мы уберем требование, чтобы цикл был нетривиальным (то есть он содержит по крайней мере 2 терминала), задача сводится к задаче о минимальном среднем цикле в ориентированных графах и может быть решена точно за полиномиальное время (см. @xcite). алгоритмы для нетривиальной задачи цикла с минимальной плотностью являются полезным инструментом для решения задач @xmath0-@xmath1vc и @xmath0-@xmath1ec. в этом разделе мы приводим алгоритм аппроксимации @xmath75 для нетривиальной задачи цикла с минимальной плотностью. сначала мы докажем теорему [ thm: цикл], что 2-связный граф с реберными затратами и конечными весами содержит простой нетривиальный цикл с плотностью, не превышающей среднюю плотность графа. мы приводим два алгоритма для нахождения такого цикла; первый, описанный в разделе [ подраздел : nonpoly ], проще, но время выполнения не является полиномиальным. более техническое доказательство, которое приводит к алгоритму с сильно выраженным полиномиальным временем, описано в разделе [подраздел : strong ]; мы рекомендуем пропустить это доказательство при первом чтении.      чтобы найти нетривиальный цикл с плотностью не более, чем у 2-связного входного графа @ xmath2, мы начнем с произвольного нетривиального цикла и последовательно будем находить циклы с лучшей плотностью, пока не получим цикл с плотностью не более @xmath109. следующая лемма показывает, что если цикл @xmath35 имеет ухо с плотностью меньше, чем @xmath110, мы можем использовать это ухо, чтобы найти цикл с меньшей плотностью. [ lem : goodear ] пусть @xmath35 будет нетривиальным циклом, а @xmath6 - ухом, инцидентным @xmath35 в @xmath50 и @xmath28, таким, что @xmath111. пусть @xmath112 и @xmath113 будут двумя внутренне непересекающимися путями между @xmath50 и @xmath28 в @xmath35. тогда @xmath114 и @xmath115 оба являются простыми циклами, и один из них нетривиален и имеет плотность меньше, чем @xmath110. @xmath35 имеет по крайней мере 2 терминала, поэтому он имеет конечную плотность; тогда @xmath6 должен иметь по крайней мере 1 терминал. пусть @xmath116, @xmath117 и @xmath118 будут, соответственно, суммой затрат ребер в @xmath112, @xmath113 и @xmath6, и пусть @xmath119, @xmath120 и @xmath121 будут суммой весов терминалов в @xmath112, @xmath113 и @xmath122. предположим, что @xmath112 имеет плотность не более, чем у @xmath113. (то есть, @xmath123. ) и @xmath113 имеет стоимость 0 и вес 0. в этом случае пусть @xmath112 будет компонентом с ненулевым весом. ] @xmath112 должен содержать по крайней мере один терминал, и поэтому @xmath114 является простым нетривиальным циклом. оператор @xmath124 эквивалентен @xmath125.    @xmath126 следовательно, @xmath114 - это простой цикл, содержащий по меньшей мере 2 терминала с плотностью меньше, чем @xmath110. [ lem:2conncomp ] учитывая цикл @xmath35 в @xmath1-связанном графе @xmath2, пусть @xmath42 - граф, образованный из @xmath2 путем сжатия @xmath35 до одной вершины @xmath28. если @xmath6 является подключенным компонентом @xmath127, то @xmath128 является подключенным к @xmath1 в @xmath42. пусть @xmath6 - произвольный подключенный компонент @xmath127, и пусть @xmath129. чтобы доказать, что @xmath58 является 2-связным, мы сначала заметим, что @xmath28 является 2-связным с любой вершиной @xmath130. (любой набор, который отделяет @xmath131 от @xmath28 в @xmath58, отделяет @xmath131 от цикла @xmath35 в @xmath2. ) теперь следует, что для всех вершин @xmath132, @xmath131 и @xmath133 являются 2-соединенными в @xmath58. предположим, удаление некоторой вершины @xmath50 отделяет @xmath131 от @xmath133. вершина @xmath50 не может быть @xmath28, поскольку @xmath6 является подключенным компонентом @xmath127. но если @xmath134, @xmath28 и @xmath131 находятся в одном и том же компоненте @xmath135, поскольку @xmath28 2-подключен к @xmath131 в @xmath58. аналогично, @xmath28 и @xmath133 находятся в одном и том же компоненте @xmath135, и поэтому удаление @xmath50 не отделяет @xmath131 от @xmath133.    теперь мы покажем, что для любого 2-связного графа @xmath2 мы можем найти нетривиальный цикл плотности не больше, чем у @xmath2. [ thm : cycleexists ] пусть @xmath2 - это граф, связанный с @xmath1, по крайней мере, с терминалами @xmath1. @xmath2 содержит простой нетривиальный цикл @xmath136, такой, что @xmath137. пусть @xmath35 - произвольный нетривиальный простой цикл; такой цикл существует всегда, поскольку @xmath2 подключен к @xmath1 и имеет по крайней мере 2 терминала. если @xmath138, мы даем алгоритм, который находит новый нетривиальный цикл @xmath139 такой, что @xmath140. повторяя этот процесс, мы получаем циклы последовательно лучшей плотности, пока, в конечном счете, не найдем нетривиальный цикл @xmath136 с плотностью не более @xmath109. пусть @xmath42 - граф, образованный сокращением данного цикла @xmath35 до одной вершины @xmath28. в @xmath42 @xmath28 не является терминалом и поэтому имеет вес 0. рассмотрим 2-связные компоненты @xmath42 (из леммы [ lem:2conncomp ], каждый такой компонент формируется путем добавления @xmath28 к связному компоненту @xmath127 ) и выберите тот, который имеет минимальную плотность. если @xmath6 является этим компонентом, то @xmath141 в качестве усредняющего аргумента. @xmath6 содержит как минимум 1 терминал. если он содержит 2 или более терминала, рекурсивно найдите нетривиальный цикл @xmath139 в @xmath6 такой, что @xmath142. если @xmath139 существует в данном графе @xmath2, он обладает желаемыми свойствами, и мы закончили. в противном случае @xmath139 содержит @xmath28, а ребра @xmath139 образуют колос @xmath35 в исходном графе @xmath2. плотность этого ear меньше плотности @xmath35, поэтому мы можем применить лемму [ lem : goodear ], чтобы получить нетривиальный цикл в @xmath2, который имеет плотность меньше, чем @xmath110. наконец, если @xmath6 имеет ровно 1 терминал @xmath50, найдите любые 2 пути, не пересекающиеся с вершинами, используя ребра @xmath6 от @xmath50 до различных вершин в цикле @xmath35. (поскольку @xmath2 является двухсвязным, всегда существуют такие пути. ) стоимость этих путей составляет не более @xmath143, и объединение этих двух путей соответствует значению @xmath35 в @xmath2. плотность этого уха меньше, чем @xmath110; опять же, мы используем лемму [ lem : goodear ], чтобы получить цикл в @xmath2 с желаемыми свойствами. мы еще раз отмечаем, что алгоритм теоремы [ thm : cycleexists ] не приводит к алгоритму с полиномиальным временем, даже если все граничные затраты и конечные веса полиномиально ограничены. в разделе [подраздел : strong ] мы описываем алгоритм с сильно полиномиальным временем, который, учитывая график @ xmath2, находит нетривиальный цикл с плотностью, не превышающей @ xmath2. обратите внимание, что ни один из этих алгоритмов не может напрямую дать хорошее приближение к задаче о нетривиальном цикле с минимальной плотностью, поскольку оптимальный нетривиальный цикл может иметь плотность намного меньше, чем у @xmath2. однако мы можем использовать теорему [ thm: cycleexists ], чтобы доказать следующую теорему: [ thm : эквивалентность ] существует @ xmath144-аппроксимация к (некорневой) задаче dens-@ xmath1vc тогда и только тогда, когда существует @xmath144-аппроксимация к задаче нахождения минимальной плотности, не являющейся - тривиальный цикл. предположим, что у нас есть @ xmath145-аппроксимация для задачи dens-@ xmath1vc; мы используем ее, чтобы найти нетривиальный цикл с низкой плотностью. решите задачу dens-@ xmath1vc на данном графе; поскольку оптимальный цикл представляет собой двухсвязный граф, наше решение @xmath6 для задачи dens-@xmath1vc имеет плотность, самое большее в @xmath145 раз превышающую плотность этого цикла. найдите нетривиальный цикл в @xmath6 с плотностью, не превышающей @xmath6; его плотность не более чем в @xmath145 раз превышает плотность оптимального нетривиального цикла. обратите внимание, что любой экземпляр (некорневой) задачи dens-@xmath1vc имеет оптимальное решение, представляющее собой нетривиальный цикл. ( рассмотрим любое оптимальное решение @xmath6 плотности @xmath146; по теореме [ thm : цикл ], @xmath6 содержит нетривиальный цикл плотности не более @xmath146. этот цикл является допустимым решением проблемы dens-@xmath1vc. ) следовательно, a @xmath147-approвычисление для нетривиальной задачи цикла с минимальной плотностью дает приближение @xmath147 для задачи dens-@xmath1vc. теорема [ thm : эквивалентность ] и лемма [ lem : densv ] подразумевают приближение @ xmath37 для нетривиальной задачи цикла с минимальной плотностью; это доказывает следствие [ cor : цикл ]. мы говорим, что граф @ xmath5 минимально 2-соединен на своих терминалах, если для каждого ребра @xmath148 некоторая пара терминалов не является 2-соединенной в графе @xmath149. раздел [ подраздел : strong ] показывает, что в любом графе, который минимально 2-соединен на своих терминалах, каждый цикл это нетривиально. следовательно, задача нахождения нетривиального цикла минимальной плотности в таких графах - это всего лишь задача нахождения цикла минимальной плотности, которая может быть решена точно за полиномиальное время. однако, как мы объясняем в конце раздела, это напрямую не приводит к эффективному алгоритму для произвольных графов.      в этом разделе мы опишем алгоритм с сильно полиномиальным временем, который, учитывая 2-связный граф @ xmath5 со стоимостью ребер и конечными весами, находит нетривиальный цикл плотности, не превышающий @ xmath2. мы начнем с нескольких определений: пусть @xmath35 - цикл в графе @xmath2, а @xmath42 - граф, образованный удалением @xmath35 из @xmath2. пусть @xmath150 - подключенные компоненты @xmath42; мы называем их _ серьгами _ из @xmath35. если бы это был просто путь, это было бы ухо @xmath35, но @xmath151 может быть более сложным. ] для каждого @xmath151 пусть вершины @xmath35, инцидентные ему, называются его _ clasps_. из определения серьги следует, что для любой пары застежек из @xmath151 существует путь между ними, все внутренние вершины которого находятся в @xmath151. мы говорим, что вершина @xmath35 является _ якорем_, если это застежка какой-либо серьги. (якорем может быть застежка нескольких серег. ) _ сегмент _ @xmath13 из @xmath35 - это путь, содержащийся в @xmath35, такой, что конечные точки @xmath13 являются якорями, и ни одна внутренняя вершина @xmath13 не является якорем. (обратите внимание, что конечными точками @xmath13 могут быть застежки одной и той же серьги или разных серег. ) легко видеть, что сегменты разделяют набор ребер @xmath35. удаляя сегмент, мы имеем в виду удаление его ребер и внутренних вершин. обратите внимание, что если @xmath13 удаляется из @xmath2, единственными вершинами @xmath152, которые теряют ребро, являются конечные точки @xmath13. сегмент является _ безопасным_, если граф @xmath153 является двусвязным. произвольно выберите вершину @xmath154 из @xmath35 в качестве _ origin _ и последовательно пронумеруйте вершины @xmath35 по часовой стрелке вокруг цикла как @xmath155. первая застежка серьги @xmath6 - это застежка с наименьшим номером, а последняя застежка - это застежка с наибольшим номером. (если источником является застежка @xmath6, она считается первой застежкой, а не последней. ) _ дуга _ серьги - это подграф @xmath35, найденный путем перемещения по часовой стрелке от ее первой застежки @xmath156 до последней застежки @xmath157 ; длина этой дуги равна @xmath158. (то есть длина дуги - это количество ребер, которые она содержит. ) обратите внимание, что если дуга содержит начало координат, то это должна быть первая вершина дуги. рисунок [ рис. : серьга ] иллюстрирует несколько из этих определений. ( 0,0 ) круг ( 2 см ) ; в ( 0,0 ) @xmath35 ; ( 30:2 см ) ( 30:3 см ) ; ( 2,0 ) ( 3,0 ) ; ( -45:2 см ) ( -45:3 см ) ; в ( 38:2.35 см ) @xmath159 ; в ( 2.35,0.25 ) @xmath160 ; в ( -53:2.35 см ) @xmath161 ; в ( 0,2.35 ) @xmath162 ; ( 30:2.8 см ) дуги(30:-45:2.8 см ) ; ( 30:4.2 см ) дуги ( 30:-45:4.2 см ) ; ( 30:2.8 см ) дуги ( -150:-330:0,7 см ) ; ( -45:2.8 см ) дуги ( 135:315:0,7 см ) ; в ( 15:3.5 см ) @xmath6 ; ( 30:2 см ) круг ( 1 мм ) ; ( -45:2 см ) круг ( 1 мм ) ; ( 2,0 ) круга ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 30:1,75 см ) дуги ( 30:-45:1,75 см ) ; ( 0,0 ) круга ( см 2 ) ; в ( 0,0 ) @xmath35 ; ( 0,2 ) ( 0,3.6 ) дуги(90:-90:3,6 см ) ( 0,-2 ) ; в ( 0,1.6 ) @xmath163 ; в ( 0,-1.6 ) @xmath164 ; в ( 0,3.9 ) [ шрифт= ] @xmath165 ; ( 30:2 см ) ( 30:3 см ) дуги(30:-30:3 см ) ( -30:2 см ) ; в ( 30:1.6 см ) @xmath156 ; в ( -30:1,6 см ) @xmath157 ; ( 30:2.2 см ) дуги(30:330:2,2 см ) ; ( 25:2,2 см ) ( 25:2.8 см ) дуги(25:-25:2.8 см ) ( -25:2.2 см ) ; ( 30:2 см ) круг ( 1 мм ) ; ( -30:2 см ) круг ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 0,-2 ) круга ( 1 мм ) ; ( 150:2 см ) круг ( 1 мм ) ; при ( 150:1,6 см ) @xmath162 ; ( 0,0 ) круга ( см 2 ) ; в ( 0,0 ) @xmath35 ; ( 0,2 ) ( 0,3.6 ) дуги(90:-90:3,6 см ) ( 0,-2 ) ; в ( 0,1.6 ) @xmath163 ; в ( 0,-1.6 ) @xmath164 ; в ( 0,3.9 ) [ шрифт= ] @xmath166 ; в ( 30:1.6 см ) @xmath156 ; в ( -30:1,6 см ) @xmath157 ; ( 30:2 см ) ( 30:3.6 см ) ; ( 88:2 см ) ( 85:3 см ) дуги(85:-85:3 см ) ( -88:2 см ) ; на ( 85:3,3 см ) [ шрифт= ] @xmath167 ; ( -30:2 см ) ( -30:3 см ) ; ( 25:2,2 см ) ( 25:3,4 см ) дуги ( 25:-88:3,4 см ) ( -88:2.2 см ) дуги ( -88:-35:2,2 см ) ; ( -25:2,2 см ) ( -25:2.8 см ) дуги ( -25:80:2.8 см ) ( 80:2.2 см ) дуги ( 80:35:2.2 см ) ; ( 30:2 см ) круг ( 1 мм ) ; ( -30:2 см ) круг ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 0,-2 ) круга ( 1 мм ) ; ( 150:2 см ) круг ( 1 мм ) ; при ( 150:1,6 см ) @xmath162 ; ( 0,0 ) круга ( см 2 ) ; в ( 0,0 ) @xmath35 ; ( 0,2 ) ( 0,3.6 ) дуги(90:-90:3,6 см ) ( 0,-2 ) ; в ( 0,1.6 ) @xmath163 ; в ( 0,-1.6 ) @xmath164 ; в ( 0,3.9 ) [ шрифт= ] @xmath165 ; в ( 30:1.6 см ) @xmath156 ; в ( -30:1,6 см ) @xmath157 ; ( 30:2 см ) ( 30:3,1 см ) дуги ( 30:-105:3,1 см ) ( -105:2 см ) ; в ( 38:2.55 см ) [ шрифт= ] @xmath166 ; ( -30:2 см ) ( -30:2,5 см ) дуги(-30:-135:2,5 см ) ( -135:2 см ) ; в ( -143:2,5 см), [ шрифт= ] @xmath167 ; ( 35:2.15 см ) дуги ( 35:85:2.15 см ) ( 85:3.45 см ) дуги ( 85:-85:3.45 см ) ( -85:2.15 см ) дуги ( -85:-35:2.15 см ) ; ( 25:2,2 см ) ( 25:2.95 см ) дуги(25:-100:2.95 см ) ( -100:2.15 см ) дуги ( -100:-130:2.15 см ) ( -130:2,65 см ) дуги ( -130:-25:2,65 см ) ( -25:2.15 см ) ; ( 30:2 см ) круг ( 1 мм ) ; ( -30:2 см ) круг ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 0,-2 ) круга ( 1 мм ) ; ( 150:2 см ) круг ( 1 мм ) ; при ( 150:1,6 см ) @xmath162 ; ( 0,0 ) круга ( см 2 ) ; в ( 0,0 ) @xmath35 ; ( 0,2 ) ( 0,3.6 ) дуги(90:-90:3,6 см ) ( 0,-2 ) ; в ( 0,1.6 ) @xmath163 ; в ( 0,-1.6 ) @xmath164 ; в ( 0,4.1 ) [ шрифт= ] @xmath168 ; в ( 30:1.6 см ) @xmath156 ; в ( -30:1,6 см ) @xmath157 ; ( 30:2 см ) ( 30:3.6 см ) ; ( -30:2 см ) ( -30:3 см ) дуги(-30:-120:3 см ) ( -120:2 см ) ; в ( -125:3 см ) [ шрифт= ] @xmath167 ; ( -35:2.2 см ) дуги ( -35:-85:2.2 см ) ( -85:3,4 см ) дуги ( -85:25:3,4 см ) ( 25:2,2 см ) ; ( -35:2,2 см ) ( -35:2.8 см ) дуги(-35:-115:2.8 см ) ( -115:2.2 см ) дуги ( -115:-330:2,2 см ) ; ( 30:2 см ) круг ( 1 мм ) ; ( -30:2 см ) круг ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 0,-2 ) круг ( 1 мм ) ; ( 150:2 см ) круг ( 1 мм ) ; при ( 150:1,6 см ) @xmath162 ; ( 0,0 ) круга ( см 2 ) ; в ( 0,0 ) @xmath35 ; ( 0,2 ) ( 0,3.6 ) дуги(90:-90:3,6 см ) ( 0,-2 ) ; в ( 0,1.6 ) @xmath163 ; в ( 0,-1.6 ) @xmath164 ; в ( 0,4.1 ) [ шрифт= ] @xmath168 ; в ( 30:1.6 см ) @xmath156 ; в ( -30:1,6 см ) @xmath157 ; ( -30:2 см ) ( -30:3.6 см ) ; ( 30:2 см ) ( 30:3 см ) дуги(30:-120:3 см ) ( -120:2 см ) ; в ( -125:3 см ) [ шрифт= ] @xmath167 ; ( -25:2,2 см ) ( -25:3,4 см ) дуги ( -25:85:3,4 см ) ( 85:2.2 см ) дуги ( 85:35:2.2 см ) ; ( -35:2.2 см ) дуги ( -35:-115:2,2 см ) ( -115:2.8 см ) дуги(-115:35:2.8 см ) ( 35:2.2 см ) ; ( 30:2 см ) круг ( 1 мм ) ; ( -30:2 см ) круг ( 1 мм ) ; ( 0,2 ) круг ( 1 мм ) ; ( 0,-2 ) круг ( 1 мм ) ; ( 150:2 см ) круг ( 1 мм ) ; при ( 150:1,6 см ) @xmath162 ; [ терм : earringproof ] пусть @xmath6 быть серьга минимальную длину дуги. каждый сегмент, содержащийся в дуге @xmath6, безопасен. пусть @xmath169 - набор сережек с дугой, идентичной дуге @xmath6. поскольку они имеют одинаковую дугу, мы называем это дугой @xmath169, или _критической дугой_. пусть первой застежкой каждой серьги в @xmath169 будет @xmath163, а последней застежкой каждой серьги в @xmath169 будет @xmath164. поскольку серьги в @xmath169 имеют дуги минимальной длины, любая серьга @xmath170 имеет застежку @xmath171, которая не находится в критической дуге. ( то есть @xmath172 или @xmath173. ) мы должны показать, что каждый сегмент, содержащийся в критической дуге, безопасен; напомним, что сегмент @xmath13 безопасен, если граф @xmath153 двусвязен. учитывая произвольный сегмент @xmath13 на критической дуге, пусть @xmath156 и @xmath157 ( @xmath174 ) будут якорями, которые являются его конечными точками. мы доказываем, что всегда существуют 2 внутренне не пересекающихся пути между @xmath156 и @xmath157 в @xmath152; этого достаточно, чтобы показать 2-связность. мы рассмотрим несколько вариантов, в зависимости от сережек, содержащих @xmath156 и @xmath157. рисунок [ fig : earringproof ] иллюстрирует эти варианты. если @xmath156 и @xmath157 содержатся в одной и той же серьге @xmath58, легко найти два пути, не пересекающихся вершинами, между ними в @xmath153. первый путь проходит по часовой стрелке от @xmath175 до @xmath176 в цикле @xmath35. второй путь полностью содержится в earring @xmath58 (серьга подключена в @xmath177, поэтому мы всегда можем найти такой путь. ) в противном случае, @xmath156 и @xmath157 являются застежками разных серег. мы рассматриваем три случая: и @xmath156, и @xmath157 являются застежками серег в @xmath169, одна из них (но не обе), или ни одна из них не является.    1. сначала мы рассмотрим, что и @xmath156, и @xmath157 являются застежками серег в @xmath169. пусть @xmath156 будет застежкой @xmath166, а @xmath157 - застежкой @xmath167. первый путь - от @xmath157 до @xmath163 через @xmath167, а затем по часовой стрелке вдоль критической дуги от @xmath163 до @xmath156. второй путь - от @xmath157 до @xmath164 по часовой стрелке вдоль критического пути, а затем от @xmath164 до @xmath156 через @xmath166. легко видеть, что эти пути внутренне не пересекаются вершинами. 2. теперь предположим, что ни @xmath156, ни @xmath157 не являются застежкой серьги в @xmath169. пусть @xmath156 будет замыканием на @xmath166, а @xmath157 будет застежкой @xmath167. первый найденный нами путь следует по критической дуге по часовой стрелке от @xmath157 до @xmath164 (последнее замыкание критической дуги), от @xmath164 до @xmath163 через @xmath165 и снова по часовой стрелке через критическую дугу от @xmath163 до @xmath156. все внутренние вершины этого пути находятся в @xmath6 или на критической дуге. пусть @xmath178 будет замыканием @xmath166 не на критической дуге, а @xmath179 будет последним замыканием @xmath167 не на критической дуге. второй путь идет от @xmath156 к @xmath178 через @xmath166, от @xmath180 к @xmath181 через цикл @xmath35 за пределами критической дуги и от @xmath179 к @xmath157 через @xmath167. внутренние вершины этого пути находятся в @xmath182 или в @xmath35, но не являются частью критической дуги (поскольку каждая из @xmath178 и @xmath179 находится за пределами критической дуги). следовательно, у нас есть 2 вершинно- непересекающихся пути от @xmath156 к @xmath157. наконец, мы рассмотрим случай, когда ровно один из @xmath183 является застежкой серьги в @xmath169. предположим, что @xmath156 является застежкой @xmath168, а @xmath157 является застежкой @xmath184; другой случай (где @xmath185 и @xmath186 симметричны и опущены, хотя рисунок [ рис. : защита от ушек ] иллюстрирует пути. ) пусть @xmath181 будет индексом замыкания @xmath167 за пределами критической дуги. первый путь - от @xmath157 к @xmath164 через критическую дугу, а затем от @xmath164 к @xmath156 через @xmath166. второй путь - от @xmath157 к @xmath179 через @xmath167 и от @xmath179 к @xmath156 по часовой стрелке через @xmath35. обратите внимание, что последняя часть этого пути входит в критическую дугу в точке @xmath163 и продолжается по дуге до @xmath156. внутренние вершины первого пути, которые находятся в @xmath35, находятся на критической дуге, но имеют индекс больше, чем @xmath175. внутренние вершины второго пути, которые принадлежат @xmath35, либо не находятся на критической дуге, либо имеют индекс между @xmath163 и @xmath156. следовательно, эти два пути внутренне не пересекаются по вершинам. теперь мы опишем наш алгоритм поиска нетривиального цикла хорошей плотности, доказывая теорему [ thm : цикл ]: _ пусть @ xmath2 - связный граф @ xmath1 с реберными затратами и весами терминалов и, по крайней мере, терминалами @xmath1. существует алгоритм полиномиального времени для нахождения нетривиального цикла @ xmath136 в @ xmath2, такого, что @ xmath137. _ теорема [ thm : цикл ] пусть @xmath2 - граф с терминалами @xmath32 и плотностью @xmath146; мы описываем алгоритм полиномиального времени, который либо находит цикл в @xmath2 с плотностью меньше, чем @xmath146, или соответствующий подграф @xmath42 из @xmath2, который содержит все терминалы @xmath32. в последнем случае мы можем выполнить рекурсию по @xmath42 до тех пор, пока в конечном итоге не найдем цикл с плотностью не более @xmath146. сначала мы находим, за время @xmath187, цикл минимальной плотности @xmath35 в @xmath2. согласно теореме [ thm : cycleexists ], @xmath35 имеет плотность не более @xmath146, потому что цикл минимальной плотности _ нетривиальный _ имеет не более этой плотности. если @xmath35 содержит по крайней мере 2 терминала, мы закончили. в противном случае @xmath35 содержит ровно один терминал @xmath28. поскольку @xmath2 содержит по крайней мере 2 терминала, должна существовать хотя бы одна серьга @xmath35. пусть @xmath28 является началом этого цикла @xmath35, а @xmath6 - серьгой минимальной длины дуги. по теореме [ thm: earringproof ], каждый сегмент в дуге @xmath6 безопасен. пусть @xmath13 будет таким сегментом; поскольку @xmath28 был выбран в качестве начала координат, @xmath28 не является внутренней вершиной @xmath13. поскольку @xmath28 является единственным терминалом @xmath35, @xmath13 не содержит терминалов, и, следовательно, граф @xmath188 является двусвязным и содержит все @xmath32 терминалы @xmath2. приведенное выше доказательство также показывает, что если @xmath2 минимально 2-связен на своих терминалах (то есть у @xmath2 нет 2-связного правильного подграфа, содержащего все его терминалы), каждый цикл @xmath2 нетривиален. (если цикл содержит 0 или 1 клемму, у него есть безопасный сегмент, не содержащий клемм, который может быть удален; это приводит к противоречию. ) следовательно, учитывая граф, который _ минимально 2-связен на своих терминалах, нахождение нетривиального цикла минимальной плотности эквивалентно нахождению цикла минимальной плотности и, таким образом, может быть решено точно за полиномиальное время. это наводит на мысль о естественном алгоритме решения задачи: учитывая граф, который не является минимально 2-связным на своих терминалах, удаляйте ребра и вершины до тех пор, пока граф не станет минимально 2-связным на терминалах, а затем найдите цикл минимальной плотности. как показано выше, это дает цикл плотности не больше, чем у входного графика, но это может быть не цикл минимальной плотности исходного графика. например, существуют случаи, когда цикл минимальной плотности использует ребра безопасного сегмента @xmath13, которые могут быть удалены этим алгоритмом. в этом разделе мы доказываем теорему [ thm : avekv ]. нам дан график @xmath2 и @xmath3, набор, по крайней мере, терминалов @xmath0. кроме того, каждый терминал в @xmath2 имеет 2 непересекающихся пути к корню @xmath39 общей стоимости не более @xmath67. пусть @xmath32 - количество терминалов в @xmath2, а @xmath189 - его общая стоимость; @xmath190 - плотность @xmath2. мы описываем алгоритм, который находит подграф @xmath6 из @xmath2, содержащий по крайней мере терминалы @xmath0, каждый из которых подключен к корню по 2, и имеет общую стоимость ребра @xmath191. мы можем предположить, что @xmath192, или достаточно тривиального решения взять весь график @xmath2. основная фаза нашего алгоритма заключается в поддержании набора двухсвязных подграфов, которые мы называем _ clusters _, и многократном поиске циклов низкой плотности, которые объединяют кластеры одинакового веса, образуя более крупные кластеры. (вес кластера @xmath136, обозначаемого @xmath193, равен (примерно ) количеству содержащихся в нем терминалов. ) кластеры сгруппированы в _уровни _ по весу; уровень @xmath95 содержит кластеры с весом не менее @xmath194 и менее @xmath102. изначально каждый терминал представляет собой отдельный кластер уровня 0. мы говорим, что кластер является _ большим _, если он имеет вес не менее @xmath0, и _ маленьким _ в противном случае. алгоритм останавливается, когда большинство терминалов находятся в больших кластерах. теперь мы опишем алгоритм слияния кластеров (смотрите следующую страницу). для упрощения обозначения пусть @xmath144 будет величиной @xmath195. мы говорим, что цикл _ хорош_, если он имеет плотность не более @xmath144; то есть хорошие циклы имеют плотность не более @xmath196, в несколько раз превышающую плотность входного графика.    : + для ( каждого @xmath95 в @xmath197 ) сделайте : + if ( @xmath198 ) : + каждый терминал имеет вес 1 + else : + пометьте все вершины как нетерминалы + для (каждого небольшого двухсвязного кластера @xmath136 в tier @xmath95 ) сделайте : + добавьте (фиктивный ) терминал @xmath199 к @xmath2 веса @xmath193 + добавьте (фиктивные) ребра стоимости 0 из @xmath199 к двум (произвольным) различным вершинам @xmath136 + while ( @xmath2 имеет нетривиальный цикл @xmath35 плотности не более @xmath144 в @xmath2 ) : + пусть @xmath200 - это небольшие кластеры, содержащие терминал * или ребро * из @xmath35. + (обратите внимание, что терминалы в @xmath35 принадлежат подмножеству @xmath201. ) + сформируйте новый кластер @xmath202 (более высокого уровня) путем слияния кластеров @xmath203 + @xmath204 +, если ( @xmath198 ) : + пометьте все терминалы в @xmath202 как нетерминалы + else : + удалите все (фиктивные) терминалы в @xmath202 и связанные с ними (фиктивные) ребра. мы кратко остановимся на некоторых существенных особенностях этого алгоритма и нашем анализе, прежде чем представить детали доказательств.    1. в итерации @xmath95 терминалы соответствуют кластерам уровня @xmath95. кластеры - это 2-связные подграфы @xmath2, и, используя циклы для объединения кластеров, мы сохраняем 2-связность по мере увеличения кластеров. 2. когда цикл @xmath35 используется для объединения кластеров, все небольшие кластеры, содержащие ребро @xmath35 (независимо от их уровня), объединяются для формирования нового кластера. следовательно, на любом этапе алгоритма все небольшие в данный момент кластеры не пересекаются по краям. большие кластеры, с другой стороны, являются _ замороженными_; даже если они пересекают хороший цикл @xmath35, они не объединяются с другими кластерами на @xmath35. таким образом, в любой момент ребро может находиться в нескольких больших кластерах и вплоть до одного маленького кластера. 3. в итерации @xmath95 mergeclusters плотность цикла @xmath35 определяется только его стоимостью и весом терминалов в @xmath35, соответствующих кластерам уровня @xmath95. хотя небольшие кластеры других (более низких или более высоких) уровней могут быть объединены с помощью @xmath35, мы не используем их вес для оплаты ребер @xmath35. 4. итерация @xmath95 завершается, когда не удается найти подходящие циклы с использованием кластеров оставшегося уровня @xmath95. на данный момент может остаться несколько терминалов, соответствующих кластерам, которые не объединены для формирования кластеров более высоких уровней. однако наш выбор @xmath144 (который определяет плотность хороших циклов) таков, что мы можем ограничить количество терминалов, которые `остались позади\" таким образом. следовательно, когда алгоритм завершается, большинство терминалов находятся в больших кластерах.    ограничивая плотность больших кластеров, мы можем найти решение коренной проблемы @xmath0-@xmath1vc с ограниченной плотностью. поскольку мы всегда используем циклы низкой плотности для объединения кластеров, анализ, аналогичный анализу @xcite и @xcite xcite показывает, что каждый большой кластер имеет плотность не более @xmath205. сначала мы представляем этот анализ, хотя его недостаточно для доказательства теоремы [ thm : avekv ]. более тщательный анализ показывает, что существует по крайней мере один большой кластер с плотностью не более @xmath206; это позволяет нам доказать желаемую теорему. теперь мы формально докажем, что mergeclusters обладает желаемым поведением. во-первых, мы представляем серию утверждений, которые в совокупности показывают, что при завершении работы алгоритма большинство терминалов находятся в больших кластерах, и все кластеры двухсвязны. [ rem : cluster ] на протяжении всего алгоритма граф @xmath2 всегда является двусвязным. вес кластера равен, самое большее, количеству содержащихся в нем терминалов. единственное структурное изменениеизменения в @xmath2 происходят, когда новые вершины добавляются в качестве терминалов; они добавляются ребрами к двум различным вершинам @xmath2. это сохраняет 2-связность, как и удаление этих терминалов со связанными ребрами.    чтобы убедиться в справедливости второго утверждения, обратите внимание, что если терминал вносит вес в кластер, он содержится в этом кластере. терминал может находиться в нескольких кластерах, но он вносит вес ровно в один кластер. мы используем следующее простое предложение в доказательствах 2-связности; доказательство является простым и, следовательно, опущено.    [ prop : shareedge ] пусть @xmath207 и @xmath208 будут связанными с @xmath1 подграфами графа @xmath5, такими что @xmath209. тогда граф @xmath210 связан с @xmath1. [ lem : clusters2conn ] все кластеры, образованные mergeclusters, связаны с @xmath1. пусть @xmath202 - кластер, сформированный с помощью цикла @xmath35 для объединения кластеров @xmath200. ребра цикла @xmath35 образуют 2-связный подграф @xmath2, и мы предполагаем, что каждый @xmath211 является 2-связным по индукции. далее, @xmath35 содержит по меньшей мере 2 вершины из каждой @xmath211 может быть одноэлементной вершиной (например, если мы находимся на уровне 0), но такая вершина не влияет на 2-связность. ], поэтому мы можем использовать индукцию и предложение [ prop : shareedge ] выше: мы предполагаем @xmath212 является 2-связным по индукции, а @xmath35 содержит 2 вершины @xmath213, поэтому @xmath214 является 2-связным.    обратите внимание, что мы показали, что @xmath215 имеет 2 соединения, но @xmath35 (и, следовательно, @xmath202 ) может содержать фиктивные клеммы и соответствующие фиктивные ребра. однако каждый такой терминал с двумя связанными ребрами является ухом @xmath202; их удаление оставляет @xmath202 2-подключенным. [ lem : fewleftbehind ] общий вес небольших кластеров на уровне @xmath95, которые не объединяются для формирования кластеров более высоких уровней, составляет не более @xmath216. предположим, что это неверно; это означает, что кластеры слияния не смогли найти больше циклов плотности не более @xmath144, используя оставшиеся кластеры малого уровня @xmath95. но общая стоимость всех ребер составляет не более @xmath189, а сумма весов терминалов составляет не менее @xmath216; это означает, что плотность графа (с использованием оставшихся терминалов) составляет не более @xmath217. но по теореме [ thm : cycleexists ], граф должен содержать хороший нетривиальный цикл, и поэтому цикл while не завершился бы. [ cor : weightlargeclusters ] когда алгоритм mergeclusters завершается, общий вес больших кластеров составляет не менее @xmath218. каждый терминал, не входящий в большой кластер, вносит свой вклад в вес кластера, который не был объединен с другими для формирования кластера более высокого уровня. предыдущая лемма показывает, что общий вес таких кластеров на любом уровне составляет не более @xmath219; поскольку существует @xmath220 уровней, общее количество терминалов, не входящих в большие кластеры, меньше @xmath221. до сих пор мы показывали, что большинство терминалов достигают больших кластеров, все из которых двухсоединены, но мы не спорили о плотности этих кластеров. следующая лемма гласит, что если мы сможем найти большой кластер с хорошей плотностью, мы сможем найти решение проблемы @xmath0-@xmath1vc с хорошей плотностью. [ lem : сегмент ] пусть @xmath202 - большой кластер, образованный mergeclusters. если @xmath202 имеет плотность не более @xmath222, мы можем найти график @xmath223 по крайней мере с терминалами @xmath0, каждый из которых @xmath1 подключен к @xmath39, общей стоимостью не более @xmath224. пусть @xmath200 - кластеры, объединенные для формирования @xmath202 в порядке вокруг цикла @xmath35, который их объединил; каждый @xmath211 был небольшим кластером, весом не более @xmath0. простой аргумент усреднения показывает, что существует последовательный сегмент @xmath211s с общим весом между @xmath0 и @xmath225, так что стоимость ребер @xmath35, соединяющих эти кластеры, вместе со стоимостью самих кластеров составляет не более @xmath226. пусть @xmath227 будет `первым\" кластером этого сегмента, а @xmath228 - `последним\". пусть @xmath28 и @xmath229 являются произвольными терминалами @xmath227 и @xmath228 соответственно. подключите каждый из @xmath28 и @xmath229 к корневому @xmath39, используя 2 пути, не пересекающихся вершинами; стоимость этого шага составляет не более @xmath230. (мы предположили, что каждый терминал может быть дважды подключен к @xmath39, используя непересекающиеся пути стоимостью не более @xmath67. ) построенный таким образом график @xmath223 имеет как минимум @xmath0 терминалов, а общая стоимость не более @xmath231. мы покажем, что каждая вершина @xmath232 из @xmath223 2-соединена с @xmath39; это завершает наше доказательство. пусть @xmath232 - произвольная вершина @xmath223 ; предположим, что существует вырезанная вершина @xmath131, которая при удалении отделяет @xmath232 от @xmath39. и @xmath28, и @xmath229 являются 2-соединенными с @xmath39, и, следовательно, ни один из них не находится в том же компоненте, что и @xmath232 в @xmath233. однако мы описываем 2 вершинно- непересекающихся пути @xmath234 и @xmath235 в @xmath223 от @xmath232 до @xmath28 и @xmath229 соответственно; удаление @xmath131 не может отделить @xmath232 как от @xmath28, так и от @xmath229, что приводит к противоречию. пути @xmath234 и @xmath235 легко найти; пусть @xmath211 - кластер, содержащий @xmath232. цикл @xmath35 содержит путь от вершины @xmath236 к @xmath237 и другой (не пересекающийся с вершинами) путь от @xmath238 к @xmath239. объединение этих путей с путями от @xmath240 к @xmath28 в @xmath227 и @xmath241 к @xmath229 в @xmath228 дает нам пути, не пересекающиеся с вершинами @xmath242 от @xmath243 до @xmath28 и @xmath244 от @xmath245 до @xmath229. поскольку @xmath211 является двусвязным, мы можем найти пути, не пересекающиеся с вершинами, от @xmath232 до @xmath243 и @xmath245, что дает нам желаемые пути @xmath234 и @xmath235. может не находиться ни в одном кластере @xmath211. в этом случае @xmath234 формируется с использованием ребер @xmath35 от @xmath232 до @xmath237, а затем путь от @xmath240 до @xmath28 ; @xmath235 формируется аналогичным образом. ] теперь мы представляем два анализа плотности, упомянутых ранее. ключевое различие между более слабым и более жестким анализом заключается в том, как мы привязали граничные затраты. в первом случае каждый большой кластер оплачивает свои ребра отдельно, используя тот факт, что все используемые циклы имеют плотность не более @xmath246. во втором мы критически используем тот факт, что объединяются небольшие кластеры, которые имеют общие ребра. грубо говоря, поскольку небольшие кластеры не пересекаются по краям, средняя плотность небольших кластеров должна быть сопоставима с плотностью входного графика @xmath2. как только ребро находится в большом кластере, мы больше не можем использовать аргумент непересекаемости по краям. мы должны платить за эти ребра отдельно, но мы можем ограничить эту стоимость. во-первых, следующая лемма позволяет нам показать, что каждый большой кластер имеет плотность не более @xmath205. [ lem : tiercost ] для любого кластера @xmath202, сформированного mergeclusters во время итерации @xmath95, общая стоимость ребер в @xmath202 составляет не более @xmath247. мы докажем эту лемму путем индукции по числу вершин в кластере. пусть @xmath248 - множество кластеров, объединенных с помощью цикла @xmath35 с образованием @xmath202. пусть @xmath249 - набор кластеров в @xmath248 уровня @xmath95, а @xmath250 - @xmath251. ( @xmath250 содержит кластеры уровней меньше или больше, чем @xmath95, которые содержали ребро @xmath35. ) стоимость ребер в @xmath202 самое большее равна сумме : стоимость @xmath35, стоимость @xmath249 и стоимость @xmath250. поскольку все кластеры в @xmath250 были сформированы во время итерации @xmath95 или ранее и меньше, чем @xmath202, мы можем использовать индукцию, чтобы показать, что стоимость ребер в @xmath250 составляет не более @xmath252. все кластеры в @xmath249 относятся к уровню @xmath95 и, следовательно, должны были быть сформированы до итерации @xmath95 (любой кластер, сформированный во время итерации @xmath95, имеет строго больший уровень), поэтому мы используем индукцию для привязки стоимости ребер в @xmath249 к @xmath253. наконец, поскольку @xmath35 был циклом с хорошей плотностью, и только кластеры уровня @xmath95 участвуют в расчете плотности @xmath35, стоимость @xmath35 составляет самое большее @xmath254. следовательно, общая стоимость ребер в @xmath202 составляет не более @xmath255. пусть @xmath202 - произвольный большой кластер; поскольку у нас есть только уровни @xmath220, предыдущая лемма подразумевает, что стоимость @xmath202 составляет не более @xmath256. то есть плотность @xmath202 составляет не более @xmath205, и мы можем использовать этот факт вместе с леммой [ lem : сегмент ], чтобы найти решение коренной проблемы @xmath0-@xmath1vc о стоимости не более @xmath257. это завершает \"более слабый\" анализ, но этого недостаточно для доказательства теоремы [ thm : avekv ]; чтобы доказать теорему, нам нужно было бы использовать большой кластер @xmath202 плотности @xmath206 вместо @xmath205.    с целью более тщательного анализа неявно создайте forest @xmath258 для кластеров, сформированных mergeclusters. изначально набор вершин @xmath258 - это просто @xmath13, набор терминалов, а @xmath258 не имеет ребер. каждый раз, когда кластер @xmath202 формируется путем слияния @xmath200, мы добавляем соответствующую вершину @xmath202 в лес @xmath258 и добавляем ребра из @xmath202 к каждому из @xmath203; @xmath202 является родительским для @xmath259. мы также связываем стоимость с каждой вершиной в @xmath258; стоимость вершины @xmath202 - это стоимость цикла, используемого для формирования @xmath202 из @xmath203. таким образом, мы создаем деревья по мере выполнения алгоритма; корень любого дерева соответствует кластеру, который еще не стал частью более крупного кластера. листья деревьев соответствуют вершинам @xmath2; все они имеют стоимость 0. кроме того, любой большой кластер @xmath202, сформированный алгоритмом, находится в корне своего дерева; мы называем это дерево @xmath260.    для каждого большого кластера @xmath202 после завершения mergeclusters скажите, что @xmath202 имеет тип @xmath95, если @xmath202 был сформирован во время итерации @xmath95 mergeclusters. теперь мы определяем кластеры _ final - stage _ из @xmath202: это кластеры, сформированные во время итерации @xmath95, которые стали частью @xmath202. (мы включаем сам @xmath202 в список кластеров заключительной стадии; даже несмотря на то, что @xmath202 был сформирован в итерации @xmath95 mergeclusters, он может содержать другие кластеры конечной стадии. например, во время итерации @xmath95 мы можем объединить несколько кластеров уровня @xmath95, чтобы сформировать кластер @xmath136 уровня @xmath261. затем, если мы найдем цикл @xmath35 с хорошей плотностью, содержащий ребро @xmath136, @xmath136 сольется с другими кластерами @xmath35. ) _ предпоследние _ кластеры @xmath202 - это те кластеры, которые существуют непосредственно перед началом итерации @xmath95 и становятся частью @xmath202. аналогично, предпоследними кластерами являются кластеры, сформированные до итерации @xmath95, которые являются непосредственными дочерними элементами в @xmath260 кластеров конечной стадии. на рисунке 1 показаны определения кластеров конечной стадии и предпоследнего этапа. такое дерево могло бы быть сформировано, если бы на итерации @xmath262 4 кластера этого уровня объединились, чтобы сформировать @xmath263, кластер уровня @xmath264. впоследствии, на итерации @xmath95, кластеры @xmath6 и @xmath265 объединяются, образуя @xmath266. затем мы находим хороший цикл, содержащий @xmath267 и @xmath2 ; @xmath266 содержит ребро этого цикла, поэтому эти три кластера объединяются, образуя @xmath17. обратите внимание, что стоимость этого цикла оплачивается только весами @xmath267 и @xmath2 ; @xmath266 является кластером уровня @xmath264, и поэтому его вес не включается в расчет плотности. наконец, мы находим хороший цикл оплачено @xmath268 и @xmath35 ; с @xmath17 и @xmath263 общие ребра с этого цикла, все они, сливаясь, образуют большие скопления @xmath202. = [ круг, ничья, внутренний сентября=0pt, минимальный размер=6 мм ] ; = [ Круг, ничья, внутренний сентября=0pt, минимальный размер=7 мм ] ; = [ шрифт= ] ; \\(г ) в ( 6,5.5 ) [ высокое ] @xmath202 ; \\(a ) по ( 1.5,4 ) [ вершина ] @xmath95 ; ( Б ) В ( 4.5,4 ) [ выс ] @xmath269 ; ( C ) по ( 7.5,4 ) [ вершина ] @xmath95 ; ( Д ) в ( 10.5,4 ) [ вершина ] @xmath264 ; ( а ) ( г ) ( Б ) ; ( В ) ( Г ) ( Д ) ; в ( 0.7,4 ) @xmath268 ; в ( 3.6,4 ) @xmath17 ; в ( 6.7,4 ) @xmath35 ; в ( 9.7,4 ) @xmath263 ; \\(е ) в ( 3,2.5 ) [ вершина ] @xmath95 ; ( е ) в ( 4.5,2.5 ) [ высокое ] @xmath264 ; ( г ) в ( 6,2.5 ) [ вершина ] @xmath95 ; ( е ) ( б ) ( ф ) ; ( Б ) ( г ) ; в ( 2.3,2.7 ) @xmath267 ; в ( 3.8,2.7 ) @xmath266 ; в ( 5.35,2.7 ) @xmath2 ; \\(х ) в ( 3.5,1 ) [ вершина ] @xmath95 ; ( J ) в ( 5.5,1 ) [ вершина ] @xmath95 ; ( ч ) ( Ф ) ( К ) ; в ( 2.9,1.3 ) @xmath6 ; в ( 4.9,1.3 ) @xmath265 ; в ( г ) [ вершина ] ; в ( б ) [ вершина ] ; в ( Ф ) [ вершина ] ; лезвия большого скопления @xmath202 называется _ окончательной края _ если он используется в цикле @xmath35, который производит окончательный этап скопление @xmath202. все остальные ребра @xmath202 называются _ предпоследними ребрами _ ; обратите внимание, что любое предпоследнее ребро находится в некотором предпоследнем кластере @xmath202. мы определяем _ конечную стоимость _ @xmath202 как сумму затрат на его конечные ребра, а его _ предпоследнюю стоимость _ как сумму затрат на его предпоследние ребра; очевидно, что стоимость @xmath202 - это сумма его конечных и предпоследних затрат. мы связали окончательные и предпоследние затраты отдельно. напомним, что ребро является конечным ребром большого кластера @xmath202, если оно используется mergeclusters для формирования цикла @xmath35 на заключительной итерации, во время которой формируется @xmath202. причина, по которой мы можем ограничить стоимость конечных ребер, заключается в том, что стоимость любого такого цикла не более чем в @xmath144 раза превышает вес кластеров, содержащихся в цикле, и кластер не вносит вклад в вес более чем одного цикла за итерацию. (в этом также суть леммы [ lem : tiercost ]. ) мы формализуем эту интуицию в следующей лемме. [ lem : final ] конечная стоимость любого большого кластера @xmath202 составляет не более @xmath270, где @xmath271 - это вес @xmath202. пусть @xmath202 - произвольный большой кластер. при построении дерева @xmath260 мы связали с каждой вершиной @xmath260 стоимость цикла, используемого для формирования соответствующего кластера. чтобы привязать общую конечную стоимость @xmath202, мы должны привязать сумму затрат вершин @xmath260, связанных с кластерами конечной стадии. вес @xmath202, @xmath271 равен, по меньшей мере, сумме весов кластеров предпоследнего уровня @xmath95, которые становятся частью @xmath202. следовательно, достаточно показать, что сумма затрат вершин @xmath260, связанных с кластерами конечной стадии, самое большее в @xmath144 раза превышает сумму весов кластеров предпоследнего уровня @xmath202 @xmath95. (обратите внимание, что кластер уровня @xmath95 должен быть сформирован до итерации @xmath95, и, следовательно, он сам по себе не может быть кластером конечной стадии. ) цикл использовался для построения кластера конечной стадии @xmath136 только в том случае, если его стоимость была не более чем в @xmath144 раза больше суммы весов кластеров предпоследнего уровня @xmath95, которые становятся частью @xmath136. (более крупные кластеры могут стать частью @xmath136, но они не вносят вес в расчет плотности. ) следовательно, если @xmath136 является вершиной @xmath260, соответствующей кластеру конечной стадии, стоимость @xmath136 самое большее в @xmath144 раза превышает сумму весов его непосредственных дочерних элементов уровня @xmath95 в @xmath260. но @xmath260 - это дерево, и поэтому ни одна вершина, соответствующая кластеру предпоследнего уровня @xmath95, не имеет более одного родительского элемента. то есть вес предпоследнего кластера оплачивает только один кластер конечной стадии. следовательно, сумма затрат вершин, связанных с кластерами конечной стадии, самое большее в @xmath144 раза превышает сумму весов кластеров предпоследнего уровня @xmath95 @xmath202, и, таким образом, конечная стоимость @xmath202 составляет самое большее в @xmath270. [ lem : предпоследний ] если @xmath272 и @xmath273 являются отдельными большими кластерами одного типа, ни одно ребро не является предпоследним ребром как для @xmath272, так и для @xmath273. предположим, в порядке противоречия, что некоторое ребро @xmath85 является предпоследним ребром как @xmath272, так и @xmath273, которые являются большими кластерами типа @xmath95. пусть @xmath274 ( соответственно @xmath275 ) является предпоследним кластером из @xmath272 ( соответственно @xmath273 ), содержащим @xmath85. как предпоследние кластеры, оба @xmath274 и @xmath275 формируются перед итерацией @xmath95. но до итерации @xmath95 ни один из них не является частью большого кластера, и два небольших кластера не могут совместно использовать ребро без объединения. следовательно, @xmath274 и @xmath275 должны были быть объединены, поэтому они не могут принадлежать к отдельным большим кластерам, что дает желаемое противоречие.    [ thm : goodlargecluster ] после завершения mergeclusters по крайней мере один большой кластер имеет плотность не более @xmath206. мы определяем \"предпоследнюю плотность\" большого кластера как отношение его предпоследней стоимости к его весу.    рассмотрим общие предпоследние затраты всех крупных кластеров: для любого @xmath95 каждое ребро @xmath276 может быть предпоследним ребром не более 1 большого кластера типа @xmath95. это означает, что каждое ребро может быть предпоследним ребром не более чем в кластерах @xmath220. следовательно, сумма предпоследних затрат всех крупных кластеров составляет не более @xmath277. кроме того, общий вес всех крупных кластеров составляет не менее @xmath278. следовательно, (взвешенная) средняя предпоследняя плотность больших кластеров составляет не более @xmath279, и, следовательно, существует большой кластер @xmath202 с предпоследней плотностью не более @xmath280. следовательно, предпоследняя стоимость @xmath202 составляет не более @xmath281, а из леммы [ lem : final ] конечная стоимость @xmath202 составляет не более @xmath270. следовательно, плотность @xmath202 составляет не более @xmath282. теорема [ thm : goodlargecluster ] и лемма [ lem: segment ] вместе подразумевают, что мы можем найти решение коренной проблемы @xmath0-@xmath1vc с затратами не более @xmath191. это завершает наше доказательство теоремы [ thm : avekv ]. мы перечисляем следующие открытые проблемы: * можно ли улучшить коэффициент аппроксимации для задачи @xmath0-@xmath1vc с текущего @xmath44 до @xmath283 или лучше? было бы интересно устранить зависимость от @xmath32, чтобы получить даже @xmath284. если нет, можно ли улучшить коэффициент аппроксимации для более простой задачи @xmath0-@xmath1ec? * можем ли мы получить алгоритмы аппроксимации для задач @xmath0-@xmath8vc или @xmath0-@xmath8ec для @xmath285 ? в целом, известно немного результатов для задач, где требуется, чтобы связность вершин была больше 2, но был достигнут больший прогресс с более высокими требованиями к связности ребер. * учитывая 2-связный граф плотности @xmath146 с некоторыми вершинами, помеченными как терминалы, мы показываем, что он содержит нетривиальный цикл с плотностью не более @xmath146, и даем алгоритм поиска такого цикла. мы также нашли приближение @xmath37 для задачи нахождения нетривиального цикла с минимальной плотностью. существует ли приближение с постоянным коэффициентом для этой задачи? можно ли это решить _ точно _ за полиномиальное время? б. авербух, ю. Азар, а. Блюм и с. Вемпала. новые гарантии приближения для деревьев с минимальным весом @xmath0 и продавцов, собирающих призы., 28(1):254262, 1999. предварительная версия в _ proc.  из acm stoc _, 1995. м. х. Гоеманс и Д. п. Уильямсон. первично-дуальный метод для алгоритмов аппроксимации и его применение к задачам проектирования сетей. в книге Д. с. Хохбаума, редактора, \"алгоритмы аппроксимации для np - сложных задач\". издательство pws, 1996.

в задаче @xmath0-@xmath1vc нам дан неориентированный граф @xmath2 со стоимостью ребер и целым числом @xmath0; цель состоит в том, чтобы найти подграф с минимальной стоимостью, связанный с 2 вершинами @ xmath2, содержащий по крайней мере вершины @xmath0. немного более общая версия получается, если во входных данных также указано подмножество @xmath3 из _ terminals _, и цель состоит в том, чтобы найти подграф, содержащий по крайней мере @xmath0 терминалов. тесно связанной с задачей @xmath0-@xmath1vc и фактически ее частным случаем является задача @xmath0-@xmath1ec, в которой цель состоит в том, чтобы найти подграф с минимальной стоимостью, связанный с двумя ребрами, содержащий вершины @xmath0. задача @xmath0-@xmath1ec была введена Лау _ и др. _ @xcite, которые также дали для нее полилогарифмическую аппроксимацию. предыдущий алгоритм аппроксимации не был известенwn для более общей задачи @xmath0-@xmath1vc. мы описываем приближение @xmath4 для задачи @xmath0-@xmath1vc.