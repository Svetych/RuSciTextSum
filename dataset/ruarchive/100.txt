методы монте-карло @xcite появились около шестидесяти лет назад в связи с необходимостью оценки численных значений для различных сложных задач. эти методы эволюционировали и были применены на ранних этапах к квантовым задачам, что позволило получить точные численные решения нетривиальных квантовых задач @xcite. последовало множество улучшений этих методов, позволяющих избежать критического замедления вблизи фазовых переходов и позволяющих работать непосредственно в непрерывном воображаемом временном ограничении @xcite. в последние годы усилился интерес к методам, которые работают в каноническом ансамбле с глобальными обновлениями, но при этом предоставляют доступ к зеленым функциям @xcite. однако метод, который хорошо работает для данного гамильтониана, часто нуждается в серьезных модификациях для другого. например, добавление члена обмена кольцами с 4 участками в бозонной модели Хаббарда потребовало специальных разработок для обработки алгоритмом расширения стохастического ряда @xcite, а также алгоритмом словарной строки @xcite. это может привести к длительным задержкам. поэтому выгодно иметь в своем распоряжении алгоритм, который может быть применен к очень широкому классу гамильтонианов, не требуя каких-либо изменений. в недавней публикации @xcite был представлен алгоритм стохастической функции Грина (sgf), который отвечает этой цели. алгоритм может быть применен к любому гамильтониану решетки вида @xmath3, где @xmath1 является диагональю в выбранном базисе номера занятия, а @xmath2 имеет только положительные матричные элементы. это включает в себя все виды систем, которые могут быть обработаны другими методами, представленными в ref.@xcite, например, модели бозе - Хаббарда с ловушкой или без нее, смеси бозе - Ферми в одном измерении, модели Гейзенберга... в частности, гамильтонианы, для которых недиагональная часть @ xmath2 нетривиальна (собственный базис неизвестен), легко обрабатываются, такие как модель Бозе - Хаббарда с кольцевым обменом @ xcite или многовидовые гамильтонианы, в которых данный вид может быть превращен в другой (см. уравнение.([два вида ] ) и рис. [ плотность ] и [импульс ] для конкретного примера ). системы, для которых невозможно найти базис, в котором @xmath1 является диагональным, а @xmath2 имеет только положительные матричные элементы, как говорят, имеют `проблему знака\", которая обычно возникает с фермионными и фрустрированными системами. как и другие методы qmc, алгоритм sgf не решает эту проблему.    алгоритм позволяет измерять несколько представляющих интерес величин, таких как энергия, локальная плотность, локальная сжимаемость, корреляционные функции плотность - плотность плотности... в частности, производится выборка обмотки и предоставляется доступ к плотности сверхтекучей среды. равновременные n - образные функции Грина, вероятно, являются наиболее интересными величинами, которые могут быть измерены с помощью алгоритма, предоставляя доступ к функциям распределения импульса, которые позволяют проводить прямые сравнения с экспериментами. все подробности об измерениях приведены в ref.@xcite. Кроме того, алгоритм обладает свойством простоты в кодировании, отчасти благодаря простой схеме обновления, в которой все ходы принимаются с вероятностью 1. несмотря на такую общность и простоту, алгоритм может страдать от снижения эффективности по сравнению с другими алгоритмами в ситуациях, когда они могут быть применены. цель этой статьи - представить схему `направленного\" обновления, которая (i) сохраняет простоту и общность исходного алгоритма sgf и (ii) повышает его эффективность за счет улучшения выборки по мнимой оси времени. хотя алгоритм sgf не предназначен для того, чтобы конкурировать по скорости с другими алгоритмами, улучшение, получаемое в результате схемы направленного обновления, примечательно (см. раздел v). но что делает метод sgf сильным, так это то, что он позволяет моделировать гамильтонианы, которые невозможно обработать другими методами или которые потребовали бы специальные разработки (см. уравнение.([два вида ] ) для конкретного примера ). документ организован следующим образом: в разделе ii мы вводим обозначения и определения, используемые в ref.@xcite. в разделе iii мы предлагаем упрощение схемы обновления, используемой в исходном алгоритме sgf, и определяем, как обеспечить детальный баланс. обобщение упрощенной схемы обновления представлено в разделе iv, который представляет собой схему направленного обновления. наконец, в разделе v показано, как определить введенные параметры оптимизации, и представлены некоторые тесты алгоритма и сравнение с исходной версией. в этом разделе мы вспоминаем выражение `оператор грина\", введенное в алгоритм sgf, и расширенную функцию разбиения, которая рассматривается. хотя это и не требуется для понимания данной статьи, мы отсылаем читателя к ref.@xcite для получения полной информации об алгоритме. как и многие алгоритмы qmc, алгоритм sgf выполняет выборку функции разбиения @xmath4 алгоритм обладает свойством работать в каноническом ансамбле. чтобы определить оператор Грина, мы сначала определяем `нормализованные\" операторы создания и уничтожения, @xmath5, где @xmath6 и @xmath7 - обычные операторы создания и уничтожения бозонов, а @xmath8 - числовой оператор. из ( [ normalizedoperators ] ) можно показать следующие соотношения для любого состояния @xmath9 в представлении номера занятия, @xmath10 с частным случаем @xmath11. исходя из этого исключения, операторы @xmath12 и @xmath13 изменяют состояние @xmath9, соответственно создавая и уничтожая одну частицу, но они не изменяют норму состояния.    используя обозначение @xmath14 для обозначения двух подмножеств индексов сайта @xmath15 и @xmath16 с ограничением, что все индексы в подмножестве @xmath17 отличаются от индексов в подмножестве @xmath18 (но несколько индексов в одном подмножестве могут быть равны), мы определяем оператор грина @xmath19 с помощью @xmath20, где @xmath21 - это матрица, которая зависит от применения алгоритма @xcite. чтобы выполнить выборку функции разбиения ( [ partitionfunction ] ), рассматривается расширенная функция разбиения @xmath22 путем разбиения пропагатора @xmath23 и введения оператора green между разбитыми частями, @xmath24 определяет зависящие от времени операторы @xmath25 и @xmath26, @xmath27 и работает с номером занятия базис, в котором @xmath1 является диагональным, расширенная функция разбиения принимает форму @xmath28, где сумма @xmath29 неявно выполняется по полным наборам состояний @xmath30. мы будем систематически использовать метки @xmath31 и @xmath32 для обозначения состояний, появляющихся слева и справа от оператора green, и использовать обозначение @xmath33 для обозначения диагональной энергии @xmath34. мы также будем обозначать @xmath35 и @xmath36 временные индексы операторов @xmath2, появляющихся слева и справа от @xmath19.    в результате расширенная функция разбиения представляет собой сумму по всем возможным конфигурациям, каждая из которых определяется набором временных индексов @xmath37 и набором состояний @xmath38, @xmath39, @xmath40,@xmath41, @xmath42. алгоритм заключается в обновлении этих конфигураций с помощью оператора green. предполагая, что оператор green действует во время @xmath43, он может `создать\" оператор @xmath2 (то есть оператор @xmath2 может быть вставлен в строку оператора) в то же время, таким образом вводя новое промежуточное состояние, затем оно может быть сдвинуто на другое время. при перемещении любой оператор @xmath2, с которым сталкивается зеленый оператор, `уничтожается\" (то есть удаляется из строки оператора). предполагая перемещение влево (или вправо), создание оператора обновит состояние @xmath44 (или @xmath41 ), в то время как уничтожение обновит состояние @xmath41 ( или @xmath44 ). когда возникает диагональная конфигурация оператора green, @xmath45, такая конфигурация, связанная с расширенной функцией разделения ( [ extendedpartitionfunction ] ), также является конфигурацией, связанной с функцией разделения ( [ partitionfunction ] ). Измерения могут быть выполнены, когда это происходит (см. ref.@xcite для получения подробной информации об измерениях ). в следующем разделе представлена простая схема обновления, отвечающая требованиям эргодичности и детального баланса. прежде чем вводить направленное обновление, мы начнем с упрощения схемы обновления, используемой в исходном алгоритме sgf.      далее мы будем предполагать, что выбран левый ход оператора green. в оригинальной версии зеленый оператор @xmath26 может выбрать, создавать или нет справа от него оператор @xmath2 во время @xmath43. затем для зеленого оператора выбирается сдвиг по времени @xmath46 влево с экспоненциальным распределением в диапазоне @xmath47. если при перемещении зеленого оператора встречается оператор, то оператор уничтожается, и перемещение на этом останавливается. в результате за один ход могут возникнуть четыре возможные ситуации: 1. нет создания, сдвига, разрушения. 2. создание, сдвиг, отсутствие разрушения. 3. нет создания, сдвига, разрушения. 4. создание, сдвиг, разрушение. похоже, что первая возможность `ни создания, ни уничтожения\" на самом деле бесполезна, поскольку в строке оператора не выполняется никаких изменений. идея состоит в том, чтобы избавиться от этой возможности, заставив оператора green уничтожить оператор, если не выбрано создание. Дальнейшее упрощение можно сделать, заметив, что последняя возможность `создание, уничтожение\" не является необходимой для эргодичности алгоритма, и ее можно избежать, ограничив диапазон действия оператора. временной сдвиг после создания оператора. поэтому мы заменяем исходную схему обновления следующей: мы предполагаем, что зеленый оператор действует в момент времени @xmath43, а оператор слева от него действует в момент времени @xmath35. зеленый оператор @xmath26 выбирает создавать или нет оператора справа от него в момент времени @xmath43. если выбрано создание, то временной сдвиг @xmath46 оператора green выбирается влево в диапазоне @xmath48 с распределением вероятности, определенным ниже. если не выбрано создание, то зеленый оператор непосредственно перемещается к оператору слева от него в момент времени @xmath35, и оператор уничтожается. в результате должны быть реализованы только две возможности рассмотрено: 1. создание, сдвиг. 2. сдвиг, уничтожение. на рисунке [ simplfiedupdatescheme ] показана связанная органиграмма. в разделе iii.b объясняется, как можно обеспечить детальный баланс с помощью этой упрощенной схемы обновления.          при обновлении конфигураций в соответствии с выбранной схемой обновления нам необходимо сгенерировать различные переходы от начального к конечному состояниям с вероятностями, удовлетворяющими детальному балансу. в этом разделе мы предлагаем выбор для этих вероятностей и определяем соответствующие приемлемые коэффициенты. мы обозначаем вероятность начальной (окончательной) конфигурации через @xmath49 ( @xmath50 ). мы обозначаем через @xmath51 вероятность перехода от конфигурации @xmath17 к конфигурации @xmath52, а через @xmath53 вероятность обратного перехода. наконец, мы обозначаем через @xmath54 скорость принятия перехода от @xmath17 к @xmath52, а через @xmath55 скорость принятия обратного перехода. подробный баланс может быть записан как @xmath56 мы будем использовать решение metropolis @xcite, @xmath57 с @xmath58 мы будем использовать загрунтованные (не загрунтованные) метки для состояний и временные индексы для обозначения окончательных (начальных) конфигураций. здесь мы рассматриваем случай, когда выбирается движение влево, создается оператор справа от зеленого оператора в момент времени @xmath43 и выбирается новое состояние. затем для зеленого оператора выбирается сдвиг по времени влево в диапазоне @xmath59. важно отметить, что @xmath60 и @xmath61 соответствуют временным индексам операторов, появляющихся слева и справа от зеленого оператора после того, как был вставлен новый оператор, то есть в тот момент, когда необходимо выполнить сдвиг по времени. таким образом, у нас есть @xmath62 и @xmath63. вероятность начальной конфигурации - это вес Больцмана, появляющийся в расширенной функции разбиения ( [ extendedpartitionfunction ] ) : @xmath64 вероятность окончательной конфигурации принимает вид : @xmath65 здесь важно понимать, что оператор green только вставил справа от себя оператор @xmath66, прежде чем переместиться с от @xmath61 до @xmath67. следовательно, мы имеем равенства @xmath68, @xmath69, @xmath70 и @xmath71. вероятность @xmath51 перехода от начальной конфигурации к окончательной конфигурации равна вероятности @xmath72 перемещения влево, умноженной на вероятность @xmath73 создания, умноженной на вероятность @xmath74 выбора нового состояния @xmath75, умноженной на вероятность @xmath76 смещения зеленого оператора на @xmath77, зная , что состояния слева и справа от оператора green в момент сдвига равны @xmath78 и @xmath79 : @xmath80 вероятность обратного перехода - это просто вероятность @xmath81 правильного перемещения, умноженная на вероятность отсутствия создания, @xmath82 : @xmath83\\ ] ] из оригинальной версии алгоритма sgf мы знаем, что выбор временного сдвига с экспоненциальным распределением является хорошим выбором, поскольку он отменяет экспоненты, появляющиеся в вероятностях начальной ([ initial ] ) и конечной ( [ final ] ) конфигураций, избегая экспоненциально малых приемлемых коэффициентов. однако здесь должна использоваться другая нормализация, поскольку временной сдвиг выбран в диапазоне @xmath84 вместо @xmath47. подходящим решением является: @xmath85 несложно проверить, что приведенная выше вероятность правильно нормализована и четко определена для любого реального значения @xmath86, частный случай @xmath87 сводится к равномерному распределению @xmath88 (обратите внимание, что @xmath89 всегда является положительным числом ). для вероятности @xmath74 выбрать новое состояние @xmath75 удобное решение такое же, как и в оригинальной версии: @xmath90 складывая все вместе, коэффициент приемлемости ( [ metropolis2 ] ) становится @xmath91\\big[1-e^{-(\\tau_l^\\prime-\\tau_r^\\prime)(v_r^\\prime - v_l^\\prime)}\\big]}{v_r^\\prime - v_l^\\prime},\\end{выровнено}\\ ] ] где мы использовали обозначение @xmath92, чтобы подчеркнуть, что этот коэффициент приемлемости соответствует созданию. для остальной части этой статьи также важно отметить, что @xmath92 записывается как количество, зависящее от начальной конфигурации, умноженное на количество, зависящее от окончательной конфигурации. здесь мы рассматриваем случай, когда выбран левый ход, и оператор, расположенный слева от зеленого оператора, уничтожается. этот ход соответствует обратному описанному выше движению `создание, сдвиг\". таким образом, соответствующий коэффициент приемлемости @xmath93 получается путем инвертирования коэффициента приемлемости @xmath92, замены начального времени @xmath43 и конечного времени @xmath67 и переключения направления. однако @xmath94 представляет собой абсолютный сдвиг во времени, поэтому @xmath35 и @xmath36 не нужно заменять. мы получаем @xmath95\\big[1-e^{-(\\tau_l-\\tau_r)(v_l - v_r)}\\big ] } \\\\ & \\times & \\frac{\\big\\langle_ psi_l^\\prime\\big|\\hat\\mathcal g\\big|\\psi_r^\\prime\\big\\rangle p(\\rightarrow^\\prime)p_\\rightarrow^\\dagger(\\tau^\\prime)}{\\big\\langle\\psi_l^\\prime\\big |\\шляпа\\mathcal t\\шляпа\\mathcal g\\big|\\psi_r ^\\prime\\big\\rangle},\\end{выровнено}\\ ] ], которое записывается как количество, зависящее от начальной конфигурации, умноженное на количество, зависящее от конечной конфигурации. мы будем использовать здесь краткие обозначения @xmath96, @xmath97 и @xmath98 для обозначения соответственно величин @xmath99, @xmath100 и @xmath101. как в ссылке. @xcite, у нас есть некоторая свобода выбора вероятностей выбора левого или правого хода, @xmath72 и @xmath102, а также вероятностей создания @xmath73 и @xmath103. подходящий выбор для этих вероятностей может быть сделан для того, чтобы принять все ходы, что приводит к заметному упрощению процесса. алгоритм. для этой цели мы устанавливаем коэффициент приемлемости @xmath92 (или @xmath104) равным коэффициенту приемлемости @xmath93 (или @xmath105). это позволяет определить вероятности @xmath73 и @xmath103, @xmath106, а коэффициенты приемлемости @xmath107 и @xmath108 принимают форму @xmath109 с @xmath110 наконец, мы можем установить, что коэффициенты приемлемости @xmath111 и @xmath112 равны. это подразумевает, что @xmath113 определяет @xmath114, у нас остается единственный фактор принятия, @xmath115, который не зависит от выбранного направления и от характера движения (создание или разрушение). таким образом, все ходы могут быть приняты с использованием надлежащего повторного взвешивания, как описано в ссылке. в приложении показано, как генерировать случайные числа с соответствующим экспоненциальным распределением ( [ exponentialdistribution ] ).      хотя приведенная выше упрощенная схема обновления работает, оказывается, что она имеет низкую эффективность. это происходит из-за отсутствия `направленности\": зеленый оператор в среднем имеет вероятность @xmath116 выбрать движение влево или вправо. следовательно, оператор грина распространяется по цепочке операторов подобно `пьяному человеку\", по закону диффузии. основные процессы создания и уничтожения соответствуют шагам случайного блуждания. это говорит о том, что эффективность схемы обновления может быть повышена, если можно заставить оператора green двигаться в одном и том же направлении в течение нескольких итераций. в следующем разделе представлена модифицированная версия упрощенной схемы обновления, которая позволяет контролировать среднюю длину шагов случайного блуждания, то есть среднее количество созданий и разрушений в заданном направлении. предложенную схему направленного обновления можно считать аналогичной `направленному циклическому обновлению\", используемому в алгоритме расширения стохастического ряда @xcite, который предотвращает обратное движение червя. однако связь не должна заходить слишком далеко. действительно, картина червя, голова которого эволюционирует как в пространстве, так и в мнимом времени по вершинам, очевидна в циклическом алгоритме. в таком алгоритме оператор создания (или уничтожения), представленный головой червя, распространяется как в пространстве, так и в мнимом времени, в то время как оператор уничтожения (или создания), представленный хвостом червя, остается в состоянии покоя. цикл заканчивается, когда голова червя кусает хвост. такая картина червя не очевидна в алгоритме sgf: вместо одиночных операторов создания или уничтожения используется полный оператор грина по всему пространству, который распространяется только в мнимом времени. это создает открытые мировые линии, тем самым вводя разрывы. эти разрывы увеличиваются или уменьшаются при распространении в мнимом времени. все открытые концы мировых линий локализованы в одном и том же индексе мнимого времени. поэтому на самом деле невозможно нарисовать шаг за шагом червя, голова которого эволюционирует в пространстве и мнимом времени, пока он не укусит себя за хвост. в этом разделе мы представляем схему направленного обновления, которая получается путем незначительного изменения упрощенной схемы обновления, сохраняя, таким образом, простоту и общность алгоритма.      предполагая, что выбран левый ход, зеленый оператор выбирает между началом хода путем создания или уничтожения. после создания (или уничтожения) оператора зеленый оператор может выбрать продолжать движение в том же направлении и уничтожить (или создать) с вероятностью @xmath117 (или @xmath118) или остановиться. если он продолжает двигаться, то происходит разрушение (или создание), и оператор green может выбрать продолжение движения и создание (или уничтожение) с вероятностью @xmath118 (или @xmath117)... и так далее, пока он не решит остановиться. если последним действием перемещения является создание, то выбирается сдвиг по времени. органиграмма представлена на рисунке [ directedupdatescheme ].          чтобы обеспечить детальный баланс, в дополнение к коэффициентам приемлемости @xmath92 и @xmath93, нам необходимо определить новые коэффициенты приемлемости формы @xmath119 и @xmath120. сначала мы определяем новые выражения @xmath92 и @xmath93, полученные в результате схемы направленного обновления. для @xmath92 предыдущая вероятность @xmath51 должна быть умножена на вероятность остановить ход после создания, @xmath121. предыдущая вероятность @xmath53 должна быть умножена на вероятность остановить ход после уничтожения, @xmath122. мы получаем для @xmath92 и @xmath93 новые выражения : @xmath123}{\\big\\langle_ psi_l\\big|\\hat\\mathcal g\\big |\\psi_r\\big\\rangle p(\\leftarrow)p_\\leftarrow^\\dagger(\\tau ) } \\\\ & \\times & \\frac{p(\\rightarrow^\\prime)\\big[1-p_\\rightarrow^\\dagger(\\tau^\\prime)\\big]\\big[1-e^{-(\\tau_l^\\prime-\\tau_r^\\prime)(v_r^\\prime - v_l^\\prime)}\\big]}{\\big[1-p_\\leftarrow^{kd}(\\tau^\\prime)\\big]\\big(v_r^\\prime - v_l^\\prime\\big ) } \\\\\\nonumber q_\\leftarrow^d & = & \\frac{\\big[1-p_\\rightarrow^{kd}(\\tau)\\big]\\big(v_l - v_r\\big)}{p(\\leftarrow)\\big[1-p_\\leftarrow^\\dagger(\\tau)\\big]\\big[1-e^{-(\\tau_l-\\tau_r)(v_l - v_r)}\\big ] } \\\\ & \\times & \\frac{\\big\\langle_ psi_l ^\\prime\\big|\\hat\\mathcal g \\big |\\psi_r ^\\prime\\big\\rangle p(\\rightarrow^\\prime)p_\\rightarrow^\\dagger(\\tau^\\prime)}{\\big\\langle\\psi_l ^\\prime\\big|\\hat\\mathcal t\\hat\\mathcal g\\big|\\psi_r^\\prime\\big\\rangle\\big[1-p_\\leftarrow^{kc}(\\tau^\\prime)\\big]},\\end{выровнено}\\ ] ] здесь мы рассматриваем случай, когда выбран левый ход, оператор создается справа от зеленого оператора, и создается новое состояние. избранный. затем оператор, расположенный слева от зеленого оператора, уничтожается. используя верхние индексы @xmath124 для обозначения промежуточных конфигураций между начальной и конечной конфигурациями, последовательность выглядит следующим образом 1. @xmath125 2. @xmath126 3. @xmath127, где у нас есть @xmath128, @xmath129, @xmath130 и @xmath131. вероятность перехода от начальной конфигурации к окончательной конфигурации равна вероятности @xmath72 выбрать движение влево, умноженной на вероятность @xmath73 создать оператор в момент времени @xmath43, умноженной на вероятность @xmath132 выбрать новое состояние @xmath133, умноженной на вероятность @xmath134 продолжить движение и уничтожить, умноженное на вероятность @xmath135 остановить ход после уничтожения : @xmath136\\ ] ] вероятность обратного хода точно симметрична : @xmath137\\ ] ] важно заметить, что, когда в промежуточной конфигурации @xmath7 время @xmath138 оператора слева время оператора green равно @xmath35, а время оператора @xmath139 справа от оператора green равно @xmath43. таким образом, коэффициент приемлемости принимает вид @xmath140}{\\big\\langle_ psi_l\\big|\\hat\\mathcal g\\big|\\psi_r\\big\\rangle p(\\leftarrow)p_\\leftarrow^\\dagger(\\tau ) } \\\\\\nonumber & \\times & \\frac{e^{-\\big(\\tau_l^a-\\tau_r^a\\big)v_r^a}p_\\rightarrow^{kd}(a)}{e^{-\\big(\\tau_l^a-\\tau_r^a\\big)v_l^a}p_\\leftarrow^{kd}(a ) } \\\\ & \\times & \\frac{\\big\\langle_ psi_l^\\prime\\big|\\hat\\mathcal g \\big |\\psi_r ^\\prime\\big\\rangle p(\\rightarrow^\\prime)p_\\rightarrow^\\dagger(\\tau^\\prime)}{\\big\\langle_ psi_l^\\prime\\big|\\hat\\mathcal t\\hat\\mathcal g\\big|\\psi_r^\\prime\\big\\rangle\\big[1-p_\\leftarrow^{kc}(\\tau^\\prime)\\big]},\\end{выровнено}\\ ] ] и записывается как количество, зависящее от начальной конфигурации, умноженное на количество, зависящее от промежуточной конфигурации @xmath7, умноженное на количество, зависящее от конечной конфигурации. в оставшейся части статьи полезно определить промежуточный коэффициент приемлемости, @xmath141 здесь мы рассматриваем случай, когда выбирается левый ход, оператор слева от зеленого оператора уничтожается, затем справа от него создается оператор и выбирается новое состояние. наконец, выбирается временной сдвиг. последовательность конфигураций следующая 1. @xmath125 2. @xmath142 3. @xmath127, где у нас есть @xmath143 и @xmath144. вероятность перехода от начальной конфигурации к окончательной конфигурации равна вероятности @xmath72 выбрать движение влево, умноженной на вероятность @xmath145 не создавать, умноженной на вероятность @xmath146 продолжать двигаться и создавать, умноженной на вероятность @xmath74 выбрать новое состояние @xmath75, умноженной на вероятность @xmath121, чтобы остановить ход после уничтожения, умножьте вероятность @xmath76 сдвинуть зеленый оператор на @xmath77 : @xmath147p_\\leftarrow^{kc}(a)p_\\leftarrow(\\psi_r^\\prime ) \\\\ & \\times & \\big[1-p_\\leftarrow^{kd}(\\tau^\\prime)\\big]p_\\leftarrow^{l ^\\prime r^\\prime}(\\tau ^\\prime-\\tau_r^\\prime)\\end{выровнено}\\ ] ] вероятность обратного хода точно симметрична : @xmath148p_\\rightarrow^{kc}(a)p_\\rightarrow(\\psi_l ) \\\\ & \\times & \\big[1-p_\\rightarrow^{kd}(\\tau)\\big]p_\\rightarrow^{lr}(\\tau_l-\\tau)\\end{выровнено}\\ ] ] коэффициент приемлемости принимает вид @xmath149\\big(v_l - v_r\\big)}{p(\\leftarrow)\\big[1-p_\\leftarrow^\\dagger(\\tau)\\big]\\big[1-e^{-(\\tau_l-\\tau_r)(v_l - v_r)}\\big ] } \\\\ \\nonumber & \\times & \\frac{\\big\\langle_ psi_l ^a\\big |\\hat\\mathcal g \\hat\\mathcal t\\big |\\psi_r ^a\\big\\rangle p_\\rightarrow^{kc}(a)}{\\big\\langle_ psi_l ^a\\big|\\hat\\mathcal t\\hat\\mathcal g\\big|\\psi_r ^a\\big\\rangle p_\\leftarrow^{kc}(a) } \\\\ & \\times & \\frac{p(\\rightarrow^\\prime)\\big[1-p_\\rightarrow^\\dagger(\\tau^\\prime)\\big]\\big[1-e^{-(\\tau_l^\\prime-\\tau_r^\\prime)(v_r^\\ простое число - v_l^\\простое число)}\\big]}{\\big[1-p_\\leftarrow^{kd}(\\tau^\\prime)\\big]\\big(v_r^\\prime - v_l^\\prime\\big)},\\end{выровнено}\\ ] ] и записывается как величина, которая зависит от начальной конфигурации, умноженное на количество, зависящее от промежуточной конфигурации @xmath7, умноженное на количество, зависящее от конечной конфигурации. в оставшейся части статьи полезно определить промежуточный коэффициент приемлемости, @xmath150 здесь мы рассматриваем случай, когда выбирается левый ход, справа от зеленого оператора создается оператор, затем оператор слева от него уничтожается, затем справа от него создается второй оператор. наконец, выполняется сдвиг по времени зеленого оператора. последовательность конфигураций следующая 1. @xmath125 2. @xmath126 3. @xmath151 4. @xmath152, учитывая промежуточные конфигурации @xmath7 и @xmath153 между начальной и конечной конфигурациями, легко показать, что соответствующий коэффициент приемлемости может быть записан @xmath154 мы рассматриваем здесь случай если выбран левый ход, оператор слева от зеленого оператора уничтожается, затем справа от него создается оператор. наконец, второй оператор слева от зеленого оператора уничтожается. последовательность конфигураций следующая 1. @xmath155 2. @xmath156 3. @xmath157 4. @xmath127, учитывая промежуточные конфигурации @xmath7 и @xmath153 между начальной и конечной конфигурациями, легко показать, что соответствующий коэффициент приемлемости может быть записан @xmath158 это прямолинейно, чтобы показать что коэффициенты приемлемости формы @xmath159, @xmath160, @xmath161 ( или @xmath162, @xmath163, @xmath164 ) могут быть выражены как произведения коэффициента приемлемости @xmath92 ( или @xmath93 ) и промежуточных коэффициентов @xmath165 и @xmath166.    таким же образом, коэффициенты приемлемости формы @xmath167, @xmath168, @xmath169 ( или @xmath170, @xmath171, @xmath172 ) могут быть выражены как произведения коэффициента приемлемости @xmath173 ( или @xmath174 ) и промежуточных коэффициентов @xmath165 и @xmath166.      здесь снова можно воспользоваться свободой, которая у нас есть для выбора вероятностей @xmath72, @xmath175, @xmath118 и @xmath117 (или @xmath102, @xmath176, @xmath177 и @xmath178). правильный выбор этих вероятностей может быть сделан для того, чтобы позвольте нам принять все ходы, простота и общность являются лейтмотивом алгоритма sgf.    для этой цели мы устанавливаем равенство всех приемлемых коэффициентов, соответствующих левым (или правым) ходам. для этого требуется, чтобы промежуточные коэффициенты приемлемости @xmath165 и @xmath166 ( или @xmath179 и @xmath180 ) были равны 1. это реализуется, если @xmath181, где @xmath182 и @xmath183 являются параметрами оптимизации, принадлежащими @xmath184. настраивая эти параметры, можно управлять средней длиной шагов оператора green. обратите внимание, что мы явно исключили @xmath185 из допустимых значений для этих параметров оптимизации. это необходимо для того, чтобы у зеленого оператора был шанс завершить работу в диагональной конфигурации, @xmath45. действительно, выбор @xmath186 систематически приводил бы к значениям @xmath185 для вероятностей @xmath187 и @xmath188 для диагональных конфигураций. следовательно, зеленый оператор никогда не остановится в диагональной конфигурации, и никакие измерения не могут быть выполнены. здесь важно отметить, что величины @xmath96, @xmath97 и @xmath98 вычисляются между состояниями слева и справа от оператора green, которые присутствуют в тот момент, когда эти величины необходимы, а также для временных индексов @xmath189 и @xmath190 и потенциалов @xmath191 и @xmath192. все коэффициенты приемлемости, соответствующие заданному направлению распространения, становятся равными, если мы выберем для вероятностей создания: @xmath193(v_l - v_r)}{\\big[1-p_\\rightarrow^{kc}\\big]\\big[1-e^{-(\\tau_l-\\tau_r)(v_l - v_r)}\\big ] } } \\\\ & & p_\\rightarrow^\\dagger(\\tau)=\\frac{\\big\\langle\\шляпа\\mathcal t\\шляпа\\mathcal g\\big\\rangle}{\\big\\langle\\шляпа\\mathcal t\\шляпа\\mathcal g\\big\\rangle+\\big\\langle\\hat\\mathcal g\\big\\rangle\\frac{\\big[1-p_\\leftarrow ^{kd}\\big](v_r - v_l)}{\\big[1-p_\\leftarrow^{kc}\\big]\\big[1-e^{-(\\tau_l-\\tau_r)(v_r - v_l)}\\big]}},\\end{выровнено}\\ ] ] наконец, все коэффициенты приемлемости становятся независимыми от направления распространения, если мы выбираем @xmath194 и @xmath195 с @xmath196\\frac{\\big\\langle\\hat\\mathcal g\\hat\\mathcal t\\big\\rangle}{\\big\\langle\\hat\\mathcal g\\big\\rangle}+\\frac{\\big[1-p_\\rightarrow^{kd}\\big](v_l - v_r)}{\\big[1-e^{-(\\tau_l-\\tau_r)(v_l - v_r)}\\big ] } \\\\ r_\\rightarrow(\\tau)=\\big[1-p_\\leftarrow^{kc}\\big]\\frac{\\big\\langle\\hat\\mathcal t\\hat\\mathcal g\\big\\rangle}{\\big\\langle\\hat\\mathcal g\\big\\rangle}+\\frac{\\big[1-p_\\leftarrow^{kd}\\big](v_r - v_l)}{\\big[1-e^{-(\\tau_l-\\tau_r)(v_r - v_l)}\\big]}.\\end{выровнено}\\ ] ] в результате все ходы могут быть приняты снова, обеспечивая максимальную простоту процесса алгоритм. у нас все еще есть некоторая свобода в выборе параметров оптимизации @xmath182 и @xmath183. это обсуждается в следующем разделе. из центральной предельной теоремы мы знаем, что полоса ошибок, связанная с любой измеряемой величиной, должна уменьшаться как квадратный корень из числа измерений или, что эквивалентно, квадратный корень из времени моделирования. следовательно, имеет смысл определить эффективность @xmath197 алгоритма qmc с помощью @xmath198, где @xmath199 представляет набор всех параметров оптимизации алгоритма, @xmath200 - интересующая измеренная величина, @xmath201 - время моделирования, а @xmath202 - панель ошибок, связанная с измеренной величиной @xmath200. это определение гарантирует, что @xmath197 не зависит от времени моделирования. в результате, чем больше @xmath197, тем эффективнее алгоритм.    в данном случае у нас есть @xmath203, в то время как @xmath204 для исходного алгоритма sgf. здесь полезно понимать, что по симметрии средние значения @xmath118 и @xmath177 ( и @xmath117 и @xmath178 ) должны быть равны. поэтому мы определяем @xmath205 и @xmath206. представляется разумным ввести условие равномерной выборки, @xmath207. это условие может быть выполнено путем динамической настройки значений @xmath182 и @xmath183 во время процесса термализации. для этой цели мы вводим новый параметр оптимизации @xmath208 и время от времени применяем следующий алгоритм при термализации (мы начинаем с @xmath209): @xmath210 таким образом, у нас остается параметр оптимизации @xmath211. чтобы определить оптимальное значение, мы рассмотрели 2 разных гамильтониана @xmath212 и @xmath213 и оценили эффективность алгоритма при сканировании @xmath211. первый гамильтониан, который мы рассмотрели, описывает свободные хардкорные бозоны и является точно разрешимым, @xmath214, где сумма проходит по парам первых соседних узлов, а @xmath215 является скачкообразным параметром. второй гамильтониан весьма нетривиален и описывает смесь атомов и двухатомных молекул, со специальным термином, допускающим преобразования между двумя видами @xcite, @xmath216, где @xmath217 и @xmath218 ( @xmath219 и @xmath220 ) являются операторами создания и уничтожения атомов (молекул), @xmath221, @xmath222, @xmath223, @xmath224 и @xmath225 являются соответственно параметром скачкообразного взаимодействия атомов, параметром скачкообразного взаимодействия молекул, параметром взаимодействия атомов на месте, параметром взаимодействия молекул на месте и параметром межвидового взаимодействия. условие преобразования настраивается с помощью параметра @xmath226 и не сохраняет количество @xmath227 атомов или количество @xmath228 молекул. однако общее количество частиц @xmath229 сохраняется и является каноническим ограничением. параметр @xmath230 позволяет контролировать соотношение между количеством атомов и молекул. применение алгоритма sgf к гамильтониану ([ два вида ] ) подробно описано в ref.@xcite. изменения, происходящие со схемой направленного обновления, полностью независимы от выбранного гамильтониана. в следующей таблице показано среднее число созданий и разрушений за один шаг, @xmath231, и относительная эффективность @xmath232 алгоритма, примененного к @xmath212 при половинном заполнении, для которого мы измерили энергию @xmath233, плотность сверхтекучей жидкости @xmath234 и количество частиц с нулевым импульсом. состояние @xmath235 : . относительная эффективность алгоритма, примененного к @xmath212 при половинном заполнении для энергии, плотности сверхтекучей среды и числа частиц в состоянии с нулевым импульсом. [ колы=\"^,^,^,^,^\", options=\"header \", ] хотя наилучшее значение @xmath211 зависит от рассматриваемого гамильтониана и измеряемой величины, представляется, что хорошим компромиссом является выбор @xmath211 между @xmath236 и @xmath237. повышение эффективности является замечательным. далее мы проиллюстрируем применимость алгоритма к задачам с неоднородными потенциалами, добавив параболическую ловушку к гамильтониану ( [ два вида ]): @xmath238 параметры @xmath239 и @xmath240 позволяют управлять кривизной ловушки, связанной с атомами и молекулами, соответственно, и @xmath31 - это количество узлов решетки. включение этого члена в алгоритм тривиально, поскольку изменяются только значения диагональных энергий @xmath241 и @xmath242. на рисунках ( [ плотность ] ) и ( [ импульс ] ) показаны профили плотности и функции распределения импульса, полученные для системы с участками решетки @xmath243, первоначально загруженными атомами @xmath244 и без молекул, и параметрами @xmath245, @xmath246, @xmath247, @xmath248, @xmath249, @xmath250, @xmath251, @xmath252, @xmath253 и @xmath254. представленные результаты были получены путем выполнения обновлений @xmath255 для термализации и обновлений @xmath256 с измерениями (обновление следует понимать как появление диагональной конфигурации). время моделирования составляет около 8 часов на дешевом 32-разрядном ноутбуке с процессором 1 ГГц, с реализацией алгоритма, включающего динамические структуры с указателями (см. ref.@xcite ).    ) на гамильтониан ( [ два вида ] ). полосы ошибок меньше размеров символов и являются самыми большими в окрестности индексов сайта 23 и 47, где они равны размеру символов., scaledwidth=45,0% ] ) гамильтониану ( [ два вида ] ). полосы ошибок меньше размеров символов и являются самыми большими для @xmath257, где они равны размеру символов., scaledwidth=45,0% ] мы представили схему направленного обновления для алгоритма sgf, которая обладает свойствами сохранения простоты и общности исходного алгоритма и улучшает значительно повышает его эффективность. я хотел бы выразить особую благодарность Питеру Дентениру за полезные предложения. эта работа является частью исследовательской программы `stichting voor fundamenteel onderzoek der materie ( fom)\", которая финансируется `nederlandse organisatie voor wetenschappelijk onderzoek\" ( nwo). \"здесь мы описываем, как генерировать числа с соответствующим экспоненциальным распределением ( [ exponentialdistribution ] ). предполагая, что в нашем распоряжении имеется генератор однородных случайных чисел, который генерирует случайную величину @xmath258 с распределением @xmath259 для @xmath260, мы хотели бы найти функцию @xmath52, такую, чтобы случайная величина переменная @xmath261 генерируется с распределением @xmath262, где @xmath46 и @xmath263 являются параметрами экспоненциального распределения. из-за отношения @xmath261 вероятность найти @xmath264 в диапазоне @xmath265 должна быть равна вероятности найти @xmath258 в диапазоне @xmath266. это подразумевает условие @xmath267 с @xmath268. таким образом, у нас есть @xmath269, принимая антипроизводную по отношению к @xmath270 по обе стороны уравнения, мы получаем @xmath271, где @xmath272 - константа. эта константа и правильный знак определяются путем наложения условий @xmath273 и @xmath274. в результате, если @xmath270 является реализацией @xmath258, то реализация @xmath264 задается @xmath275.\\ ] ] 10 Николас Метрополис и С. Улам, журнал американской статистической ассоциации, номер 247, том 44 (1949). 

в недавней публикации мы представили алгоритм стохастической функции Грина (sgf), который обладает свойствами быть общим и простым в применении к любому гамильтониану решетки вида @ xmath0, где @xmath1 является диагональю в выбранном базисе номера занятия, а @xmath2 имеет только положительные матричные элементы. здесь мы предлагаем модифицированную версию схемы обновления, которая сохраняет простоту и общность исходного алгоритма sgf и значительно повышает его эффективность.