алгоритм, представленный в этой статье, решает задачу * численного * определения декомпозиции конечномерного неприводимого унитарного линейного представления (\"unrep\" в дальнейшем) группы относительно унитарных неприводимых представлений (irreps) данной подгруппы. точнее, пусть @ xmath1 - компактная группа Ли, а @ xmath2 - конечномерное неприводимое унитарное представление ее, т.е. @ xmath3 - групповой гомоморфизм, удовлетворяющий следующим трем условиям: @xmath4 здесь, @xmath5 - комплексное гильбертово пространство с внутренним произведением @xmath6, @xmath7 - группа из унитарных операторов на @xmath5, а @xmath8 обозначает сопряженный.    условия ( 1 ) ( 3 ) выше определяют * унитарное представление * @xmath9 группы @xmath1. представление называется * неприводимым *, если нет надлежащих инвариантных подпространств @xmath5, т.е. если любое линейное подпространство @xmath10 таково, что @xmath11 для всех @xmath12, то @xmath13 - это либо @xmath14, либо @xmath5. поскольку группа @xmath1 компактна, любое неприводимое представление @ xmath1 будет конечномерным с размерностью, скажем, @xmath15 ( @xmath16 ).    рассмотрим замкнутую подгруппу @xmath17. ограничение @xmath18 на @xmath19 определит унитарное представление @xmath19, которое в общем случае является приводимым, то есть оно будет обладать инвариантными подпространствами @xmath20 такими, что @xmath21 для всех @xmath22. если мы обозначим через @xmath23 семейство классов эквивалентности повторений @xmath19 (напомним, что два унитарных представления @xmath19, @xmath24 и @xmath25, эквивалентны, если существует унитарное отображение @xmath26 такое, что @xmath27 для всех @xmath28 ), то @xmath29, где @xmath30 являются неотрицательные целые числа, @xmath31 обозначает подмножество в классе неотрицательных чисел группы @xmath19, т.е. каждое @xmath32 обозначает конечномерное неотрицательное число @xmath19, образованное парой @xmath33, а @xmath34 обозначает прямую сумму линейного пространства @xmath35 с самим собой @xmath30 раз. таким образом, семейство неотрицательных целых чисел @xmath30 обозначает кратность неотрицательных чисел @xmath36 в @xmath9. числа @xmath30 удовлетворяют @xmath37, где @xmath38, а инвариантные подпространства @xmath20 имеют размерность @xmath39. Обратите внимание, что унитарный оператор @xmath40 будет иметь соответствующую блочную структуру: @xmath41, где @xmath42. задача определения ортонормированного базиса @xmath5, адаптированного к декомпозиции, будет называться * задачей Клебша Гордана * из @xmath9 относительно подгруппы @xmath19. чтобы быть более точным, задача Клебша Гордана о представлении @ xmath18 @ xmath1 в @xmath5 относительно подгруппы @xmath19 состоит в нахождении ортонормированного базиса @ xmath5, @xmath43, такого, что каждое семейство @xmath44 для данного @xmath32 определяет ортонормированный базис @xmath35. таким образом, учитывая произвольный ортонормированный базис @xmath45, мы вычисляем унитарную матрицу @xmath46 @xmath47 с элементами @xmath48 таким образом, что @xmath49 коэффициенты @xmath50 матрицы @xmath47 обычно выражаются символом @xmath51 и называются * коэффициентами Клебша Гордана* разложения. исходная проблема Клебша Гордана берет свое начало в композиции двух квантовых систем, обладающих одной и той же группой симметрии: пусть @xmath52 и @xmath53 обозначают гильбертовы пространства, соответствующие, соответственно, двум квантовым системам @xmath54 и @xmath55, которые поддерживают соответствующие неотрицательные @xmath56 и @xmath57 группы ли @xmath1. затем составная система, гильбертово пространство которой равно @xmath58, поддерживает unrep группы продуктов @xmath59. взаимодействие между обеими системами приводит к тому, что составная система обладает только @xmath1 в качестве группы симметрии, рассматривая диагональную подгруппу @xmath60 группы продуктов. представление тензорного произведения @xmath61 больше не будет неприводимым по отношению к подгруппе @xmath62, и мы будем вынуждены рассмотреть его разложение на неприводимые компоненты. значительные усилия были приложены для вычисления матрицы Клебша Гордана для различных ситуаций, представляющих физический интерес. например, группы @xmath63 широко обсуждались (см. @xcite, @xcite и ссылки в них), поскольку при рассмотрении групп @xmath64 и @xmath0 матрица Клебша Гордана обеспечивает мультиплетную структуру и спиновые компоненты составной системы частиц (см. @xcite, @xcite ). однако все эти результаты критически зависят от алгебраической структуры базовой группы @xmath1 (и подгруппы @xmath19), и до сих пор не было известно алгоритма для эффективного вычисления матрицы Клебша Гордана для общей подгруппы @ xmath17 произвольной компактной группы @xmath1.    с другой стороны, проблема определения декомпозиции неприводимого представления относительно данной подгруппы не рассматривалась с числовой точки зрения. кратность данного неприводимого представления @xmath33 компактной группы @xmath1 в конечномерном представлении @xmath65 задается внутренним произведением @xmath66, где @xmath67 и @xmath68, @xmath69 обозначают символы соответствующих представлений, а @xmath70 обозначает стандартное внутреннее произведение центрального функции относительно (левоинвариантной) меры Хаара в @xmath1. следовательно, если известны символы @xmath71 неприводимых представлений @xmath1, вычисление кратностей становится, в принципе, простой задачей. более того, учитывая символы @xmath71 неприводимых представлений, метод проектора позволил бы нам явно построить матрицу Клебша Гордана (* ? ? ? 4 ). однако, если неприводимые представления @xmath19 заранее неизвестны (или явно не описаны), не существует простого способа определения кратностей @xmath30.    опять же, по крайней мере, в принципе, вычисление неприводимых представлений конечной группы может быть достигнуто путем построения ее таблицы символов, т.е. унитарной матрицы @xmath72, где @xmath73 - число классов сопряженности группы, но опять же, не существует численного алгоритма общего назначения для этого это. недавние разработки в области квантовой групповой томографии требуют работы с широким семейством представлений большого класса групп, компактных или нет, и их подгрупп (смотрите @xcite и ссылки на него для получения недавнего обзора по этому вопросу). квантовая томография позволяет расширить идеи стандартной классической томографии для анализа состояний квантовых систем. одной из реализаций квантовой томографии является квантовая групповая томография. квантовая групповая томография основана на квантовых системах, поддерживающих представления групп. такие представления позволяют строить соответствующие томограммы для заданных квантовых состояний @xcite, @xcite, @xcite. следовательно, становится все более актуальным иметь новые инструменты, способные эффективно обрабатывать групповые представления и их разложения. оказывается, именно идеи и методы квантовой томографии дают ключ к разгадке численного алгоритма, представленного в этой работе. более конкретно, * смешанные адаптированные квантовые состояния*, т.е. матрицы плотности *, адаптированные * к заданному представлению, будут использоваться для вычисления матрицы Клебша Гордана. раздел [ sec: предварительные сведения ] будет посвящен представлению проблемы, которую мы хотим решить. в разделе [ sec : general_outline ] представлено несколько результатов, которые помогут нам показать корректность алгоритма. подробности численного алгоритма содержатся в разделе [ the_algorithm : sec ], в то время как раздел [ sec : примеры ] охватывает различные примеры и приложения алгоритма, среди них декомпозиция регулярных представлений любой конечной группы и декомпозиция многочастичных систем спиновых частиц. примечательно, что предложенный здесь алгоритм не требует априорного знания неприводимых представлений групп, и сами неприводимые представления возвращаются в качестве результатов алгоритма. это делает предлагаемый алгоритм эффективным инструментом для вычисления неприводимых представлений, в принципе, любой конечной или компактной группы. для ясности большая часть анализа будет выполнена в случае конечных групп. однако следует отметить, что все утверждения и доказательства могут быть легко перенесены на компактные группы путем замены конечных сумм по элементам группы соответствующими интегралами по группе относительно нормализованной меры Хаара на ней. некоторые дополнительные замечания и результаты будут обсуждаться в конце в разделе [ sec : обсуждение ]. итоговый результат содержит численные результаты для примеров, рассмотренных в разделе [ sec : примеры ]. пусть @xmath1 - конечная группа порядка @xmath74, и пусть @xmath75 - подгруппа, не обязательно нормальная к @xmath1, порядка @xmath76. мы помечаем элементы @xmath1 как @xmath77, где первые элементы @xmath78 соответствуют элементам подгруппы @xmath19, т.е. @xmath79. в дальнейшем общий элемент в группе @xmath1 будет просто обозначаться @xmath12, если только не требуется какая-либо конкретная индексация. пусть @ xmath18 - унитарное неприводимое представление @ xmath1 в конечномерном гильбертовом пространстве @xmath5, @xmath80, и пусть @xmath81, @xmath82 - любой заданный ортонормированный базис @xmath5. мы обозначим через @xmath83_{i, j=1}^{n}\\ ] ] унитарную матрицу, связанную с @xmath84, @xmath69, в выбранном базисе, т.е. @xmath85 для каждого @xmath86. ограничение представления @xmath18 подгруппой @xmath19, иногда обозначаемой @xmath87 и называемой _ приведенным представлением _ из @xmath18 в @xmath19, будет, в общем, приводимым, даже если @xmath18 неприводим. обратите внимание, что унитарная матрица, связанная с @xmath88, @xmath28, является просто подматрицей @xmath89, полученной путем ограничения нас элементами подгруппы @xmath19.    смешанное состояние в @xmath5, также называемое _ матрицей плотности _, представляет собой @xmath46 нормализованную эрмитову положительную полуопределенную матрицу @xmath90, т.е. @xmath91, если унитарное представление @xmath18 из @xmath1 неприводимо, тогда любое состояние @xmath90 может быть записано как @xmath92 для доказательства этой формулы можно использовать соотношения ортогональности Шура: @xmath93, где @xmath94 обозначает комплексно сопряженное, а @xmath95 и @xmath96 обозначают, соответственно, элементы унитарных матриц @xmath97 и @xmath98.xmath98 связан с неприводимыми представлениями @xmath33 и @xmath99 группы @xmath1 относительно заданных произвольных ортонормированных базисов в @xmath35 и @xmath100. давайте теперь рассмотрим состояние @xmath90, удовлетворяющее соотношениям ортогональности @xmath101 ясно, что из-за уравнения такое состояние проверяет @xmath102 [ adapted_def ] состояние @xmath90 в гильбертовом пространстве @xmath5, поддерживающее unrep группы @xmath1, называется * адаптированным * к закрытой подгруппе @xmath19 если @xmath103 для @xmath104.    другими словами, состояние @xmath90, адаптированное к подгруппе @xmath19 конечной группы @xmath1, должно иметь вид @xmath105, даже если приведенное представление @xmath87 является приводимым. ввиду важной роли, которую они будут играть в алгоритме, давайте теперь кратко обсудим роль внутренних произведений @xmath106 в области квантовой теории: учитывая линейный оператор @xmath54 на @xmath5 и состояние @xmath90, число @xmath107 называется ожидаемым значением оператора @xmath54 находится в состоянии @xmath90 и, следовательно, обозначается как @xmath108. если оператор @xmath54 самосопряжен, ожидаемое значение @xmath108 является действительным числом, и оно действительно представляет ожидаемое значение измерения наблюдаемого, описанного оператором @xmath54 в квантовой системе в состоянии @xmath90.    на языке квантовой томографии групповая функция @xmath109 определяется коэффициентами в разложении, записанном в уравнении, @xmath110 и называется характеристической функцией состояния @xmath90, связанной с представлением @xmath65, или, в зависимости от ударения, размытым символом состояния @xmath65. представление @xmath18 по отношению к состоянию @xmath90 ( см. @xcite ). можно легко проверить, что характеристическая функция @xmath111 всегда положительно полуопределена, т.е. @xmath112 для всех @xmath113, @xmath114 и @xmath115, а также @xmath116 и @xmath117. Обратите внимание, что если состояние @xmath90 равно @xmath118, то характеристическая функция @xmath111 является стандартным символом @xmath119 из представления @xmath120. более того, если представление @xmath120 является тривиальным, то @xmath121 для всех @xmath12. теперь мы в состоянии указать, что является конечной целью нашего алгоритма: вычисление так называемой матрицы Клебша Гордана.    [ cg_matrix_def ] пусть @xmath1 - группа, @xmath9 - неприводимое унитарное представление @xmath1, а @xmath19 - замкнутая подгруппа @xmath1. в * клебша Гордана матрицы * связанные с @xmath122 и @xmath9 является @xmath46 матрицы @xmath47 такие, что @xmath123{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\mbox с{\\огромным{$0 $ } } & \\\\ & & & \\hspace{-1,7 см } { \\rotatebox{-46}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\\\ & \\hspace{-1.8 см}\\mbox с{\\огромным{$0 $ } } & & & \\hspace{-1.4 см } { \\rotatebox{-46}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\\\ & & & & & \\hspace{-1.65 см}\\mathds{1}_{c_n}\\otimes д^н(ч ) \\конец{pmatrix все},\\ ] ] для каждого @xmath22, где @xmath124 являются матрицами, определенными в @xmath125, в @xmath126, несколько матриц, связанных с irreps подгруппы @xmath19 и @xmath127 стенды для товара матрица Кронекера определяется как @xmath128{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & ох{1Н}б \\\\ ох{21}в B & \\hspace{-0.3 см } ох{22}b и { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&a_{2n}b\\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{-0.6 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } \\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{0,8 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt}}}}\\\\ \\vspace можно{0,1 см}\\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & & \\hspace{0.3 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.10им}\\hfill\\kern0pt}}}}\\\\ ох{М1}б & \\hspace{-0.3 см}ох{м2}B и { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & ох{МН}б \\конец{pmatrix все}\\ ] ] для произвольных матриц @xmath129 и @xmath55.    поскольку унитарное представление уникально (унитарные преобразования по модулю внутри каждого собственного инвариантного подпространства @xmath130 или перестановки среди @xmath130 ), матрица Клебша Гордана также уникальна (за исключением таких преобразований), (более подробную информацию об этом смотрите @xcite). наконец, давайте уточним, какие адаптированные состояния мы будем использовать в алгоритме. как мы увидим, такие состояния должны будут удовлетворять определенным условиям невырожденности: учитывая любое адаптированное состояние @xmath90, мы знаем, что, согласно ( [ адаптировано ] ), @xmath90 является линейной комбинацией представлений @xmath131, поэтому матрица Клебша Гордана @xmath47 в определении [ cg_matrix_def ] будет блокировать - расположить по диагонали @xmath90 в виде @xmath132{\\makebox[1.6em]{\\xleaders\\hbox{$\\cdot$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\mbox{\\huge{0 } } & \\\\ & & & \\ hspace{-0.4 cm } { \\rotatebox{-46}{\\makebox[0pt]{\\makebox[1.6em]{\\xleaders\\hbox{$\\cdot$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\\\ & \\ hspace{-0,8 см}\\mbox{\\огромный{0 } } & & & \\hspace{-0,1 см } { \\rotatebox{-46}{\\makebox[0pt]{\\makebox[1.6em]{\\xleaders\\hbox{$\\cdot$\\hskip.11em}\\hfill\\kern0pt } } } } & \\\\ & & & & & \\hspace{-1,05 см}\\mathds{1}_{c_n}\\otimes \\sigma^n \\end{pmatrix},\\ ] ] где каждый блок @xmath133 является эрмитовой положительной полуопределенной матрицей той же размерности, что и соответствующий @xmath134. теперь рассмотрим спектральную разложение матриц @xmath135, т.е. @xmath136, где @xmath137 являются ортонормированными собственными векторами @xmath135 в пределах каждого соответствующего подпространства @xmath138 [ generic_def ] адаптированное состояние @xmath90 называется * общим *, если его собственные значения имеют минимально возможное вырождение, то есть @xmath139 для всех @xmath140 и для всех @xmath141, @xmath142. обратите внимание, что собственные значения не могут иметь того, что мы могли бы назвать минимальным вырождением, поскольку каждое @xmath143 имеет по конструкции кратность @xmath144 (напомним уравнение.([structure_rho ] ) ). при построении алгоритма потребуется дополнительная концепция попарной универсальности : [ generic_pair_def ] пара @xmath145 адаптированных состояний называется *взаимно универсальной *, если они оба являются универсальными, в смысле определения @xmath146, и нет собственный вектор @xmath147 блока @xmath148 из @xmath149 является собственным вектором соответствующего @xmath150 из @xmath151 всякий раз, когда @xmath152, где @xmath153 конечно, мы исключаем случай @xmath154, в котором собственное инвариантное подпространство имеет размерность один и, следовательно, собственные векторы должны совпадать. прежде чем мы дадим подробное описание предлагаемого нами алгоритма декомпозиции, давайте сначала дадим приблизительное представление о том, как организован алгоритм и, особенно, почему он работает. конечная цель алгоритма - найти матрицу Клебша Гордана @xmath47, которая, как показано в определении [ cg_matrix_def ], блочно диагонализирует все элементы представления @xmath124, @xmath22. другими словами, столбцы @xmath47 предоставляют ортонормированные базы для всех правильных инвариантных подпространств @xmath155 _, которые являются общими для всех @xmath124, @xmath22 _ (и, следовательно, общими для всех адаптированных состояний). теперь рассмотрим любое фиксированное адаптированное состояние @xmath90 и любую унитарную матрицу @xmath156, диагонализирующую @xmath90 поточечно, т.е. такую, что @xmath157 является диагональной. идея, лежащая в основе нашего алгоритма, заключается в том, что, поскольку столбцы как @xmath156, так и @xmath47 охватывают одни и те же собственные инвариантные подпространства, они должны быть каким-то образом связаны. эта связь, которая имеет решающее значение для нашего аргумента, будет четко изложена в теореме [ triple_v ] ниже и подразумевает, что после соответствующего изменения порядка столбцов @xmath156 любое другое адаптированное состояние (в более общем плане, любая матрица, которая является линейной комбинацией @xmath124) будет _ block - диагонализирован _ с помощью @xmath156 (смотрите следствие [ transformation_any_state ] ниже ). кроме того, полученные диагональные блоки имеют очень специфическую структуру, которая, будучи идентифицирована в следствии [ transformation_any_state ], будет ключом к извлечению матрицы Клебша Гордана @xmath47 из @xmath156 с помощью соответствующих преобразований подобия, описанных как в следствии [ r_tilde : следствие ], так и в лемме [ перестановка : лемма]. следующий результат является основой алгоритма, который мы описываем в [ the_algorithm : sec ] ниже : [ triple_v ] пусть @xmath90 - любое общее адаптированное состояние, и пусть @xmath156 - любая унитарная матрица, такая, что @xmath157 является диагональной. тогда @xmath158, где @xmath47 - матрица Клебша Гордана, определенная как в определении @xmath159, @xmath160 - любая матрица перестановок, и @xmath161, с @xmath162, заданным @xmath163 для любого набора @xmath164 унитарных матриц @xmath165, где @xmath166 - набор собственных векторов матриц @xmath135, @xmath167, приведенные в. * доказательство *: из этого следует, что @xmath168 для любого выбора @xmath169 ортонормированных базисов @xmath170, @xmath141. напомним, что @xmath169 - это размерность инвариантного подпространства @xmath35 или, что эквивалентно, количество строк и столбцов эрмитовых положительных полуопределенных матриц @xmath135. с другой стороны, @xmath30 - это кратность этого подпространства, т.е. глобальная кратность собственных значений @xmath171 в общей матрице @xmath90 (см. ). если мы теперь построим унитарные матрицы @xmath172 таким образом, чтобы их столбцы были ортонормированными векторами базиса @xmath173, то матрица @xmath174 будет диагонализировать матрицу @xmath175 с ее собственными значениями, отсортированными следующим образом: @xmath176{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & & \\mbox{\\огромный{0 } } & \\\\ & & & \\ hspace{-0,26 см } { \\rotatebox{-47}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & & \\\\ & \\ mbox{\\huge{0 } } & & & \\hspace{-0 см } { \\rotatebox{-47}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & \\\\ & & & & & \\ hspace{-0,6 см}\\lambda_{n_\\alpha}^\\alpha\\mathds{1}_{c_\\alpha } \\end{pmatrix}=\\lambda^\\alpha\\,.\\ ] ] следовательно, ввиду того, что матрица @xmath161 диагонализирует матрицу @xmath177, @xmath178 и любая перестановка @xmath160 столбцов матрицы @xmath179 все равно будет диагонализировать @xmath90, что показывает, что любая унитарная матрица @xmath156, диагонализирующая @xmath90 может быть записан как продукт @xmath180. @xmath181 [ transformation_any_state ] пусть @xmath90 - любое адаптированное состояние, пусть @xmath182 - связанная блочно - диагональная матрица с блоками, пусть @xmath183 с @xmath184, где каждый @xmath185, @xmath186 является матрицей перестановок @xmath187, и пусть @xmath180. затем для любой линейной комбинации @xmath188 проверяется, что @xmath189{\\makebox[1.6em]{\\xleaders\\hbox{$\\cdot$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\\\ & & & \\ высота{-1,99 см } { \\rotatebox{-43}{\\makebox[0pt]{\\makebox[1.6em]{\\xleaders\\hbox{$\\cdot$\\hskip.11em}\\hfill\\kern0pt } } } } & \\\\ & & & & \\ hspace{-2,4 см}c_nn_n\\слева\\{\\начать{array}{|ccc|}\\hline \\phantom{a } & \\phantom{a } & \\phantom{a}\\\\phantom{a } & \\phantom{a } & \\phantom{a } \\\\phantom{a} \\\\phantom{a } & \\phantom{a } & \\phantom{a}\\\\\\hline \\end{array}\\right. \\конец{массив } \\справа),\\начать{массив}{с } \\hspace{-6.5 см}\\vspace можно{4.08 см}\\Сигма^1 \\конец{массив } \\Фантом{а } \\начать{массив}{с } \\hspace{-5см}\\vspace можно{1,3 см}\\сигма^2 \\Конец{массив } \\Фантом{а } \\начать{массив}{с } \\hspace{-2.35 см}\\vspace можно{-3.8 см}\\Сигма^п \\конец{массив}\\ ] ], где @xmath190{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & г_{1n_\\Альфа}^\\Альфа \\\\ г_{21}^\\Альфа & \\hspace{-0.3 см } г_{22}^\\Альфа & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&r_{2n_\\alpha}^\\alpha\\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{-0.6 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } \\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{0,8 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt}}}}\\\\ \\vspace можно{0,1 см}\\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & & \\hspace{0.3 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.10им}\\hfill\\kern0pt}}}}\\\\ г_{п\\альфа 1}^\\Альфа & \\hspace{-0.3 см}г_{п - \\альфа-2}^\\Альфа & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & г_{п - \\п-альфа\\альфа}^\\альфа \\конец{pmatrix все},\\ ] ] с @xmath191 квадратных матриц размера @xmath30 определяется как @xmath192 где @xmath193, @xmath167, являются матрицы на блоке диагональ @xmath194 после @xmath47, т. е. матрицы, такие, что @xmath195.    * доказательство *: мы просто преобразуем @xmath194 с помощью @xmath156, @xmath196{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & & \\hspace{-0cm}\\mbox{\\huge{0 } } & \\\\ & & & \\hspace{-1,15 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & & \\\\ & \\hspace{-2,8 см}\\mbox{\\huge{0 } } & & & \\hspace{-0,4 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & \\\\ & & & & & \\ hspace{-1,85 см}\\big(x^np^n\\big)^\\dagger(\\mathds{1}_{c_n}\\otimes\\tau^n)x^np^n \\end{pmatrix}.\\ ] ] следовательно, матрицы @xmath197 в операторе равны @xmath198. наконец, если мы подставим в @xmath199 определение @xmath200 в уравнении и используем свойство @xmath201 произведения Кронекера для матриц @xmath202 таким образом, что произведения @xmath203 и @xmath204 выполнимы, мы получим @xmath205 @xmath181 это следствие является ключевым для алгоритма, описанного в разделе [ the_algorithm : sec ] ниже, потому что это означает, что любая матрица, диагонализирующая одно общее адаптированное состояние @xmath90, с соответствующим переупорядочением собственных векторов преобразует любую линейную комбинацию представления @xmath124 (в частности, любое другое адаптированное состояние) в конкретную форму, заданную следствием [ transformation_any_state ], которое имеет совершенно особый структура. наш следующий шаг сводится к использованию этой специальной структуры для того, чтобы выявить более тонкую блочную структуру внутри каждого @xmath197 для любой линейной комбинации представления. [ r_tilde : следствие ] пусть @xmath206 и @xmath207 будут такими, как в следствии [ transformation_any_state ]. пусть @xmath208 для любой матрицы @xmath209 и установите @xmath210 для любой фиксированной @xmath211. если @xmath212, являются диагональные блоки @xmath213 для некоторых других @xmath214, затем @xmath215{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\Тильду{х}_{{k_\\Альфа}1n_\\Альфа}^\\Альфа \\mathds{1}_{Когда\\Альфа } \\\\ \\Тильда{х}_{{k_\\Альфа}21}^\\Альфа \\mathds{1}_{Когда\\Альфа } & \\hspace{-0.3 см } \\Тильду{х}_{{k_\\Альфа}22}^\\Альфа \\mathds{1}_{когда\\Альфа } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\Тильду{х}_{{k_\\Альфа}2n_\\Альфа}^\\Альфа \\mathds{1}_{Когда\\Альфа}\\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{-1.2 см } { \\rotatebox{-25}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } \\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{0,8 см } { \\rotatebox{-25}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt}}}}\\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & & \\hspace{0.56 см } { \\rotatebox{-25}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}\\\\тильда{s}_{{k_\\alpha}n_\\alpha 1}^\\alpha \\mathds{1}_{c_\\alpha } & \\hspace{-0,3 см } \\tilde{s}_{{k_\\alpha}n_\\alpha 2}^\\alpha \\mathds{1}_{c_\\alpha } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt } } } } & \\тильда{s}_{{k_\\alpha}n_\\alpha n_\\alpha}^\\alpha \\mathds{1}_{c_\\alpha}. \\конец{pmatrix все}\\ ] ] * подтверждение * : если мы пишем @xmath216{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & t_ в{1n_\\Альфа}^\\Альфа \\\\ t_ в{21}^\\Альфа & \\hspace{-0.3 см } t_ в{22}^\\Альфа & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&t_{2n_\\alpha}^\\alpha\\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{-0.6 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } \\\\ \\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2em]{\\xleaders\\hbox{$\\cdot$\\hskip.12em}\\hfill\\kern0pt}}}}&\\hspace{0,8 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[1.2 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt}}}}\\\\ \\vspace можно{0,1 см}\\hspace{-0.2 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & \\hspace{-0.5 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.1эм}\\hfill\\kern0pt } } } } & & \\hspace{0.3 см } { \\rotatebox{-32}{\\makebox[0pt]{\\makebox[1.6 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.4 см } { \\rotatebox{90}{\\makebox[0pt]{\\makebox[0.85 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.10им}\\hfill\\kern0pt}}}}\\\\ t_ в{п\\альфа 1}^\\Альфа & \\hspace{-0.3 см}t_ в{п - \\альфа-2}^\\Альфа & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & { \\rotatebox{0}{\\makebox[0pt]{\\makebox[1.4 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.12em}\\hfill\\kern0pt } } } } & t_ в{п - \\п-альфа\\альфа}^\\альфа \\конец{pmatrix все},\\ ] ], где @xmath217, то можно легко проверить, что @xmath218 @xmath181 обратите внимание, что это преобразование приводит к матрице с почти структуре ( [ structure_rho ] ), с той разницей, что записи в блоках @xmath135 разбросаны повсюду, а не сосредоточена в диагональных блоков. другими словами, если мы установим @xmath219 для @xmath220 таким образом, что @xmath221 для всех @xmath222, тогда @xmath223, в то время как мы хотели бы иметь продукты Кронекера в обратном порядке. хорошо известно, что для любой пары матриц @xmath54 и @xmath55 произвольных размеров два произведения Кронекера @xmath224 и @xmath225 являются перестановочно эквивалентными (т.е. @xmath226 для соответствующих матриц перестановок @xmath160 и @xmath227 ). более того, когда оба @xmath54 и @xmath55 квадратные, они на самом деле они перестановочно схожи (т.е. можно взять @xmath228 выше: смотрите, например, следствие 4.3.10 в @xcite или @xcite xcite ). [ перестановки : Лемма ] даны две матрицы @xmath54 и @xmath55 произвольных размеров, существуют два перестановочных матриц @xmath160 и @xmath227, которые зависят только от размерности матриц @xmath54 и @xmath55, таких, что @xmath229 в случае, @xmath54 и @xmath55 квадратные матрицы размеров @xmath15 и @xmath73 соответственно, перестановка матрицы связаны с @xmath230, где @xmath231 и @xmath232 следующие матриц размерности @xmath233 и @xmath234 соответственно : @xmath235{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & & \\\\ & & \\hspace{-0.05 см } { \\rotatebox{-45}{\\makebox[0pt]{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.1 см } { \\rotatebox{-45}{\\makebox[0pt]{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{0.2 см}\\mbox с{\\огромным{$0 $ } } & \\\\ & & & \\hspace{0.02 см } { \\rotatebox{-45}{\\makebox[0pt]{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.6 см } { \\rotatebox{-45}{\\makebox[0pt]{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\\\ & \\mbox с{\\огромным{$0 $ } } & & & \\hspace{0.05 см } { \\rotatebox{-45}{\\makebox[0pt]{\\makebox[1.5 ЭМ]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.11em}\\hfill\\kern0pt } } } } & \\hspace{-0.2 см}1 \\\\ & & & & & \\hspace{-0.2 см}0 \\конец{pmatrix все},\\четырехъядерных\\qquad Ф=\\влево(\\начать{массив}{с|C } 1&\\начать{массив}{с } \\vspace можно{-0.3 см}\\\\ \\большой{\\текст{$0$}}_{1\\раз(N-1)}\\\\ \\vspace можно{-0,4 см } \\конец{массив}\\\\\\hline на \\Начать{массив}{с } \\vspace можно{0,2 см}\\\\ \\большой{\\текст{$0$}}_{(СП-1)\\раз 1 } \\конец{массив}&\\hspace{-0.19 см}\\начать{массив}{с } \\vspace можно{-0.3 см}\\\\ \\mathds{1}_{(п-1)}\\otimes\\влево(\\начать{массив}{с } 0\\\\ \\vdots\\\\ 0\\\\ 1 \\конец{массив}\\справа)_{С\\раз 1 } \\vspace можно{0,1 см}\\\\\\hline на \\конец{массив}\\\\ & \\начать{массив}{с } \\vspace можно{-0.3 см}\\\\ \\огромной{\\текст{$0$}}_{(к-1)\\раз ( N-1 ) } \\конец{массив } \\конец{массив}\\право).\\ ] ] как следствие леммы [ перестановка : лемма ], если мы вычислим матрицу @xmath236 таким образом, что @xmath237, если @xmath156 является унитарной матрицей в следствии [ transformation_any_state ], а @xmath238 задается через ( [ def_r_tilde ] ), мы заключаем, что @xmath239 является матрицей клебша Гордана в определение [ cg_matrix_def ]. теперь мы в состоянии дать подробное описание, шаг за шагом, алгоритма декомпозиции, который мы назвали smily. сначала мы указываем входные данные и выходные данные алгоритма: * * input * : унитарное представление любой конечной группы или компактной группы ли @xmath19. * * вывод *: матрица Клебша Гордана @xmath240, в базисе собственных векторов исходного адаптированного состояния @xmath149. мы можем разбить алгоритм smily на восемь шагов: 1. * сгенерировать два адаптированных состояния *: мы начинаем с создания двух взаимно общих состояний @xmath149 и @xmath151 (см. определение [ generic_pair_def ] ). Чтобы создать их, мы генерируем два случайных вектора @xmath241 и @xmath242 размером @xmath243, с без нулевых компонентов и используем их соответствующие элементы в качестве коэффициентов для построения двух линейных комбинаций матриц @xmath131 : @xmath244 далее мы симметрируем, @xmath245 сдвигаем их на спектральный радиус и делим на трассировку, @xmath246, чтобы получить две эрмитовы нормализованные положительные полуопределенные матрицы @xmath149 и @xmath151. поскольку они были сгенерированы случайным образом, можно с уверенностью предположить, что они являются взаимно общими. * точечно диагонализируйте первое состояние *: вычислите унитарную матрицу @xmath247, которая точечно диагонализирует состояние @xmath149, т.е. такую, что @xmath248 является диагональной матрицей. такая матрица существует, поскольку @xmath149 является эрмитовой. + [ step_3_ps ] 3. * первая сортировка *: измените порядок столбцов @xmath247, сгруппировав вместе собственные векторы, соответствующие одному и тому же правильному подпространству @xmath20. напомним, что, согласно следствию [ transformation_any_state ], происходит изменение порядка столбцов @xmath247, которое блокирует диагонализацию @xmath151, а размеры диагональных блоков являются размерами @xmath20. обратите внимание, что если два столбца @xmath249 и @xmath250 из @xmath247 соответствуют одному и тому же правильному подпространству @xmath20, то @xmath251. это будет наш тест для перестановки столбцов в @xmath247. точнее, мы используем следующую процедуру, основанную на подходе \"разделяй и властвуй\": 1. выберите один столбец из @xmath247, переименуйте его в @xmath252 и переместите в список векторов, который мы назовем @xmath253. + + [ шаг_3_2 ] 2. вычислите @xmath254 для другого столбца @xmath250 из @xmath247, и если @xmath255, переместите @xmath250 в список @xmath253 и переименуйте его в @xmath256. повторите со всеми оставшимися столбцами @xmath247, переместите эти @xmath250 с @xmath257 в список @xmath253 и пометьте их как @xmath258, с индексом @xmath259, отражающим порядок, в котором они были включены в список. +. ] 3. вычислите @xmath260 для @xmath261, для тех, которые были включены в список. столбцы @xmath250 из @xmath247 еще не перемещены в @xmath253 на шаге. это повторная проверка, поскольку на шаге может остаться какой-то вектор, не включенный в список, потому что он оказался ортогональным @xmath252 в скалярном произведении, определенном @xmath151. условие взаимной универсальности гарантирует, что ни один вектор в @xmath253 не может быть ортогонален всем оставшимся векторам в списке. +. ] как только мы закончим проверку всех собственных векторов в @xmath253, мы возьмем блок, столбцы которого являются собственными векторами в @xmath253, и обозначим его как @xmath262, поскольку это набор из векторов @xmath263, составляющих ортонормированный базис @xmath264. после этого мы возвращаемся к шагу и повторяем процесс с остальными векторами, пока все они не будут отсортированы. + в конце этого шага мы получаем матрицу, которую мы можем назвать @xmath265, столбцы которой образуют основания @xmath266 соответствующих подпространств @xmath20 для @xmath167, т.е. @xmath267 этот шаг также дает измерения @xmath268 путем подсчета количества векторов в каждом подпространстве. * вторая сортировка *: измените порядок столбцов внутри каждого @xmath269, сгруппировав вместе собственные векторы, соответствующие одному и тому же собственному значению @xmath149. чтобы сделать это, мы просто меняем порядок собственных векторов в каждом @xmath266 в порядке убывания, соответствующем их собственным значениям. таким образом, мы получаем @xmath270, где @xmath271 + подсчет кратности одного собственного значения в каждом @xmath32 даст кратность @xmath30. следовательно, поскольку мы уже получили продукты @xmath268 на шаге, мы также можем получить размеры неотделимых элементов @xmath169, разделив эти числа на @xmath30. на этом этапе также возможно, при необходимости, получить символы неотрицательных элементов в разложении @xmath124 путем вычисления @xmath272 5. * грубая блочная диагонализация @xmath273 *: вычислите матрицу @xmath274, чтобы получить грубую блочную диагонализацию @xmath151 в терминах матрицы @xmath275, как показано в следствии [ transformation_any_state ], и идентифицируем квадратные матрицы @xmath276 размера @xmath30. вычислите матрицу @xmath238 *: согласно следствию [ r_tilde : следствие ], для каждого @xmath275 выберите столбец матриц @xmath277 таким образом, что @xmath278 для всех @xmath141, вычислите унитарные матрицы @xmath279 и, наконец, вычислите унитарную матрицу @xmath280 7. * вычислите матрицу перестановок @xmath227 * : для каждого @xmath32 вычислите матрицу перестановок @xmath281, как описано в лемме [ перестановка : лемма ], и соберите их в блочную диагональную матрицу @xmath282 8. * окончательная перестановка *: вычислите матрицу Клебша Гордана @xmath283. представленный нами алгоритм разлагает любое конечномерное унитарное представление любой компактной группы Ли. в случае конечных групп естественно применить его к регулярному представлению, поскольку оно содержит каждое неприводимое представление с кратностью, равной размерности его неприводимых элементов, @xmath284 ( * ? ? ? * гл.2), таким образом: @xmath285 регулярное представление группы @xmath1 - это унитарное представление, полученное в результате действия группы @xmath1 на гильбертовом пространстве квадратных интегрируемых функций на группе, @xmath286, где @xmath287 обозначает левую (правую) инвариантную меру Хаара посредством левый ( правый) перевод.    как и прежде, мы ограничим обсуждение конечными группами @xmath1, как в разделе. [ раздел: предварительные замечания ]. пространство квадратных интегрируемых функций на @ xmath1 может быть канонически идентифицировано с @xmath288-мерным комплексным пространством, формально порожденным элементами группы, т.е. мы будем обозначать через @xmath289 $ ] линейное пространство, элементы которого задаются через @xmath290, @xmath291, @xmath69, с естественным законом сложения @xmath292. обратите внимание, что @xmath289 $ ] также содержит естественную ассоциативную алгебраическую структуру @xmath293, хотя мы не будем использовать такую структуру здесь. левое регулярное представление определяется как @xmath294 таким образом, матричные элементы регулярного представления получаются путем вычисления действия группы на ортонормированном базисе @xmath295, @xmath296 гильбертова пространства @xmath297 $ ] : @xmath298 тогда матричное представление левого регулярного представления гильбертова пространства @xmath297 $] : @xmath298 элемент @xmath299 можно легко вычислить из таблицы группы, приведенной ниже (обратите внимание на обратное расположение элементов вдоль строк). матрица @xmath300 получается путем построения матрицы с единицами в позициях, где @xmath299 появляется в таблице, и нулями в таблице rest..group. [ cols=\"^,^,^,^,^,^,^\", options=\"header\", ] в случае обычного представления входными данными нашей программы может быть матрица @xmath301, построенная из таблицы * t * (см. таблицу[group_table ] ) повторно помечены путем идентификации @xmath302 с @xmath303 и @xmath295 с @xmath304, и чьи записи определены как @xmath305 как только у нас будет таблица группового умножения в этой форме, нам не нужно явно вычислять регулярное представление для каждого элемента @xmath306, чтобы создать адаптированные состояния @xmath149 и @xmath151 на шаге, поскольку мы можем просто вычислить случайные векторы @xmath307 для элементов таблицы, то есть @xmath308_{ij}=\\varphi_a \\big(t_{ij}\\big)\\,, \\qquad a = 1,2\\,.\\] ] в финале мы покажем результаты, полученные с использованием нашего алгоритма декомпозиции регулярного представления в двух простых случаях: группа перестановок @xmath309 и переменная группа @xmath310.    чтобы проверить точность результатов, мы сравним символы, поскольку они не зависят от выбора основы. мы вычислим символы irreps, полученные после применения унитарного преобразования @xmath240, предоставленного нашим алгоритмом, и сравним их с точными символами, определив ошибку как @xmath311, где @xmath23 - семейство классов эквивалентности irreps из @xmath19. пусть @xmath1 - компактная группа Ли, а @xmath19 - замкнутая подгруппа (следовательно, тоже компактная). состояния, адаптированные к @xmath19, будут иметь вид @xmath312, где @xmath313 - коэффициент нормализации @xmath314, а @xmath315 обозначает инвариантную меру Хаара в @xmath19.    поскольку наш алгоритм является числовым, нам нужно аппроксимировать интеграл конечной суммой. выбор квадратурного правила для аппроксимации интеграла для данного @xmath90 эквивалентен использованию другого @xmath316, такого, что @xmath317 только для конечного числа элементов группы. тогда интеграл для @xmath316 сводится к конечной сумме, и аппроксимация @xmath316 является точной. могло случиться так, что полученные таким образом общие адаптированные состояния не имели достаточных степеней свободы, т.е. могло случиться так, что блочные диагональные матрицы представления не были неприводимыми. однако мы увидим, что это не проблема, потому что в случае групп ли матрица Клебша Гордана, разлагающая все элементы своей алгебры ли @xmath318, будет матрицей клебша Гордана, разлагающей все элементы представления. алгебра ли @ xmath318 - это алгебра, замкнутая в скобках ли @xmath319:\\mathfrak {g}\\times\\mathfrak {g}\\rightarrow\\mathfrak {g}$ ]. любой элемент алгебры ли может быть записан в терминах линейно независимых элементов, называемых _ generators _, @xmath320, @xmath321, которые удовлетворяют @xmath322=c_{ij}^k\\xi_k\\,,\\qquad i, j, k=1,\\ldots, n_\\mathfrak{g}\\,,\\ ] ] где коэффициенты @xmath323 называются _ структурными константами _ алгебра ли @xmath318 и @xmath324 - это ее размерность. обратите внимание, что генераторы любого представления одной и той же алгебры ли будут иметь одинаковые структурные константы, за исключением коэффициента умножения.    для групп ли унитарное представление может быть получено с помощью экспоненциального отображения любого элемента его алгебры ли @xmath318, @xmath325 : @xmath326 сразу видно, что матрица Клебша Гордана @xmath47, которая разлагает все элементы алгебры ли @xmath327, разложит все элементы представления и наоборот : @xmath328, где @xmath329, @xmath167 - это набор образующих неприводимых представлений алгебры ли @ xmath318 и @xmath330, их соответствующих представлений через экспоненциальное отображение. в случае компактных групп ли, поскольку множество образующих его алгебры ли конечно, @xmath331, матрица @xmath47, которая разлагается на неотрицательные @ xmath332 нетривиальных линейно независимых элемента алгебры ли, или @xmath332 линейно независимых элемента представления @xmath84, @xmath333, будет матрица Клебша Гордана. исходная задача Клебша Гордана состоит в уменьшении представления тензорного произведения @xmath334, @xmath335 двух представлений одной и той же группы @xmath1, ограниченного диагональной подгруппой группы продуктов. по ассоциативности эта задача может быть обобщена на любое число тензорных произведений @xmath336. здесь связанная с ним алгебра ли задается @xmath337, где @xmath322=c_{ij} ^k\\xi_k,\\qquad[\\xi_i ^\\alpha,\\xi_i ^\\alpha]=c_{ij}^k\\xi_i ^\\alpha,\\qquad\\alpha=1,\\ldots, n.\\ ] ] давайте теперь изучим группу @xmath0: генераторы представления связанной с ней алгебры ли задаются эрмитовыми бесследными операторами углового момента @xmath338, удовлетворяющими коммутационным соотношениям @xmath339=i\\epsilon_{ij}^kj_k\\,, \\qquad i, j, k = x, y, z\\,,\\qquad n_\\mathfrak{g}=3\\,.\\ ] ] связанное с ним представление @xmath0 может быть записано как @xmath340 матричное представление импульса @xmath259 операторов углового момента @xmath341 обычно записывается на основе собственные векторы @xmath342, @xmath343 и представление операторов @xmath344 и @xmath345 обычно получаются из представления лестничных операторов @xmath346, @xmath347, например, если @xmath348 : @xmath349 @xmath350 в стандартном базисе @xmath351 стандартная матрица Клебша Гордана построена с собственными векторами @xmath351. оператор общего углового момента @xmath352 по отношению к компоненту @xmath353, @xmath354, где @xmath15 - количество частей системы. собственные векторы этого оператора обычно обозначаются @xmath355, где @xmath356 представляют общий угловой момент, а @xmath357 : @xmath358 стандартная процедура получения этой матрицы Клебша Гордана состоит в последовательном применении лестничного оператора @xmath359, начиная с состояния максимального импульса @xmath360. обратите внимание, что поскольку действие матричных элементов лестничных операторов реально, коэффициенты Клебша Гордана тоже реальны. напомним, что матрица Клебша Гордана, предоставляемая нашим алгоритмом, записана в терминах собственных векторов первого адаптированного состояния @xmath149. таким образом, если мы хотим сравнить коэффициенты Клебша Гордана, полученные с помощью нашего алгоритма, со стандартными, мы должны найти матрицу клебша Гордана @xmath361, которая соответствует собственным векторам оператора @xmath362. чтобы сделать это, мы сначала создаем два реальных адаптированных состояния, используя тот факт, что операторы @xmath363, @xmath364 проверяют @xmath365, где @xmath366 обозначает комплексное сопряжение, следовательно, для любого адаптированного состояния @xmath90 его комплексное сопряжение @xmath367 также является адаптированным состоянием. следовательно, чтобы создать реальные адаптированные состояния, мы сначала добавляем каждую матрицу @xmath368, @xmath369 на шаге в разделе [the_algorithm : sec ] к ее комплексному сопряжению, чтобы получить реальные симметричные матрицы, а затем умножаем результат на его транспонирование в mсделайте это положительно определенным. наконец, мы нормализуем их деления на их след, т. е. @xmath370 как только у нас есть два реальных адаптирован государств - @xmath371 и @xmath372, мы применяем наш алгоритм, чтобы получить настоящие клебша Гордана матрицы @xmath240. после этого мы преобразуем оператор @xmath362 с @xmath240 разложить его на неприводимые представления, @xmath373 и мы diagonalize каждый блок данной матрицы, превращая его с блочно - диагональной матрицы @xmath374 который упорядочивает собственные значения следующим образом : @xmath375{\\makebox[1эм]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & & & & & & & \\\\ & & & \\hspace{-0.3 см}-j_1 & & & & & & \\\\ & & & & j_2 & & & & & \\\\ & & & & & \\hspace{-0.2 см}j_2 - 1 & & & & \\\\ & & & & & & \\hspace{-1.1 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1эм]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & & & \\\\ & & & & & & & \\hspace{-0.6 см}-j_2 & & \\\\ & & & & & & & & \\hspace{-0.4 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1эм]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } & \\\\ & & & & & & & & & \\hspace{-2.9 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1эм]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } \\\\ & & & & & & & & & \\hspace{-1.4 см}j_n \\\\ & & & & & & & & & \\hspace{0.2 см}j_n-1 \\\\ & & & & & & & & & \\hspace{0.8 см } { \\rotatebox{-40}{\\makebox[0pt]{\\makebox[1эм]{\\xleaders\\Хbox{$\\cDOT на$\\hskip.09em}\\hfill\\kern0pt } } } } \\\\ & & & & & & & & & \\hspace{2,2 см}-j_n \\\\ \\конец{pmatrix все}\\,.\\ ] ] поэтому клебша Гордана матрица, у которой столбцы являются собственными векторами @xmath362, упорядочены таким образом, дается @xmath376 в, мы покажем вычисления клебша Гордана коэффициенты для двустороннего вращение системы @xmath377 и Трехсторонней спиновой системы @xmath378. опять же, мы проверим точность, сравнив точные символы с теми, которые были вычислены после преобразования с помощью матрицы Клебша Гордана, полученной с помощью smily. для любого неприводимого представления группы @xmath0 можно показать, что символы имеют следующее выражение : @xmath379, где @xmath380 - размерность неприводимого. поэтому мы измеряем точность с помощью @xmath381 с помощью @xmath382 количество элементов в квадратурном приближении. представлен численный алгоритм вычисления декомпозиции конечномерного унитарного представления компактной группы ли. такой алгоритм использует понятие универсальных адаптированных квантовых смешанных состояний для получения блочной структуры и, в конечном счете, коэффициентов матрицы Клебша Гордана, решающей задачу декомпозиции. численный алгоритм стабилен и точен, поскольку он не сочетает в себе ничего, кроме стабильных процедур, включающих диагонализацию эрмитовых матриц, сортировку и рекомбинацию матричных блоков и матричных произведений. представленные численные примеры подтверждают это. алгоритм был успешно использован для разложения регулярного представления конечных групп и прямого произведения двух и трех представлений @xmath0. в первом случае основной вычислительной задачей была подготовка групповой таблицы, предварительная задача перед использованием алгоритма. во втором случае эта предварительная часть была намного проще, поскольку явные выражения представлений алгебры Ли @xmath383 для любого значения спина хорошо известны. алгоритм может быть легко расширен до конечномерных представлений некомпактных групп. однако, поскольку представления перестанут быть унитарными, численная стабильность алгоритма может быть поставлена под угрозу. более подробная информация по этим вопросам будет рассмотрена в другом месте. [ appendix_ps]приложение в этом приложении мы представляем результаты, полученные для декомпозиции групп @xmath309 и @xmath310, а также коэффициенты клебша Гордана спиновых систем @xmath377 и @xmath384. все эксперименты проводились с использованием matlab r2012a (версия 7.14.0.739). a.1.1.*декомпозиция левого регулярного представления группы перестановок @xmath309. * группа @xmath309 - это группа перестановок из трех элементов, и она имеет шестой порядок. элементы этой группы могут быть сгенерированы с помощью набора перестановок @xmath385, @xmath386 : @xmath387 наш алгоритм разлагает обычное представление на два представления @xmath388 и @xmath389 первого измерения и кратности один, и еще одно @xmath390 второго измерения и кратности два, точно так, как ожидалось. представление @xmath388 соответствует тривиальному, @xmath391, @xmath392, а остальные представления, полученные после применения преобразования @xmath240, приведенного smily, следующие: @xmath393 если мы используем формулу для вычисления точности символов неотрицательных, мы получаем @xmath394 a.1.2.*разложение левого регулярного представления чередующейся группы @xmath310. * переменная группа @xmath310 - это группа четных перестановок четырех элементов. эта группа состоит из двенадцати элементов, и она может быть сгенерирована с помощью трех генераторов, удовлетворяющих соотношениям @xmath395 левое регулярное представление этой группы имеет четыре неприводимых представления: три первого измерения и одно третьего измерения. следовательно, smily разложит регулярное представление этой группы на три представления измерения один с кратностью один и на представление измерения три с кратностью три. опять же, @xmath388 является тривиальным представлением @xmath391, @xmath396, а остальные даны по : @xmath397 @xmath398 в этом случае точность символов неотрицательных чисел, вычисленных с помощью, определяется по @xmath399 a.2.1.* коэффициенты Клебша Гордана для системы вращения @xmath377. * предположим, у нас есть система из двух частиц, в которой первая частица имеет импульс @xmath400, а вторая - импульс @xmath303. это хорошо известно ( * ? ? ? * гл.5 ), что эта система разлагается на прямую сумму систем импульса @xmath401, @xmath400 и @xmath402, каждая с кратностью один, @xmath403 или, другими словами, что представление @xmath0, соответствующее тензорному произведению @xmath377, имеет неприводимые представления импульса @xmath401, @xmath400 и @xmath402 с кратностью друг другу.    чтобы создать адаптированные состояния для шага алгоритма, мы выбрали три случайных вектора @xmath404, @xmath405, @xmath406 для каждого адаптированного состояния, чтобы получить три линейно независимых элемента представления. очевидно, что мы также создали два случайных вектора @xmath307 длины @xmath407 для построения матриц @xmath368, @xmath369 на шаге : @xmath408, где @xmath409 - экспоненциальное представление, заданное, а @xmath410 обозначает импульс представления @xmath32.    чтобы представить коэффициенты Клебша Гордана, мы будем использовать следующую стандартную схему: коэффициенты, полученные для системы @xmath377 с применением алгоритма smily, следующие: для оценки точности мы аппроксимировали интеграл в с помощью @ xmath411. результат, который мы получили, равен @xmath412 a.2.2.*коэффициенты клебша Гордана для спиновой системы @xmath384. * чтобы проверить возможности нашего алгоритма, мы вычислим коэффициенты Клебша Гордана для системы из трех спиновых частиц. эти коэффициенты могут быть получены из подходящего выбора коэффициентов произведений двух вращений, по этой причине не существует таблиц для систем с более чем двумя вращениями. стандартная процедура состоит в том, чтобы сначала уменьшить представление первых двух частиц, затем уменьшить результат с помощью следующей частицы и так далее, пока не останется ни одной частицы. в нашем случае произведение трех частиц со спином @xmath402, @xmath402 и @xmath400 дает @xmath413, то есть два повторения импульса @xmath402 и @xmath401 с кратностью один, а другое - импульса @xmath400 с кратностью два.    на первом шаге мы блокируем по диагонали первые два вращения: @xmath414, а затем мы диагонализируем результат: @xmath415 следовательно, матрица Клебша Гордана этой системы равна @xmath416 в этом примере мы видим, что для многосторонней системы вращений кратности представлений могут быть больше единицы. таким образом, может существовать несколько собственных векторов с одинаковыми значениями @xmath356 и @xmath417. следовательно, необходимо добавить еще одно \"квантовое число\", которое мы будем обозначать @xmath73, чтобы отличить их друг от друга. это \"квантовое число\" будет меткой, указывающей, к какой копии представления кратности больше единицы принадлежит каждый из собственных векторов с одинаковыми @xmath356 и @xmath417. отсюда и выбор @xmath73 для его обозначения, поскольку именно эту букву мы использовали для обозначения множественности в приведенном выше примере.    используя наш алгоритм, нам не нужно группировать систему по группам двудольных систем, как раньше, это можно сделать за один шаг. опять же, в этом случае мы выбрали три случайных вектора @xmath418, @xmath406, чтобы получить три линейно независимых элемента представления группы, и еще один случайный вектор @xmath419 длины @xmath407 для вычисления каждой линейной комбинации @xmath194. коэффициенты будут представлены в порядке, аналогичном случаю с двумя вращениями, но теперь включающем метку @xmath73 : обратите внимание, что приведенная ниже таблица не уникальна, поскольку существует более одной линейной комбинации, обеспечивающей действительную матрицу Клебша Гордана, которая диагонализирует @xmath420 с собственными значениями, переупорядоченными способом, указанным в. коэффициенты, полученные для трехсторонней системы @xmath384, следующие: [ tabla_5 ] снова, чтобы оценить точность, мы аппроксимировали интеграл с помощью @xmath411, и полученный результат был @xmath421 

представлен численный алгоритм, который вычисляет разложение конечномерного унитарного приводимого представления компактной группы ли. алгоритм, вдохновленный понятиями квантовой механики, генерирует два адаптированных состояния и после соответствующих алгебраических манипуляций возвращает блочно-матричную структуру представления в терминах его неотрицательнойподатливые компоненты. он также обеспечивает адаптированный ортонормированный базис. алгоритм может быть использован для вычисления коэффициентов Клебша Гордана тензорного произведения неприводимых представлений данной компактной группы ли. производительность алгоритма проверяется на различных примерах: декомпозиции регулярного представления конечных групп и вычислении коэффициентов Клебша Гордана тензорных произведений представлений @xmath0.