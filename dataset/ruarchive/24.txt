инварианты - популярная концепция в распознавании объектов и поиске изображений @xcite. они направлены на предоставление описаний, которые остаются неизменными при определенных геометрических или радиометрических преобразованиях сцены, тем самым сокращая пространство поиска. они могут быть классифицированы на глобальные инварианты, обычно основанные либо на наборе ключевых точек, либо на моментах, и локальные инварианты, обычно основанные на производных функции изображения, которая предполагается непрерывной и дифференцируемой. представляющие интерес геометрические преобразования часто включают перемещение, поворот и масштабирование, которые вкратце называются преобразованиями подобия. в предыдущей статье @xcite, основываясь на работе, проделанной Шмидом и Мором @xcite, мы предложили дифференциальные инварианты для этих преобразований подобия, а также _ линейное _ изменение яркости. здесь мы рассматриваем нелинейное изменение яркости, известное как гамма-коррекция.    гамма-коррекция - это нелинейное квантование измерений яркости, выполняемых многими камерами в процессе формирования изображения. идея состоит в том, чтобы достичь лучших результатов восприятия, поддерживая приблизительно постоянное соотношение между соседними уровнями яркости, разделяя уровни квантования на \"едва заметную разницу\". кстати, это нелинейное квантование также предварительно компенсирует нелинейное отображение от напряжения к яркости в электронных устройствах отображения @xcite. гамма-коррекция может быть выражена уравнением @xmath0, где @xmath1 - входная интенсивность, @xmath2 - выходная интенсивность, а @xmath3 - коэффициент нормализации, который определяется значением @xmath4. для устройств вывода стандарт ntsc определяет @xmath5. для устройств ввода, таких как камеры, значение параметра просто инвертируется, что приводит к типичному значению @xmath6. камера, которую мы использовали, цветная камера sony 3 ccd dxc 950, демонстрировалась на @xmath7. для камеры kodak megaplus xrc ] [ рис. : gammacorr ] показано отображение интенсивности 8-битных данных для различных значений @xmath4. оказывается, инвариант при гамма-коррекции может быть рассчитан из производных первого и второго порядка. дополнительная инвариантность при масштабировании требует производных третьего порядка. производные по своей природе трансляционно инвариантны. вращательная инвариантность в 2-d достигается использованием вращательно-симметричных операторов. ключевая идея для разработки предлагаемых инвариантов состоит в том, чтобы сформировать подходящие соотношения производных функции изображения таким образом, чтобы параметры, описывающие интересующее преобразование, были сведены на нет. эта идея была использована в @xcite для достижения инвариантности при линейных изменениях яркости, и ее можно адаптировать к контексту гамма-коррекции, по крайней мере, концептуально рассмотрев логарифм функции изображения. для простоты мы начнем с функций одномерного изображения. пусть @xmath8 - функция изображения, т.е. исходный сигнал, предполагаемый непрерывным и дифференцируемым, а @xmath9 - соответствующая функция с гамма-коррекцией. обратите внимание, что @xmath8 является частным случаем @xmath10, где @xmath11. логарифмирование дает @xmath12 с производными @xmath13 и @xmath14. теперь мы можем определить инвариант @xmath15 при гамма-коррекции как @xmath16{0 мм}{13 мм } & = $ \\frac{\\gamma\\, \\frac{f'(x)}{f(x ) } } { \\gamma\\, \\frac{f(x))\\,f\"(x) - f'(x)^2}{f(x)^2}}$ \\\\ & = $ \\ разрыв{f(x)\\,f'(x)}{f(x)\\,f\"(x) - f'(x)^2}$ \\end{табличный}\\ ] ] коэффициент @xmath3 был устранен путем взятия производных, а @xmath4 был отменен. кроме того, @xmath15 оказывается полностью заданным в терминах функции _ original _ image и ее производных, т.е. логарифм фактически не нужно вычислять. обозначение @xmath17 указывает, что инвариант зависит от базовой функции изображения @xmath8 и местоположения @xmath18. инвариантность сохраняется при гамма-коррекции, а не при пространственных изменениях функции изображения. недостатком @xmath15 является то, что он не определен там, где знаменатель равен нулю. поэтому мы модифицируем @xmath15, чтобы он был непрерывным везде: @xmath19{0 мм}{8 мм } { \\normalsize $ \\theta_{m12\\gamma}=$ } & $ \\frac{f\\,f'}{f\\,f \" - { f'}^2}$ & { \\normalsize if $ |f\\,f'| \u003c |f\\,f \" - { f'}^2|$ } \\\\ & $ \\ frac{f\\,f \" - { f'}^2}{f\\,f'}$ & { \\normalsize else } \\\\ \\end{табличный}\\ ] ] где для удобства записи мы удалили переменную @xmath18. модификация влечет за собой. обратите внимание, что модификация - это просто эвристика для работы с полюсами. если все производные равны нулю, потому что функция изображения постоянна, то дифференциалы, безусловно, не лучший способ представления функции. если масштабирование - это преобразование, которое необходимо учитывать, то необходимо ввести другой параметр @xmath20, описывающий изменение размера. то есть масштабирование моделируется здесь как подстановка переменной @xcite: масштабированная версия @xmath8 - это @xmath21. итак, мы рассматриваем функцию @xmath22, где производными по отношению к @xmath18 являются @xmath23, @xmath24 и @xmath25. теперь инвариант @xmath26 получается путем определения подходящего соотношения производных таким образом, чтобы и @xmath4, и @xmath20 сводили на нет: @xmath27{0 мм}{10 мм } & = $ \\frac{g ^ 2 g'\\,g ' \" - 3\\,g\\,{g'}^2 g \" + 2\\,{g'}^4 } { g^2 { g\"}^2 - 2\\,g\\,{g'}^2 g \" + \\ { g'}^4}$ \\конец{табличный}\\ ] ] аналогично эквалайзеру. ( [ уравнение : thm12 g ] ), мы можем определить модифицированный инвариант @xmath28{0 мм}{8 мм } { \\normalsize $ \\theta_{m123\\gamma}=$ } & $ \\frac{g^ 2 g'\\,g ' \" - 3\\,g\\,{g'}^2 g \" + 2\\,{g'}^4 } { g^2 { g\"}^2 - 2\\,g\\,{g'}^2 g \" + \\ { g'}^4}$ & { \\normalsize, если cond2 } \\\\ & $ \\frac{g^2 { g\"}^2 - 2\\,g\\,{g'}^2 g \" + \\ { g'}^4 } { g^2 g'\\,g ' \" - 3\\,g\\,{g'}^2 g \" + 2\\,{g'}^4}$ & { \\normalsize else } \\\\ \\end{табличный}\\ ] ] где условие cond1 равно @xmath29 @xmath30, а условие cond2 равно @xmath31 @xmath32 @xmath33. опять же, эта модификация влечет за собой. это простое, хотя и громоздкое упражнение для проверки инвариантов из уравнений. ( [ eq : th12g ] ) и ( [ eq : th123g ] ) с аналитической, дифференцируемой функцией. в качестве произвольного примера мы выбираем @xmath34, первыми тремя производными являются @xmath35, @xmath36 и @xmath37. затем, согласно уравнению. ( [ эквалайзер : th12 g ] ), @xmath38. если мы теперь заменим @xmath8 версией с гамма-коррекцией, скажем, @xmath39, первая производная станет @xmath40, вторая производная - @xmath41, а третья - @xmath42. если мы вставим эти производные в уравнение. ( [ уравнение : th12g ] ), мы получим выражение для @xmath43, которое идентично приведенному выше выражению для @xmath17. читателю, склонному к алгебре, рекомендуется проверить инвариант @xmath44 для той же функции. [ рис. : analyex ] показывает пример функции и ее аналог с гамма-коррекцией, вместе с их производными и двумя модифицированными инвариантами. как и ожидалось, графики инвариантов справа такие же, как и слева. обратите внимание, что инварианты определяют отображение \"многие к одному\". то есть отображение не сохраняет информацию, и невозможно восстановить исходное изображение из его инвариантного представления. если @xmath45 или @xmath46 должны быть вычислены на изображениях, то уравнения.  ( [ eq : th12 g ] ) - ( [ eq : thm123 g ] ) должны быть обобщены на два измерения. это должно быть сделано вращательно-инвариантным способом, чтобы достичь инвариантности при преобразованиях подобия. стандартный способ - использовать вращательно-симметричные операторы. для первой производной у нас есть хорошо известная величина градиента, определенная как @xmath47, где @xmath48 - функция двумерного изображения, а @xmath49, @xmath50 - частные производные вдоль оси x и оси y. для производной второго порядка мы можем использовать линейный _ laplacian _ @ xmath51 horn @ xcite также представляет альтернативный оператор производной второго порядка, _ квадратичную вариацию _ @ xmath52 поскольку qv не является линейным оператором и более дорогостоящим для вычисления, мы используем лапласиан для нашей реализации. для производной третьего порядка мы можем определить, в тесной аналогии с квадратичной вариацией, _ кубическую вариацию _ как @xmath53 инварианты из уравнений. ( [ eq : th12 g ] ) - ( [ eq : thm123 g ] ) остаются действительными в 2-d, если мы заменим @xmath54 на @xmath55, @xmath56 на @xmath57 и @xmath58 на @xmath59. это можно проверить, используя тот же аргумент, что и для функций. напомним, что критическое замечание в уравнении. ( [ eq : th12g ] ) заключалось в том, что @xmath4 отменяет, что имеет место, когда все производные возвращают множитель @xmath4. но так же обстоит дело и с упомянутыми выше вращательно-симметричными операторами. например, если мы применим оператор величины градиента к @xmath60, т.е. к логарифму функции изображения с гамма-коррекцией, мы получим @xmath61, возвращающий коэффициент @xmath4, и аналогично для @xmath62, qv и cv. Аналогичный аргумент справедлив для уравнения. ( [ eq : th123g ] ) где мы должны показать, кроме того, что первая производная возвращает множитель @xmath20, вторая производная возвращает множитель @xmath63, а третья производная возвращает множитель @xmath64, что имеет место для наших двумерных операторов.      в то время как производные непрерывных дифференцируемых функций определены однозначно, существует множество способов реализации производных для _ выборочных _ функций. мы следуем примеру Шмида и Мора @ xcite, тер Хаара Ромени @xcite и многих других исследователей в использовании производных функции Гаусса в качестве фильтров для вычисления производных функции выборки изображения с помощью свертки. таким образом, вывод сочетается со сглаживанием. двумерное нулевое среднее гауссово значение определяется как @xmath65 частными производными до третьего порядка являются @xmath66, @xmath67, @xmath68, @xmath69, @xmath70, @xmath71, @xmath72, @xmath73, @xmath74. они показаны на рис. [ рис. : гауссовы ядра ]. мы использовали настройку параметров @xmath75 и размер ядра @xmath76 для этих ядер, например. ( [ eq : th12 g ] ), например, реализован как @xmath77 в each пиксель @xmath78, где @xmath79 обозначает свертку. мы вычисляем инвариант @xmath45 из уравнения. ( [ уравнение : thm12g ] ) двумя разными способами. сначала мы измеряем, насколько инвариант, вычисленный на изображении без гамма-коррекции, отличается от инварианта, вычисленного на том же изображении, но с гамма-коррекцией. теоретически эта разница должна быть равна нулю, но на практике это не так. во-вторых, мы сравниваем точность соответствия шаблону на изображениях интенсивности, опять же без гамма-коррекции и с гамма-коррекцией, с точностью, достижимой, если вместо этого используется инвариантное представление. мы также исследуем, можно ли улучшить результаты с помощью предварительной фильтрации. простым показателем погрешности является _ absolute error _, @xmath80, где `0gc\" относится к изображению без гамма-коррекции, а gc означает либо `sgc\", если гамма-коррекция выполняется синтетически с помощью эквалайзера. ( [ eq : gammacorr ] ), или для ` cgc \", если гамма-коррекция выполняется с помощью аппаратного обеспечения камеры. как и сам инвариант, абсолютная ошибка вычисляется в каждом местоположении пикселя @xmath81 изображения, за исключением границ изображения, где производные и, следовательно, инварианты не могут быть надежно вычислены. [ рис. : imas ] показывает пример изображения. изображение sgc было вычислено из изображения 0gc с помощью @xmath82. Обратите внимание, что гамма-коррекция выполняется _ после _ квантования изображения 0gc, поскольку у нас нет доступа к изображению 0gc до квантования. [ рис. : accuinv ] показывает инвариантные представления данных изображения с рис. [ рис. : imas ] и соответствующие абсолютные ошибки. поскольку у нас есть. темные точки на рис.  [ рис. : accuinv ], ( c ) и ( e ), указывают области с большими ошибками. мы наблюдаем два источника ошибок: * инвариант не может быть надежно вычислен в однородных областях. это неудивительно, учитывая, что он основан на разностях, которые по определению чувствительны только к пространственным изменениям сигнала. * даже в представлении, инвариантном к sgc, есть выбросы в точках с очень высококонтрастными краями. они являются побочным продуктом присущего сглаживания, когда производные вычисляются с использованием дифференциалов Гаусса. обратите внимание, что последнее устанавливает ограничение на максимальную величину градиента, которую можно вычислить на 8-битных изображениях. в дополнение к вычислению абсолютной ошибки, мы также можем вычислить относительную ошибку в процентах, как @xmath83, затем мы можем определить набор @xmath84 _ надежных точек _ относительно некоторого порога ошибки @xmath85, как @xmath86 и @xmath87, процент надежных точек, как @xmath88 где @xmath89 - количество допустимых, т.е. неограниченных, пикселей на изображении. [ рис. : reliapts ] в первой строке показаны надежные точки для трех разных значений порога @xmath85. во второй строке показаны наборы надежных точек для тех же пороговых значений, если мы аккуратно предварительно отфильтруем изображения 0gc и cgc. соответствующие данные для десяти тестовых изображений на рис. [ рис. : imadb ] обобщены в таблице [ tab : reliaperc ]. известно, что производные чувствительны к шуму. шум можно уменьшить путем сглаживания исходных данных перед вычислением инвариантов. с другой стороны, производные должны вычисляться как можно более локально. учитывая эти противоречивые цели, мы экспериментируем с плавной предварительной фильтрацией, используя гауссовский фильтр размером @xmath90=1.0. размер гауссовского фильтра для вычисления инварианта @xmath45 установлен равным @xmath91=1.0. Обратите внимание, что @xmath90 и @xmath91 не могут быть объединены только в один гауссовский из-за нелинейности инварианта. что касается набора надежных точек, мы наблюдаем, что после предварительной фильтрации примерно половина точек в среднем имеет относительную погрешность менее 20%. мягкая предварительная фильтрация последовательно уменьшает как абсолютные, так и относительные ошибки, но сильная предварительная фильтрация - нет. сопоставление с шаблоном - часто используемый метод в компьютерном зрении. здесь мы рассмотрим, как гамма-коррекция влияет на пространственную точность сопоставления с шаблоном и можно ли повысить эту точность с помощью инварианта @xmath45. обзор сценария тестового стенда приведен на рис. 1. [ рис. : templloca ]. небольшой шаблон размером @xmath92, представляющий шаблон поиска, взят из изображения с интенсивностью 0gc, т.е. без гамма-коррекции. затем этот шаблон запроса сопоставляется с соответствующим изображением интенсивности cgc, т.е. с той же сценой, но с включенной гамма-коррекцией. если максимум корреляции приходится точно на то место, где был вырезан шаблон запроса 0gc, мы называем это _ правильной максимальной позицией корреляции_, или cmcp.    используемая здесь корреляционная функция @xmath93 основана на нормализованной среднеквадратичной разнице @xmath94 @xcite : @xmath95, где @xmath1 - изображение, @xmath96 - шаблон, расположенный в @xmath78, @xmath97 - среднее значение подизображения @xmath1 в @xmath78 того же размера, что и @xmath96, @xmath98 - это среднее значение шаблона, а @xmath99. таким образом, проблема определения местоположения шаблона состоит в том, чтобы выполнить эту корреляцию для всего изображения и определить, происходит ли положение максимума корреляции точно в @xmath78. [ рис. : matchtempl ] демонстрирует проблему расположения шаблона, слева - изображение интенсивности, а справа - его инвариантное представление. черным прямоугольником отмечено положение исходного шаблона в точке (40,15 ), а белым прямоугольником отмечено положение совпадающего шаблона, который неправильно расположен в точке (50,64 ) на изображении интенсивности. справа сопоставленный шаблон (белый) перезаписал исходный шаблон (черный) в том же самом, правильно идентифицированном положении. [ рис. : correlexmpl ] визуализирует корреляционную функцию по всему изображению. белые области - это области с высокой корреляцией. пример с рисунков. [ fig : matchtempl ] и [ fig : correlexmpl ] имеет дело только с _ одним _ произвольно выбранным шаблоном. чтобы систематически проанализировать проблему расположения шаблона, мы повторяем процесс корреляции для всех возможных местоположений шаблона. затем мы можем определить _ correlation accuracy _ ca как процент правильно расположенных шаблонов, @xmath100, где @xmath101 - размер шаблона, @xmath102 - набор правильных максимальных позиций корреляции, а @xmath89, опять же, - количество допустимых пикселей. мы вычисляем точность корреляции как для нефильтрованных изображений, так и для изображений с легкой предварительной фильтрацией с помощью @xmath103. [ рис. : corrcorrelpts ] показывает матрицы точности бинарной корреляции для нашего примера изображения. набор cmcp показан белым цветом, его дополнение и границы - черным. мы наблюдаем более высокую точность корреляции для инвариантного представления, которая улучшается за счет предварительной фильтрации. мы вычислили точность корреляции для всех изображений, приведенных на рис. 1. [ рис. : imadb ]. результаты приведены в таблице [ tab : ca ] и визуализированы на рис. [ рис. : correlaccuras ]. мы наблюдаем следующее: * точность корреляции ca выше на инвариантном представлении, чем на изображениях интенсивности. * точность корреляции выше в инвариантном представлении с плавной предварительной фильтрацией, @xmath103, чем без предварительной фильтрации. мы также наблюдали снижение точности корреляции, если мы увеличивали предварительную фильтрацию значительно выше @xmath103. напротив, предварительная фильтрация, по-видимому, всегда отрицательно сказывается на изображениях с интенсивностью. * точность корреляции показывает широкий разброс, примерно в диапазоне 30%@xmath10490% для изображений с нефильтрованной интенсивностью и 50%@xmath104100% для предварительно отфильтрованных инвариантных представлений. аналогичным образом, выигрыш в точности корреляции колеблется от близкого к нулю до 45%. для наших тестовых изображений оказывается, что инвариантное представление всегда лучше, но это не обязательно так. * медианы и средние значения cas для всех тестовых изображений подтверждают повышение точности корреляции для инвариантного представления. * чем больше размер шаблона, тем выше точность корреляции, независимо от представления. больший размер шаблона означает большую структуру и большую способность к распознаванию. мы предложили новые инварианты, которые сочетают инвариантность при гамма-коррекции с инвариантностью при геометрических преобразованиях. в общем смысле инварианты можно рассматривать как замену производных для параметра степенного закона, что делает их интересными для приложений, выходящих за рамки обработки изображений. анализ ошибок нашей реализации на реальных изображениях показал, что для выборочных данных инварианты не могут быть надежно вычислены везде. тем не менее, сценарий приложения, соответствующего шаблону, продемонстрировал, что повышение производительности достижимо при использовании предложенного инварианта. 

_ в этой статье представлены инварианты при гамма-коррекции и преобразованиях подобия. инварианты представляют собой локальные объекты, основанные на дифференциалах, которые реализуются с использованием производных гауссова. показано, что использование предложенного инвариантного представления дает улучшенные результаты корреляции в сценарии сопоставления шаблонов. _