чтобы формально обработать (указать и доказать) некоторые свойства выполнения prolog, нам прежде всего требовалось определение порта. порт, пожалуй, является единственным наиболее популярным понятием в отладке prolog, но теоретически оно все еще кажется довольно неуловимым. это понятие вытекает из основополагающей статьи l.byrd @xcite, в которой определены четыре различных типа потока управления при выполнении prolog, как перемещения в процедурные _ блоки _ и из них _ через четыре _ порта _ этих блоков: * _ вызов _, ввод процедуры для решения цели, * _ exit _, выход из процедуры после успешного завершения, т.е. найдено решение для достижения цели, * _ fail _, выход из процедуры после сбоя, т.е. нет (больше ) решений, * _ redo _, повторный вход в процедуру, т.е. ищется другое решение.    в этой работе мы представляем формальное определение портов, которое представляет собой расчет состояний выполнения, и, следовательно, предоставляем формальную модель чистого выполнения prolog, s: pp. наш подход заключается в определении портов в силу их эффекта, как _портовых переходов_. переход через порт связывает два события. событие - это состояние при выполнении данного запроса @xmath0 по отношению к данной программе prolog @xmath1. мы вводим два ограничения: 1. программа @xmath1 должна быть чистой 2. программа @xmath1 сначала должна быть преобразована в каноническую форму. первое ограничение касается только представления в этой статье, поскольку наша модель была прототипически расширена, чтобы охватить поток управления полным стандартным prolog, как указано в @xcite. канонической формой, которую мы используем, является обычное представление в виде одного предложения. это представление, возможно, \"достаточно близко\" к исходной программе, единственные различия касаются объединения головы (которое теперь делегировано телу) и выбора (который теперь единообразно выражается как дизъюнкция). сначала мы определяем каноническую форму, в которую должна быть преобразована исходная программа. такая синтаксическая форма появляется как промежуточный этап в определении завершения логической программы по Кларку и используется при анализе логических программ. однако нам неизвестно о каком-либо консенсусе относительно названия этой формы. некоторые из названий в литературе - это _ одноклаузальная форма _ @xcite и _ нормализация логической программы _ @xcite. здесь мы используем название _ canonical form _, частично на основании того, что мы также накладываем преобразование на if - then (это дополнительное преобразование не представляет интереса в настоящей статье, которая имеет отношение только к чистому prolog, но мы указываем его для полноты). [ def : canon ] мы говорим, что предикат @xmath2 находится в канонической форме, если его определение состоит из одного предложения @xmath3 здесь @xmath4 - это `каноническое тело\" вида @xmath5, а @xmath6 - `канонический заголовок\", т.е. @xmath7 - различные переменные не отображается в @xmath8. далее, @xmath9 - это дизъюнкция канонических тел (возможно, пустая ), @xmath10 - это конъюнкция целей (возможно, пустая ), а @xmath11 - это цель (для фактов: @xmath12 ). кроме того, каждая цель if - then @xmath13 должна быть частью if - then - else ( например, @xmath14 ).    для следующей программы q(a, q(z, c ) @xmath15r(z ). r(c ).    мы получаем в виде канонической формы q(x, y ) @xmath15x = a, y = b, true; x = z, y = c, r(z ). r(x ) @xmath15x = c, true. @xmath16 представив каждый предикат в виде одного предложения и памятуя о приведенной выше метафоре коробки, мы определили несколько элементарных шагов выполнения. для простоты мы сначала игнорируем переменные.    следующая таблица должна дать некоторое представление об идее. символы @xmath17, @xmath18 в этой таблице служат для идентификации соответствующего повторного перехода в зависимости от перехода выхода. переходы являются детерминированными, поскольку правила не перекрываются. [ рис. : порт : intuit ]    [ cols=\"^, \u003c, \u003c, \u003c, \u003c \", ] [ def : rules ] @xmath19 \\привязки переменных intertext{conjunction }, 2. принятые решения ( или - ветви ), 3. используемые определения предикатов. + среда представлена одним стеком, сохраняющим каждую ставку, как только она вычисляется. для того, чтобы событие представляло состояние чистого выполнения prolog, здесь достаточно одной среды и одного стека предков.    о переходах: * отношение перехода порта является функциональным. то же самое справедливо и для обратного, если оно ограничено _ юридическими событиями _, т.е. событиями, которые могут быть достигнуты из _ начального события _ формы @xmath20. * эта уникальность юридических производных позволяет выполнять _ прямые и обратные _ шаги вывода в духе статьи Берда. * _ модульность _ вывода: выполнение цели может быть абстрагировано, как, например, @xmath21. обратите внимание на тот же a - стек.    под _ atom _ или _ atomary goal _ мы подразумеваем только пользовательские предикации. таким образом, @xmath12, @xmath22 или @xmath23 не должны рассматриваться как атомы. наиболее общие объединители @xmath24 должны быть выбраны идемпотентными, i.e.@xmath25. имена @xmath26 или @xmath27 из должны только предполагать, что аргумент связан с @xmath28 или @xmath29, но фактический поиск определяется тегами @xmath30 и @xmath31, говорящими, что в настоящее время пробуется соответственно первое или второе соединение. например, правило гласит, что вызов @xmath32 приводит к вызову @xmath28 с непосредственным предком @xmath33. такой дополнительный механизм необходим для того, чтобы иметь возможность корректно обрабатывать запрос, подобный @xmath34, где поиск по унификации застрял бы на первом соединении. обратите внимание на требование @xmath35 в . поскольку предложения представлены в канонической форме, объединение заголовка предложения с целью может привести только к переименованию цели. поскольку нам не нужно переименовывать цель, мы можем исправить mgu, чтобы он просто оперировал предложением. [ logupdate : подробнее ] посмотрите, как и служит для реализации _ logical update view _ Линдхольма и okeefe @xcite, в котором говорится, что определение предиката должно быть исправлено во время его вызова. это более подробно объясняется в следующем замечании. хотя мы запоминаем используемое определение предиката _ при выходе _, привязки выхода не повлияют на определение, потому что _ привязки применяются лениво _: вместо того, чтобы `нетерпеливо\" применять любые привязки по мере их возникновения (например, в @xmath23, в разрешении или в чтении), мы решили делать это только в соединение (в правиле ) и нигде больше. в соответствии с правилами и, привязки выхода не должны влиять на определение предиката, как, например, @xmath36.    кроме того, отложенные привязки обеспечивают менее `скачкообразную\" трассировку. скачкообразную трассировку можно проиллюстрировать следующим событием выхода (при условии, что мы с готовностью применили привязки): @xmath37,b,[o|b])}}}}}}}}\\ ifempty{\\{{{{\\ensuremath{\\mathsf{2}}}}}/([i|b]=[i|b]),добавить([],b, b){\\ensuremath{\\mathop{\\bullet}}}{{\\ensuremath{\\mathbb{u}}}}\\}{{\\ensuremath{\\mathbb{\\sigma } } } } } { } { \\ifempty{\\{{{{\\ensuremath{\\mathsf{2}}}}}/([ i|b]=[i|b]),добавить([],b, b){\\ensuremath{\\mathop{\\bullet}}}{{\\ensuremath{\\mathbb{u}}}}\\}}{}{{{,\\, { } } } { { \\ ensuremath{\\mathsf{\\{{{{\\ensuremath{\\mathsf{2}}}}}/([ i|b]=[i|b]),добавить([],b, b){\\ensuremath{\\mathop{\\bullet}}}{{\\ensuremath{\\mathbb{u}}}}\\ } } } } } } \\ ifempty{{{\\ensuremath{\\mathbb{\\sigma}}}}}{}{{{,\\, { } } } { { \\ ensuremath{\\mathit{{{\\ensuremath{\\mathbb{\\sigma } } } } } } } } } } } } \\ ] ] проблема заключается в выходе цель @xmath38,b, b)}$ ] через @xmath39,b,[o|b])}$ ], причем последнее, конечно, не является экземпляром первого. с помощью отложенной привязки мы избегаем скачкообразности и в то же время делаем возможным запоминание определений при выходе. чтобы гарантировать, что трассировка выполнения запроса показывает правильные привязки, событие должно быть напечатано только после того, как к нему была применена текущая подстановка. возможно, более важным побочным преимуществом ленивого связывания является то, что успешный вывод (см. ) всегда может быть абстрагирован следующим образом : @xmath40, даже если @xmath41 случайно был создан в дальнейшем в ходе этого вывода. создание экземпляра будет отражено в b -стеке, но не в самой цели. пусть @xmath1 будет программой. _ отношение перехода порта _ @xmath42wrt @xmath1 определено в. обратное отношение должно быть обозначено @xmath43. если @xmath44, мы говорим, что @xmath45 _ приводит к _ @xmath46. событие @xmath46 может быть _ введено _, если к нему приводит какое-либо событие. событие @xmath46 может быть _ оставлено _, если оно приводит к какому-либо событию. отношение @xmath42 является функциональным, т.е. для каждого события @xmath46 может быть не более одного события @xmath45, такого что @xmath47. посылки правил перехода являются взаимно непересекающимися, т.е. критических пар нет. [ пример : rel : converse ] обратное отношение перехода порта не является функциональным, поскольку может быть более одного события, приводящего к одному и тому же событию : @xmath48 мы могли бы предотвратить неоднозначную ситуацию, описанную выше, и сделать обратное отношение также функциональным, предоставив естественные условия для повторных переходов для атомарных цель и объединение. однако далее будет показано, что для событий, которые являются _ legal _, обратное отношение в любом случае является функциональным. пусть @xmath1 будет программой. пусть @xmath49, @xmath46 будут событиями. @xmath1-производное @xmath46 от @xmath49 _, записанное как @xmath50, представляет собой путь от @xmath49 к @xmath46 в отношении перехода порта wrt @xmath1. мы говорим, что @xmath46 может быть _ достигнут _ из @xmath49. _ начальное событие _ - это любое событие вида @xmath51, где @xmath0 - это цель. цель @xmath0 начального события называется _ целью верхнего уровня _ или _ запросом_.    пусть @xmath1 будет программой. если существует цель @xmath0, такая, что @xmath52 является производным @xmath1, тогда мы говорим, что @xmath50 является _ законным @xmath1-производным _, @xmath46 является _ законным @xmath1-событием _, а @xmath53 является @xmath1-_исполнением _ запроса @xmath0. юридическое событие @xmath46 является _ заключительным _ событием по отношению к программе @xmath1, если нет перехода @xmath54 по отношению к @xmath1. если @xmath55 - это событие, а @xmath56, то мы говорим, что @xmath57 является _ родительским _ для @xmath11. функция определяется следующим образом: @xmath58 и аналогично для дизъюнкции. пусть @xmath46 будет событием с портом @xmath59. если @xmath60 является одним из @xmath61, то @xmath46 является _ push _ событием. если @xmath60 является одним из @xmath62, то @xmath46 является _ pop _ событием. [ lem : finalevent ] если @xmath46 является законным событием pop, и его a - стек не пуст, то в соответствии с правилами (см. также приложение [ приложение : оставить ] ), возможности для выхода из события exit следующие: @xmath63 в этих правилах указано, что всегда можно оставить событие выхода @xmath64, за исключением следующих двух ограничений: родительской целью не может быть @xmath12, @xmath22 или объединение; и если родительская цель @xmath65 является дизъюнкцией, тогда должно быть @xmath66, т.е. невозможно оставить событие @xmath67, если @xmath68 ( и аналогично для второго дизъюнкта ). первое ограничение недействительно, поскольку родителем не может быть @xmath12, @xmath22 или объединение в любом случае, согласно правилам. остается показать, что второе ограничение также недействительно, т.е. законное событие выхода обязательно обладает свойством. рассматривая правила ввода события выхода, мы отмечаем, что целевая часть события выхода либо берется из a - стека, либо является @xmath12 или @xmath23. последние две возможности мы можем исключить, потому что @xmath69 может быть получен только из @xmath70, который не может быть достигнут, если @xmath71. аналогично для объединения. таким образом, целевая часть события законного выхода должна поступать из a - стека. элементы a - стека происходят из событий вызова / повтора, и у них есть свойство. в заключение, мы всегда можем оставить законное событие exit с непустым a - стеком. аналогично для события fail.    [ lem : uniq ] если @xmath46 является юридическим событием, то у @xmath46 может быть только один юридический предшественник и только один преемник. в случае, если @xmath46 не является начальным, существует ровно один юридический предшественник. в случае, если @xmath46 не является окончательным, существует ровно один преемник. часть преемника вытекает из функциональности @xmath42. рассматривая правила, мы отмечаем, что только два вида событий могут иметь более одного предшественника: @xmath72 и @xmath73. пусть @xmath73 будет юридическим событием. его предшественником, возможно, был @xmath74, при условии, что @xmath75 и @xmath76 не имеют mgu ( правило ), или это мог быть @xmath77 (правило). в последнем случае @xmath77 должно быть юридическим событием, поэтому b - стек@xmath78 должен был быть производным. единственное правило, способное вывести такой b - stack, - это при условии, что предыдущее событие было @xmath74 и @xmath79. следовательно, у @xmath73 может быть только один законный предшественник, зависящий исключительно от @xmath75 и @xmath76. аналогичным аргументом мы можем доказать, что у @xmath72 может быть только один законный предшественник. на этом завершается доказательство функциональности обратного отношения, если оно ограничено набором юридических событий.    для удобства обозначения все события, которые не являются окончательными и не приводят к каким-либо дальнейшим событиям посредством переходов относительно данной программы, как говорят, приводят к _ impossible event _, записанному как @xmath80. аналогично для событий, которые не являются начальными событиями и не могут быть введены. в частности, @xmath81 и @xmath82 в отношении любой программы. вот некоторые невозможные события : @xmath83, @xmath84 (невозможно ввести, не является начальным ) и @xmath85 (невозможно оставить, не является окончательным ). [ lem : незаконно ] если @xmath86, то @xmath46 нелегален. если @xmath87, то @xmath46 нелегален. пусть @xmath88. если @xmath46 является законным, то, из-за уникальности перехода, @xmath45 также должен быть законным.    [ lem : uptodate ] для события юридического вызова @xmath89 содержит значение @xmath90, что означает, что замены из b - стека _ уже применены _ к вызываемой цели. другими словами, цель любого законного события вызова является актуальной относительно текущей замены. обратите внимание, что это свойство справедливо только для событий вызова. объединение стеков мы обозначаем @xmath91. объединение с обоими стеками события, которое мы обозначаем @xmath92 : если @xmath93, то @xmath94. пусть @xmath1 будет программой. пусть @xmath95 будет одним из @xmath96. если @xmath97 является законным @xmath1-производным, то для каждого a - стека @xmath98 и для каждого b - стека@xmath99, так что @xmath100 является законным событием, выполняется: @xmath101 также является законным @xmath1-производным.    обратите внимание, что наши правила (за исключением ) относятся только к существованию верхнего элемента некоторого стека, но никогда к пустоте стека. поскольку верхний элемент стека @xmath102 не может измениться после добавления другого стека к @xmath102, можно эмулировать каждый из исходных шагов вывода, используя \"новые\" стеки. остается рассмотреть правило, которое применяет всю текущую замену ко второму союзу. прежде всего обратите внимание, что любые переменные в юридическом выводе вытекают либо из цели верхнего уровня, либо являются свежими. согласно, событие вызова всегда актуально, т.е. текущая подстановка уже применена к цели. наиболее общие объединители могут быть выбраны идемпотентными, поэтому многократное применение подстановки равносильно одному применению. следовательно, если @xmath100 является юридическим событием, замена @xmath99 не может повлиять ни на какие переменные исходного вывода. уникальность и модульность юридических портовых производных позволяют нам кратко определить некоторые традиционные понятия. [ def : success ] указано, что цель @xmath11 заключается в завершении программы wrt @xmath1, если существует @xmath1-производная @xmath103, где @xmath95 является одним из @xmath104. в случае @xmath105 вывод является _ успешным _, в противном случае это _ неудачный_.    при неудачном выводе @xmath106. при успешном выводе @xmath107 - это @xmath108, ограниченный переменными @xmath11, называемый _ вычисленной заменой ответа _ для @xmath11. уникальность шагов юридического вывода позволяет выполнять шаги прямого и обратного вывода в духе статьи Берда. события push (вызов, повтор) более поддаются шагам прямого вывода, а события pop (выход, сбой) более поддаются шагам обратного вывода. мы проиллюстрируем это небольшим примером. если события с левой стороны являются законными, то следующие являются юридическими производными (для соответствующих @xmath109, @xmath110 ) : @xmath111 первое утверждение утверждает: если @xmath112 является законным, то оно было достигнуто через @xmath113. без проверки @xmath99, в общем, неизвестно, является ли дизъюнкция завершилась успешно через свой первый или через свой второй член. но в этой конкретной дизъюнкции второй член не может быть успешным: предположим, что есть некоторые @xmath114, @xmath109 с @xmath115. согласно правилам: @xmath116 итак, согласно, @xmath117 не является юридическим событием, что доказывает. аналогично, неправовой вывод доказывает. модульность юридических производных позволяет абстрагироваться от выполнения цели, как в следующем примере. предположим, что цель @xmath118 достигнута успешно, т.е. @xmath119. тогда у нас есть следующий юридический вывод: @xmath120 если @xmath118 терпит неудачу, то мы имеем: @xmath121 в этой статье мы даем простое математическое определение s: pp 4-портовой модели чистого prolog. был очерчен некоторый потенциал для формальной проверки чистого prolog. есть два интересных направления для будущей работы в этой области: \\(1 ) формальная спецификация потока управления _ full standard prolog _ (в настоящее время у нас есть прототип для этого в рамках 4-портовой модели) \\(2 ) формальная спецификация и доказательство некоторых нетривиальных свойств программы, как адекватность и невмешательство в практическую трансформацию программы. что касается попыток формального определения 4-портовой модели, то нам известно лишь о нескольких предыдущих работах. одна из них - основанная на графах модель Тобермана и Бекштейна @ xcite, которые формализуют идею обхода графа Берда, определяя понятие _ trace_ (данного запроса относительно данной программы) как путь в графе трассировки. порты довольно четко определены как иерархические узлы такого графа. однако даже для простой рекурсивной программы и основного запроса с конечным sld - деревом соответствующий граф трассировки бесконечен, что ограничивает его применимость. другая модель byrd box - это основанный на продолжении подход jahier, ducass и ridoux @xcite. в @xcite также есть попытка на основе стека, но, хотя она предусматривает некоторую параметризацию, она сталкивается, по сути, с той же проблемой, что и подход, основанный на продолжении, а также прототипная реализация трассировщика, приведенная в @xcite, взятая в качестве спецификации выполнения prolog: в этих трех попытках, a порт представлен некоторым семантическим действием (например, написанием сообщения ), а не формальным методом. поэтому неясно, как использовать любую из этих моделей для доказательства некоторых утверждений, связанных с портом. в отличие от нескольких спецификаций byrd box, существует множество более общих моделей чистого (или даже полного) выполнения prolog. из-за ограниченности пространства мы упоминаем здесь только некоторые модели, непосредственно относящиеся к s: pp, а для более подробного обсуждения смотрите, например, @xcite. сопоставимыми с нашей работой являются подходы, основанные на стеке. strk дает в @xcite, в качестве побочного вопроса, простую операционную семантику чисто логического программирования. состояние выполнения - это стек стеков фреймов, где каждый фрейм состоит из цели (предка) и окружения. для сравнения, наше состояние выполнения состоит ровно из одной среды и одного стека предков. основополагающая статья Джонса и Майкрофта @xcite была первой, в которой была представлена модель выполнения на основе стека, применимая к чистому prolog с добавлением cut. в ней используется последовательность фреймов. в этих подходах, основанных на стеке (включая нашу предыдущую попытку @xcite), отсутствует _модульность_, i.e.it невозможно абстрагировать выполнение подцели. 

дано простое математическое определение 4-портовой модели для чистого prolog. модель сочетает в себе интуитивное понимание портов с компактным представлением состояния выполнения. возможны шаги прямого и обратного вывода. модель удовлетворяет требованию модульности, что делает ее пригодной для формальных рассуждений.