процессы ретикуляции относятся к передаче генетического материала между живыми организмами невоспроизводящимся способом. считается, что горизонтальный перенос генов является чрезвычайно важным процессом ретикуляции, происходящим между одноклеточными организмами (doolittle and bapteste 2007; treangen and rocha 2011). другие процессы ретикуляции включают интрогрессию, рекомбинацию и гибридизацию (fontaine et al. 2015; mcbreen and lockhart 2006 ; marcussen et al. 2014). в за последние два десятилетия филогенетические сети часто использовались для моделирования и визуализации процессов ретикуляции (gusfield 2014; huson et al., 2011). затененные деревья, затененные сети, видимые сети ретикуляции - это три популярных класса филогенетических сетей, введенных для изучения комбинаторных и алгоритмических перспектив филогенетики (wang et al. al. 2001 ; gusfield et al. 2004 ; huson and kloepper 2007 ; huson et al. 2011 ). видимые сети ретикуляции включают поврежденные деревья и поврежденные сети. они основаны на дереве (gambette et al., 2015 ). сети на основе дерева были недавно представлены Фрэнсисом и Стилом (francis and steel, 2015). хорошо известно, что число внутренних узлов в филогенетическом дереве с листьями @xmath0 равно @xmath4. напротив, произвольная филогенетическая сеть с 2 листьями может иметь столько внутренних узлов, сколько возможно. следовательно, одна интересная исследовательская проблема заключается в том, насколько большой может быть филогенетическая сеть в определенном классе. например, хорошо известно, что дочерняя древовидная сеть с листьями @xmath0 имеет максимум узлов, не являющихся листьями @xmath2. обычная сеть с листьями @xmath0 имеет максимум узлов @xmath5 (willson 2010 ). чтобы исследовать, разрешима ли проблема сдерживания дерева за полиномиальное время, удивительно, но gambette et al. (2015) доказали, что сеть с видимой сеткой с листьями @ xmath0 имеет не более @xmath6 нелистовых узлов. класс почти стабильных сетей также был представлен в их статье. они также доказали существование линейной верхней границы числа узлов сетки в почти стабильной сети.    в настоящей статье мы устанавливаем жесткую верхнюю границу для размера сети, определяемого свойством видимости, используя метод поддеревьев, который был представлен в gambette et al. остальная часть этой статьи разделена на шесть разделов. раздел [ sec : basic ] знакомит с концепциями и обозначениями, необходимыми для нашего исследования. недавно Бордевич и Сэмпл (2015) доказали, что в видимой сети ретикуляции существует не более @xmath2 узлов ретикуляции. в разделе [sec : stable ] мы представляем другое доказательство жесткой привязки @xmath2 для сетчатых видимых сетей. раздел [ sec : galled ] доказывает, что в сетях galled с листьями @xmath0 имеется не более узлов сетки @xmath1. разделы [ sec : nearlystable ] и [ sec : stablechild ] устанавливают жесткие верхние границы для размеров сетей с почти стабильной и стабильно дочерней структурой соответственно. в разделе [ conc ] мы завершаем работу несколькими замечаниями. ациклический орграф - это простой связный орграф без направленных циклов. пусть @ xmath7 - ациклический орграф, а @xmath8 и @xmath9 - два узла в @xmath10. если @xmath11, то это называется _ исходящим _ ребром @xmath8 и _ входящим _ ребром @xmath9; @xmath8 и @xmath9 называются хвостом и головой ребра. номера входящих и исходящих ребер узла называются его _ indegree _ и _ outdegree _ соответственно. @xmath10 называется _ rooted _, если существует уникальный узел @xmath12 с indegree 0 ; @xmath12 называется _ root _ из @xmath10. обратите внимание, что в корневом ациклическом орграфе существует направленный путь от корня к любому другому узлу.    для @xmath13 @xmath14 обозначает орграф с тем же набором узлов и набором ребер @xmath15. для @xmath16 @xmath17 обозначает орграф с набором узлов @xmath18 и набором ребер @xmath19. если @xmath20 и @xmath21 являются подграфами @xmath10, @xmath22 обозначает подграф с набором узлов @xmath23 и набором ребер @xmath24. филогенетическая сеть на конечном наборе таксонов, @ xmath25, является корневым ациклическим орграфом, в котором каждый некорневой узел имеет либо степень 1, либо внешнюю степень 1, и есть ровно @xmath26 узлов внешней степени 0 и внутренней степени 1, называемых _ leaves _, которые соответствуют один к одному с таксонами в сети.    в филогенетической сети узел называется узлом дерева, если он является либо корневым, либо узлом, имеющим единицу степени; он называется узлом ретикуляции, если его степень больше единицы. обратите внимание, что листья являются узлами дерева, а узел дерева может иметь как внутреннюю, так и внешнюю степень. узел, не являющийся листом, называется внутренним. филогенетическая сеть без узлов ретикуляции - это просто филогенетическое дерево.    для филогенетической сети @xmath27 мы используем следующие обозначения: * @xmath28 : корень @xmath27. * @xmath29 : набор узлов. * @xmath30 : набор узлов дерева. * @xmath31 : набор узлов сетки. * @xmath32 : набор ребер. * @xmath33 : набор листьев.    для двух узлов @xmath34 в @xmath29, если @xmath35, @xmath8 считается _ родительским _ для @xmath9 и, что эквивалентно, @xmath9 является _ дочерним _ для @xmath8. в общем, если существует направленный путь от @xmath8 к @xmath9, @xmath8 является _ предком _ @xmath9, а @xmath9 является _ потомком _ @xmath8. иногда мы говорим, что @xmath9 находится ниже @xmath8, когда @xmath8 является предком @xmath9. пусть @xmath36 и @xmath37 - это два простых пути от @xmath8 к @xmath9 в @xmath27. мы используем @xmath38 и @xmath39 для обозначения их наборов узлов соответственно. они _ внутренне не пересекаются _, если @xmath40. наконец, филогенетическая сеть является _ бинарной_, если ее корень имеет внешнюю степень 2 и внутреннюю степень 0, все внутренние узлы имеют степень 3, а все листья имеют внутреннюю степень один. здесь нас интересует, насколько большой может быть бинарная филогенетическая сеть.    в остальной части статьи бинарная филогенетическая работа называется просто сетью, а филогенетическое дерево - деревом. для удобства обсуждения мы также добавляем открытое ребро, входящее в корень сети. узел @xmath9 в сети является _ видимым_ (или стабильным) по отношению к конечному @xmath41, если @xmath9 находится на каждом пути от корня сети до @xmath41. мы говорим, что @xmath9 виден, если он виден относительно какого-либо листа в сети. [ prop1 ] пусть @xmath27 будет сетью, а @xmath42 - подсетью @xmath27 с тем же корнем и листьями, что и @xmath27. тогда узел будет виден в @xmath42, если он виден в @xmath27. эквивалентно, узел не будет виден в @xmath27, если он не виден в @xmath42. предположим, что @xmath43 виден относительно листа @xmath41 в @xmath27. для каждого пути @xmath36 от @xmath44 до @xmath41, поскольку это также путь от @xmath28 до @xmath41 в @xmath27, он должен проходить через @xmath9. таким образом, @xmath9 также виден относительно того же листа в @xmath42. _ сети с видимой сеткой _ сети, в которых все узлы сетки видны (huson et al. они также называются стабильными сетями gambette et al. (2015). сеть называется _ galled _, если у каждого узла сетки @xmath45 есть предок @xmath46, такой, что существуют два непересекающихся древовидных пути от @xmath46 до @xmath45 (huson and kloepper 2007). здесь путь - это путь к дереву если его внутренними узлами являются все узлы дерева в сети. поврежденные сети имеют видимую сетчатку и также известны как сети уровня 1. _ почти стабильные _ сети - это сети, в которых для каждой пары узлов @xmath8 и @xmath9 отображается либо @xmath8, либо @xmath9, если @xmath47 является ребром (gambette et al., 2015 ).  сети _ stable - child _ - это сети, в которых у каждого узла есть видимый дочерний узел. древовидные сети представляют собой еще один интересный класс сетей, который был представлен недавно (francis and steel 2015). сеть называется древовидной, если ее можно получить из дерева с одинаковыми листьями путем вставки набора ребер между разными ребрами в дереве. [ stable_1 ] ( gambette et al., 2015 ) для каждой сети, видимой с помощью сетки @xmath27, существует подмножество ребер @xmath48, такое, что @xmath49 содержит точно входящее ребро для каждого узла сетки, а @xmath50 является поддеревом с теми же листьями, что и @xmath27. теорема [ stable_1 ] указывает на то, что каждая сеть, видимая при ретикуляции, основана на дереве. однако сети с почти стабильной структурой и сети со стабильными дочерними элементами не обязательно основаны на дереве. мы завершаем этот раздел представлением технической леммы, которая часто будет использоваться при установлении жесткой верхней границы размера сети в каждом из четырех классов, определенных выше. [ лемма22 ] пусть @xmath27 - сеть, @xmath51 и @xmath52 - конечный набор узлов сетки ниже @xmath8. если у каждого @xmath53 есть родительский @xmath54, так что либо (а ) @xmath54 находится ниже другого @xmath55 в @xmath52, либо ( б ) существует путь от @xmath56 к @xmath54, который избегает @xmath8, тогда существует путь от @xmath56 к @xmath41, избегающий @xmath8 для каждый лист @xmath41 находится под узлом сетки @xmath53. пусть @xmath57. предположим, что @xmath41 находится ниже некоторого @xmath58. тогда существует путь @xmath59 от @xmath60 к @xmath41, который позволяет избежать @xmath8. поскольку @xmath52 конечен, а @xmath27 ацикличен, существует ряд узлов сетки, @xmath61 таких, что: \\ (i ) каждый @xmath62 имеет родительский @xmath63 ниже @xmath64 для @xmath65, и \\(ii ) узел @xmath66 имеет родительский @xmath67 такой, что существует это путь @xmath68 от @xmath28 к @xmath67, который позволяет избежать @xmath8. поскольку @xmath63 находится ниже @xmath64, существует путь @xmath69 от @xmath64 до @xmath70 для каждого @xmath71. поскольку @xmath27 является ациклическим, а @xmath64 находится ниже @xmath8, путь @xmath69 избегает @xmath8. объединяя эти пути, мы получаем следующий путь @xmath72 от @xmath73 к @xmath41, который позволяет избежать @xmath8. gambette et al. (2015) доказали, что в видимой сети ретикуляции имеется не более @xmath74 узлов ретикуляции с помеченными @xmath0 листьями. с другой стороны, в сети reticulation visible на рисунке имеется столько же сеток, сколько @xmath2  [ рис. 1 ]. итак, какова жесткая верхняя граница количества узлов сетки? интересно, что @xmath2 - это жесткая верхняя граница, которая была независимо доказана Бордевичем и Сэмплом (2015) с использованием индукционного подхода. здесь мы приводим альтернативное доказательство, чтобы проиллюстрировать наш подход.     имеют степень 3 [рис. 1], scaledwidth=80,0% ] учитывая сетчатую видимую сеть @xmath27 с листьями @xmath0, мы позволяем @xmath49 быть набором ребер, таким образом, что @xmath50 является поддеревом с тем же корнем и листьями, что и @xmath27 (теорема [ stable_1 ] ). поскольку @xmath50 имеет листья @xmath0, есть ровно узлы @xmath4 степени 3. таким образом, существуют пути @xmath75, внутренние узлы которых имеют степень 2, начинающиеся с узла степени 3 и заканчивающиеся либо другим узлом степени 3, либо листом. пусть эти пути @xmath75 будут @xmath76. ребра @xmath50, отсутствующие в @xmath77, образуют путь @xmath78, который содержит корень @xmath56 (рисунок [ fig1 ] ). если @xmath56 имеет степень 2, @xmath78 проходит через @xmath28 и заканчивается в узле степени 3. если @xmath28 имеет степень 3, @xmath78 - это просто открытое ребро, входящее в @xmath56. в целом, эти пути @xmath79 называются _ тривиальными путями _ из @xmath50. обратите внимание, что @xmath80. нетрудно заметить, что для каждого ребра в @xmath49 его голова и хвост находятся в этих тривиальных путях. ребро @xmath81 называется _ cross _ edge, если @xmath82 и @xmath83 для @xmath84; в противном случае оно называется _ non - cross _ edge. факты в следующем предложении появляются в доказательстве теоремы 1 в gambette et al (2015).    [ 31 ] * никакие два пересекающихся ребра @ xmath85 не имеют своих вершин на одном и том же тривиальном пути в @ xmath50. * для каждого непересекающегося ребра @xmath47, такого, что @xmath86 для некоторого @xmath87, существует по крайней мере одно перекрестное ребро @xmath88, такое, что @xmath89 находится между @xmath8 и @xmath9 в @xmath90.    для перекрестного ребра @xmath47, такого, что @xmath82 и @xmath83(@xmath91 ), мы говорим, что @xmath47 _ покидает _ @xmath90 и _ входит _ @xmath92. для непересекающегося пути @xmath47 и перекрестного ребра @xmath93, если @xmath8 и @xmath9 находятся в @xmath94, а @xmath89 является узлом между @xmath8 и @xmath9 в @xmath90, мы говорим, что @xmath47 _ перепрыгивает через _ @xmath93. тривиально видеть, что ни одно перекрестное ребро не входит в тривиальный путь @xmath78. предложение [ 31 ] предполагает, что @xmath49 содержит не более @xmath75 перекрестных ребер и, следовательно, не более @xmath75 непересекающихся ребер. по теореме [ stable_1 ], @xmath95.    чтобы получить жесткую верхнюю границу @xmath96 для @xmath97, мы определяем стоимость @xmath98 перекрестного ребра @xmath85 следующим образом: @xmath99 мы отнесем стоимость перекрестного ребра к тривиальному пути, в который оно входит, и назовем это _ весом _ тривиального пути. если ни одно поперечное ребро не входит в тривиальный путь, вес этого тривиального пути устанавливается равным 0. согласно предложению [ 31 ], вес тривиального пути не более 2. мы используем @xmath100 для обозначения веса тривиального пути @xmath90, @xmath101. . @xmath102 являются три тривиальных пути, инцидентных узлу степени 3 @xmath103 ; @xmath104 - это перекрестное ребро, заканчивающееся на @xmath105 в @xmath106, а непересекающееся ребро @xmath107 перепрыгивает через @xmath104 для @xmath108. здесь @xmath109 не нарисован. ( * a * ) @xmath110 и @xmath111 оба находятся между @xmath103 и @xmath112 в @xmath113. ( * b * ) @xmath110 находится между @xmath103 и @xmath112 в @xmath113, но @xmath111 находится ниже @xmath112 в @xmath113. ( * c * ) узел @xmath110 находится ниже @xmath112, а @xmath114 находится ниже @xmath115. этот случай невозможен, поскольку существует направленный цикл. [рис. 2], scaledwidth=95,0% ] для внутреннего узла @xmath103 степени 3 в @xmath50 мы используем @xmath116 для обозначения тривиального пути, входящего в @xmath103, и @xmath117 для обозначения двух тривиальных путей, выходящих из @xmath103. [ stable_3 ] пусть @xmath103 будет узлом степени 3 в @xmath50. \\(i ) если @xmath118 и @xmath119, то @xmath120. \\(ii ) если @xmath121, то @xmath122 и @xmath123.    для простоты мы разрешаем @xmath124 и используем @xmath125 для обозначения уникального пути от @xmath126 к @xmath127 для узла @xmath126 и потомка @xmath127 от @xmath126 в @xmath128. @xmath27 и @xmath128 имеют одинаковые корень и листья. общий корень @xmath27 и @xmath128 записывается как @xmath73. \\(i ) предположим, что @xmath118 и @xmath119. тогда существует перекрестное ребро @xmath129, входящее в @xmath130, и непересекающееся ребро @xmath131, перепрыгивающее через @xmath129 для каждого @xmath132. мы докажем, что @xmath120, показав, что ни одно перекрестное ребро не входит в @xmath116. предположим, что @xmath110 находится между @xmath103 и @xmath112 в @xmath113. когда @xmath111 находится ниже @xmath110 в @xmath133 (рисунок [ fig2]a ), есть два случая. если @xmath114 находится в пути @xmath134 или ниже него, то @xmath135 не передает @xmath111. если @xmath114 не находится ниже @xmath103, @xmath135 не передает @xmath103 и, следовательно, @xmath111. следовательно, согласно лемме [ lemma22 ], существует путь от @xmath73 к каждому листу ниже @xmath112, который не проходит @xmath111. для любого листа @xmath41, расположенного не ниже @xmath112 в @xmath128, @xmath136 избегает @xmath111. следовательно, @xmath111 является узлом сетки в @xmath27, но не виден. это противоречие. когда @xmath111 находится ниже @xmath112 в @xmath128 (рисунок [ fig2]b ), @xmath111 находится ниже @xmath112 в качестве узла сетки. поскольку @xmath137 не передает @xmath112, согласно лемме [ lemma22 ], существует путь от @xmath73 к листу ниже @xmath112, который не передает @xmath112. для любого листа @xmath41 не ниже @xmath112 в @xmath128, @xmath136 избегает @xmath112. следовательно, @xmath112 не виден, что является противоречием.    мы доказали, что @xmath110 не находится между @xmath103 и @xmath112 в древовидном пути @xmath113. по симметрии, @xmath114 не находится между @xmath103 и @xmath115 в @xmath134. предположим, что существует перекрестное ребро, входящее в @xmath116. пусть @xmath45 будет самым низким узлом сетки в @xmath116. тогда @xmath110 и @xmath114 оба не находятся в @xmath138. в противном случае либо @xmath111, либо @xmath139 находятся между @xmath45 и @xmath103, что противоречит тому, что @xmath45 является самым низким узлом сетки в @xmath116. объединяя этот факт с тем, что @xmath140 не находится между @xmath103 и @xmath141 в @xmath128 для @xmath142 мы приходим к выводу, что либо @xmath140 находится ниже @xmath141, либо существует путь от @xmath73 до @xmath140, не проходящий @xmath45 для каждого @xmath142. следовательно, согласно лемме [ lemma22 ], @xmath45 не виден ни для одного листа ниже @xmath45. для любого листа @xmath41 не ниже @xmath45 в @xmath128 древовидный путь @xmath136 избегает @xmath45. следовательно, @xmath45 не виден, противоречие. мы доказали, что @xmath120. \\(ii ) если @xmath121, то @xmath103 является предком любого другого узла степени 3 в @xmath50. поскольку @xmath27 является ациклическим, не существует @xmath143 такого, что @xmath144 для некоторых @xmath145 и @xmath146. следовательно, @xmath147. предположим, наоборот, что веса @xmath134 и @xmath113 равны 2. тогда @xmath140 не находится между @xmath103 и @xmath141 для @xmath142, как доказано выше. если @xmath110 или @xmath114 находятся в @xmath78, самая низкая сетка в @xmath78 не видна, что является противоречием. в противном случае @xmath110 находится ниже @xmath112, а @xmath114 находится ниже @xmath115, что подразумевает цикл в @xmath27 (рисунок [ fig2]c ). это противоречие. следовательно, либо @xmath134, либо @xmath113 имеют вес меньше 2. @xmath148 пусть @xmath27 будет сетчатой видимой сетью с листьями @xmath0. затем @xmath149 пусть @xmath150 обозначает набор внутренних узлов @xmath151 степени 3 в @xmath50. обратите внимание, что любой тривиальный путь, отличный от @xmath78, начинается с узла в @xmath150 define : @xmath152 для @xmath153. очевидно, что @xmath154 попарно не пересекаются и, следовательно, @xmath155, когда @xmath156, @xmath157. по предложению [ stable_3 ], @xmath158. пусть @xmath159 будет начальным узлом @xmath160 для каждого @xmath156. опять же, согласно предложению [ stable_3 ], @xmath161. ясно, что в соответствии с картой @xmath162 не более двух узлов в @xmath163 сопоставляются с одним и тем же узлом в @xmath164, а разные узлы в @xmath163 сопоставляются с разными узлами в @xmath165. таким образом, @xmath166. поскольку @xmath147, неравенство подразумевает, что @xmath167\\\\ & = & |v_1|+2|v_2|+3|v_3|+ ( 3|v_4|+|v_4| ) \\\\ & \\leq & 2(|v_0|+|v_1| ) + 3(|v_2|+|v_3|+|v_4|)\\\\ & \\leq & 3(|v_0|+|v_1|+|v_2|+|v_3|+|v_4|)\\\\ & = & 3(n-1 ), \\end{массив}\\ ] ] где первое неравенство выводится из замены @xmath168 на @xmath169. сети galled образуют подкласс сетей с видимой сеткой (huson et al., 2011 ). в этом разделе мы покажем, что в сети galled с листьями @xmath0 существует не более @xmath1 сеток. учитывая, что сеть galled, показанная на рисунке [рис. 3]a, имеет ровно @xmath1 сеток, @xmath1 - это жесткая граница количества узлов сетки в сети galled с листьями @xmath0. : в @xmath49 есть непересекающееся ребро @xmath47, такое, что @xmath8 и @xmath9 находятся в @xmath78, и есть перекрестное ребро @xmath170 и непересекающееся ребро @xmath109, оба заканчивающиеся на узле в тривиальном пути, отличном от @xmath78, где @xmath171 не нарисован. в (* b * ) и (* c * ) сплошные прямые и кривые стрелки представляют ребра и пути в @xmath50 соответственно; стрелки с круглыми точками представляют ребра в @xmath49 соответственно [рис. 3], scaledwidth=80,0% ] [ gn_1 ] для поврежденной сети @xmath27 с листьями @xmath0, @xmath172 пусть @xmath27 - замкнутая сеть с листьями @xmath0 и пусть @xmath173. поскольку @xmath27 является видимой сеткой, по теореме [ stable_1 ] существует набор ребер @xmath49 такой, что ( a ) @xmath49 содержит ровно одно входящее ребро для каждого узла сетки и ( b ) @xmath50 - это поддерево с теми же листьями, что и @xmath27. мы используем те же обозначения, что и в разделе 3. @xmath78 обозначает тривиальный путь, первым ребром которого является открытое ребро, входящее в @xmath73; @xmath174 обозначают другие тривиальные пути @xmath75 в @xmath50. мы доказываем результат, показывая, что @xmath49 не содержит никаких непересекающихся ребер, и только одно перекрестное ребро может заканчиваться узлом в каждом @xmath90 для @xmath145. если @xmath78 содержит только открытое ребро, входящее в @xmath73, в @xmath49 нет ребра, которое входит в @xmath78. сначала мы докажем, что этот факт яэто также верно, даже если @xmath78 содержит другие ребра ниже @xmath73. поскольку @xmath27 является ациклическим и существует направленный путь от конца @xmath78 к узлу в @xmath90 для любого @xmath145, нет перекрестного ребра @xmath81, такого, что @xmath8 находится в @xmath90, а @xmath9 находится в @xmath78.    если существует непересекающееся ребро @xmath175, такое, что @xmath176 находятся в @xmath78 (рисунок [ fig3]b ), мы позволяем @xmath89 быть другим дочерним элементом @xmath8 в @xmath78. тогда @xmath89 должен быть узлом дерева, таким как @xmath88, где @xmath177 - узел сетки в некотором тривиальном пути @xmath90, @xmath145. ( если @xmath89 - это сетка, то она не видна, противоречие. ) поскольку @xmath27 помечен, а @xmath177 является узлом ретикуляции, существуют два пути @xmath178 и @xmath179 от общего узла дерева к @xmath177 в @xmath27 таким образом, что (i ) они внутренне не пересекаются и ( 2 ) @xmath177 является единственным узлом ретикуляции в них. обратите внимание, что никакие ребра в @xmath49, кроме @xmath93, не могут отображаться в @xmath178 и @xmath179. в противном случае либо @xmath178, либо @xmath179 содержат другой узел сетки. таким образом, @xmath180 является поддеревом @xmath50. это означает, что один из @xmath178 и @xmath179 является единственным ребром @xmath93, а другой - @xmath181, уникальным путем от @xmath89 к @xmath177 в дереве @xmath50. это невозможно, поскольку узел ретикуляции @xmath9 находится в @xmath181. мы показали, что в @xmath49 нет ребра, которое входит в @xmath78. далее мы покажем, что в @xmath49 есть не более одного ребра, которое входит в @xmath90 для каждого @xmath182. предположим, что @xmath183 и @xmath184 являются двумя ребрами в @xmath49, так что @xmath139 находится ниже @xmath111 в некотором @xmath90 (@xmath145 ) (рисунок [fig3]c ). тогда @xmath185 должен быть непересекающимся ребром, а @xmath186 также находится ниже @xmath111. (в противном случае @xmath111 не виден. ) опять же, по факту ( 2 ) в предложении [ 31 ] существует перекрестное ребро @xmath187, такое, что @xmath89 находится между @xmath186 и @xmath139 в @xmath90, а @xmath177 находится в @xmath188, @xmath189. поскольку @xmath177 является узлом ретикуляции, а @xmath27 удален, существует это два внутренне непересекающихся пути @xmath178 и @xmath179 от общего узла дерева к @xmath177, в которых любые узлы, отличные от @xmath177, являются узлом дерева. если @xmath190 содержит ребро в @xmath49, отличное от @xmath93, то начало ребра является узлом сетки и отображается либо в @xmath178, либо в @xmath179, что является противоречием. следовательно, @xmath191 является поддеревом @xmath128. без потери общности мы можем предположить, что @xmath178 содержит @xmath93. то есть @xmath93 - это последнее ребро @xmath178. Обратите внимание, что @xmath192 - это все узлы в @xmath90, упорядоченные сверху вниз. если @xmath178 содержит более одного ребра в @xmath128, оно должно проходить через @xmath111, противоречие. если @xmath178 равно @xmath93, то @xmath179 должен проходить через @xmath139, противоречие. следовательно, в @xmath49 есть не более одного ребра, голова которого находится в каждом тривиальном пути @xmath90, @xmath145. таким образом, существуют тривиальные пути @xmath75, отличные от @xmath78, и в @xmath49 есть не более одного ребра, входящего в каждый из них. следовательно, @xmath193 в этом разделе мы дадим жесткую оценку количества сеток в почти стабильной сети. класс почти стабильных сетей отличается от класса сетей с видимой сеткой, но, что удивительно, жесткая верхняя граница также равна @xmath2. сеть, показанная на рисунке [fig4]a, является примером почти стабильной сети с сетками @xmath2. нам нужен следующий факт, доказанный gambette et al. (2015). [ ns_1 ] пусть @xmath27 будет почти стабильной сетью с выходами @xmath0. существует набор ребер @xmath49, такой, что (a ) @xmath50 является подсетью, видимой для ретикуляции, на тех же листах, что и @xmath27, и ( b ) @xmath49 содержит ровно одно входящее ребро для каждого узла ретикуляции, который не виден в @xmath27.     с четырьмя листьями. у него девять сеточек (заштрихованных кружочков), пять из которых не видны. края с круглыми точками - это те, которые удалены для получения видимой сетки @xmath42 в ( * b * ). пунктирные пути в @xmath42 - это пересекающиеся и непересекающиеся пути, удаленные для получения поддерева с теми же листьями, что и @xmath27. (* c * ) и (* d * ) - это два случая, рассмотренных в доказательстве части (c) в лемме [ ns_2 ]: непересекающийся путь из @ xmath8 и @ xmath9 содержит узел дерева @xmath194 из @xmath27, и он содержит узел сетки @xmath194 из @xmath27 [ рис. 4],scaledwidth=90,0% ] пусть @xmath49 - набор ребер, удовлетворяющих двум свойствам в предложении [ ns_1 ], и пусть @xmath195 (рисунок [ рис. 4]a). ребра в @xmath49 называются _ ns - edges_. отметим, что @xmath42 является подразделением бинарной сети с видимой сеткой. то есть видимая сеть ретикуляции может быть получена из @xmath42 путем замены некоторых путей, внутренние узлы которых имеют степень 2, направленными ребрами с той же ориентацией. следовательно, @xmath42 содержит узлы степени 2, если @xmath49 не пуст.    для пути @xmath36 мы используем @xmath196 для обозначения набора его внутренних узлов. поскольку @ xmath42 является подразделением бинарной сети видимой сетки с теми же листьями, что и @ xmath27, по теореме [ stable_1 ], существует набор @ xmath197 путей в @ xmath198, такой, что (i ) каждый путь @ xmath199 ведет от узла дерева степени 3 к узлу видимой сетки в @xmath198. @xmath42 и все его внутренние узлы имеют степень-2 в @xmath42, и (ii ) @xmath200 - это поддерево с теми же листьями, что и @xmath27. пусть @xmath201. @xmath128 получается в результате удаления внутренних узлов и ребер путей в @xmath202. мы можем классифицировать пути в @xmath197 как _ пересекающиеся пути _ и _ непересекающиеся пути _ соответственно, как показано в разделе 3 (рисунок [ fig4]b). [ ns_2 ] пусть @xmath27 будет почти стабильной сетью, и пусть @xmath49, @xmath42, @xmath128 и @xmath197 определены выше. \\(a ) каждый внутренний узел в пути в @xmath197 не виден в @xmath27. \\(b ) каждый перекрестный путь в @xmath197 состоит либо из одного ребра, либо из двух ребер в @xmath27. \\(c ) каждый непересекающийся путь в @xmath197 является просто ребром в @xmath27. \\(d ) если @xmath36 - это перекрестный путь в @xmath197 от @xmath89 до @xmath177, а @xmath178 - непересекающийся путь в @xmath197 от @xmath8 до @xmath9, такой, что @xmath89 находится между @xmath8 и @xmath9 (рисунок [fig4]b), то @xmath36 и @xmath178 оба являются одним ребром в @xmath27. \\(e ) каждые два различных пути в @xmath197 не пересекаются узлами. отметим, что @xmath203 обозначает уникальный путь от @xmath177 до @xmath204 для любых двух узлов @xmath177 и @xmath204 в @xmath128. \\(a ) пусть @xmath36 будет путем в @xmath197, а @xmath204 - его внутренним узлом. для любого листа @xmath205 уникальный путь @xmath136 не передает @xmath204 в @xmath128. следовательно, @xmath204 не виден в @xmath27. \\(b ) если в пути в @xmath197 есть два или более внутренних узла, по ( a) они являются последовательными и не видны в @xmath27, что противоречит тому, что @xmath27 почти стабилен. \\(c ) мы используем @xmath73 для обозначения корня @xmath27, который также является корнем @xmath42 и @xmath128. пусть @xmath36 - непересекающийся путь между @xmath8 и @xmath9, где @xmath8 и @xmath9 находятся в некотором пути @xmath90 в @xmath128. Обратите внимание, что @xmath206 является подпутем @xmath90 и внутренне не пересекается с @xmath36. согласно факту ( 2 ) в предложении [ 31 ], существует внутренний узел @xmath89 в @xmath206, который является начальным узлом перекрестного пути @xmath207 в @xmath197. во-первых, любой узел @xmath204 между @xmath8 и @xmath9 в @xmath206 не виден. это связано с тем, что для любого сетевого листа @xmath41, расположенного не ниже @xmath9 в @xmath128, @xmath208 не проходит через @xmath204, а для любого сетевого листа @xmath41, расположенного ниже @xmath9 в @xmath128, @xmath209 - это путь, не проходящий через @xmath204. следовательно, @xmath89 должен быть уникальным внутренним узлом @xmath206. то есть @xmath89 является дочерним элементом @xmath8 и родительским элементом @xmath9 в @xmath206. предположим, что @xmath36 не является ребром в @xmath27. по ( a ), существует уникальный узел степени 2 @xmath194 между @xmath8 и @xmath9 в @xmath36. мы рассмотрим следующие два случая.    если @xmath210 (рисунок [ fig4]c ), то другое исходящее ребро @xmath211 было удалено, чтобы получить @xmath42. то есть, @xmath212. по определению @xmath49, @xmath126 является узлом сетки и не виден в @xmath27. то, что @xmath194 и @xmath126 оба не видны, противоречит тому, что @xmath27 почти стабилен. если @xmath213 (рисунок [ fig4]d ), то другое входящее ребро @xmath214 было удалено, чтобы получить @xmath42. Обратите внимание, что @xmath215 и @xmath216, поскольку @xmath89 имеет степень 3 в @xmath42. кроме того, @xmath127 не является внутренним узлом пути в @xmath197. (в противном случае, по ( a ), @xmath194 и @xmath127 оба не видны ). итак, @xmath127 - это узел в @xmath128. очевидно, что @xmath127 не ниже @xmath9 и, следовательно, не ниже @xmath89 в @xmath128. (в противном случае @xmath27 имеет цикл. ) следовательно, @xmath217 не проходит через @xmath8. рассмотрим сетевой лист @xmath57. если он не ниже @xmath9, то @xmath208 не проходит через @xmath8. если @xmath41 находится ниже @xmath9, то @xmath218 - это путь, не проходящий через @xmath8 в @xmath27. следовательно, @xmath8 не виден. то, что @xmath8 и @xmath89 оба не видны в @xmath27, противоречит тому, что @xmath27 почти стабилен. \\(d ) согласно доказательству (c), @xmath178 является единственным ребром в @xmath27, а @xmath89 является единственным узлом в @xmath36 и не виден. таким образом, @xmath36 должен быть ребром в @xmath27. (в противном случае ( a ) @xmath89 и его дочерний элемент в @xmath36 не видны, что противоречит тому, что @xmath27 почти стабилен. ) \\(e ) это может быть легко выведено из определения перекрестного пути. пусть @xmath219 - перекрестный путь от @xmath89 к @xmath177. тогда @xmath177 - это видимый узел сетки в @xmath27. у него может быть целых два сетчатых родителя, которые не видны. пусть @xmath220, где @xmath221 - это набор всех родительских элементов @xmath177, а @xmath222 - это набор всех узлов сетки, которые не видны в @xmath27. @xmath223 или @xmath224. определите стоимость @xmath225 как : @xmath226, где @xmath224 используется для подсчета @xmath177 и другого дочернего элемента @xmath89, который является видимым узлом сетки, если есть непересекающееся ребро, перепрыгивающее через @xmath89.    как и в разделе [ sec : stable ], мы позволяем @xmath78 обозначать тривиальный путь, первое ребро которого является входящим ребром в @xmath73, и пусть @xmath227 обозначает другие тривиальные пути @xmath75 в @xmath128. мы относим стоимость перекрестного пути к тривиальному пути @xmath90 в @xmath128, в который входит перекрестный путь, и называем его весом @xmath90. вес @xmath90 обозначается @xmath100. если тривиальный путь не содержит ни одного конечного узла из пересекающихся путей в @xmath197, его вес устанавливается равным 0. каждый видимый узел сетки вносит вклад по крайней мере в одну единицу веса. по определению почти стабильных сетей, любой невидимый узел ретикуляции должен иметь видимый узел ретикуляции в качестве дочернего, и согласно доказательству леммы [ ns_2 ] (c), любой узел ретикуляции, который не виден в @xmath27, должен находиться в некотором @xmath228, @xmath177 является дочерним узлом. конечный узел поперечного пути, так что он также вносит свой вклад по крайней мере в одну единицу веса. следовательно, @xmath229. чтобы связать это, мы сначала установим полезную лемму. как и в разделе [ sec : stable ], мы используем @xmath116 для обозначения тривиального пути, входящего в @xmath103 и @xmath134, @xmath113 для обозначения тривиальных путей, выходящих из @xmath103 для узла @xmath103 степени 3 в @xmath128 . сплошные стрелки и кривые представляют ребра и пути в @xmath128, в то время как стрелки с квадратными точками и кривые представляют удаленные ребра и контуры. @xmath230 является дочерним элементом @xmath103 в тривиальном пути @xmath134, выходящем из @xmath103. @xmath231 является дочерним элементом @xmath103 в тривиальном пути @xmath113. путь от @xmath114 к @xmath112 - это перекрестный путь, входящий в @xmath112. ( * a * ) перекрестный путь от @xmath110 к @xmath115 и @xmath232 - это узел между @xmath103 и @xmath115, где @xmath115 находится в @xmath134. ( * b * ) уникальный узел дерева @xmath231 между @xmath103 и @xmath112 также является родительским для @xmath230 в @xmath27 [ рис. 5],scaledwidth=50,0% ] [ ns_33 ] пусть @xmath130 будет тривиальным путем, определенным выше, и пусть @xmath233 будет перекрестным путем от @xmath140 до @xmath234, где @xmath234 находится в @xmath130 и @xmath235. определите @xmath236. \\(a ) древовидный путь @xmath237 состоит либо из одного ребра, либо из двух ребер в @xmath130. если @xmath237 включает два ребра, внутренний узел не виден. \\(b ) если существует узел @xmath238 между @xmath103 и @xmath234 в @xmath130, а @xmath238 является узлом сетки в @xmath27, то никакой перекрестный путь не входит в другой тривиальный путь @xmath239. \\(c ) предположим, что @xmath233 содержит внутренний узел, который является узлом ретикуляции в @xmath27. если существует перекрестный путь @xmath240 от @xmath241 к @xmath242, такой, что @xmath242 находится в @xmath239, то @xmath140 нет в @xmath243. обратите внимание, что @xmath244 для @xmath142. без потери общности мы можем предположить, что @xmath245 и @xmath246, то есть @xmath247 и @xmath248. \\(a ) пусть @xmath232 будет узлом между @xmath103 и @xmath115 в @xmath134 (рисунок [ fig5]a ) и пусть @xmath41 будет листом в @xmath27. если @xmath41 не находится ниже @xmath115 в @xmath128, путь @xmath249 не проходит через @xmath232. пусть @xmath41 будет листом ниже @xmath115 в @xmath128. поскольку @xmath110 нет в @xmath134 в @xmath128, древовидный путь @xmath250 не проходит @xmath232. по лемме [ лемма22 ] существует путь от @xmath73 к @xmath41, который позволяет избежать @xmath232. следовательно, @xmath232 не виден.    поскольку @xmath27 почти стабилен, в @xmath251 есть не более одного узла, поскольку каждый внутренний узел невидим. \\(b ) предположим, наоборот, что существует перекрестный путь @xmath252 от @xmath114 к @xmath112, входящий в @xmath113, где @xmath112 находится в @xmath113. по (a ), @xmath112 является дочерним элементом @xmath103 или существует уникальный узел @xmath231 между @xmath103 и @xmath112 в @xmath113. сначала мы покажем, что @xmath103 не виден в @xmath27. если @xmath112 является дочерним элементом @xmath103 или в @xmath133 есть узел @xmath231, так что @xmath231 является узлом сетки в @xmath27, у @xmath103 есть два дочерних элемента сетки в @xmath27. согласно лемме [ lemma22 ], @xmath103 не виден. если @xmath113 содержит узел @xmath231 между @xmath103 и @xmath112 в @xmath27, @xmath253 не должен быть ребром в @xmath27. в противном случае, как показано на рисунке [fig5]b, @xmath230 и @xmath231 тогда не видны, что противоречит тому, что @xmath27 почти стабилен. пусть @xmath254 будет ребром, удаленным из @xmath230 в процессе преобразования @xmath27 в @xmath42. поскольку @xmath255, либо @xmath256 находится ниже @xmath112, либо существует путь от @xmath73 до @xmath256, который позволяет избежать @xmath103.    поскольку @xmath114 находится в другом тривиальном пути, а между @xmath103 и @xmath230 в @xmath134 нет узла, @xmath89 находится либо ниже @xmath230, либо путь @xmath135 не проходит @xmath103.    поскольку узлы сетки @xmath257 находятся ниже @xmath103 и удовлетворяют условию в лемме [ лемма22 ], существует путь от @xmath73 к @xmath41, который позволяет избежать @xmath103 для любого листа @xmath41 ниже @xmath230 или @xmath112. для любого листа @xmath41, расположенного ни ниже @xmath230, ни ниже @xmath112, он не находится ниже @xmath103, и путь @xmath136 не проходит через @xmath103. следовательно, @xmath103 также не виден.    тот факт, что @xmath103 и @xmath230 оба не видны, противоречит тому, что @xmath27 почти стабилен. это подразумевает, что нет перекрестного пути, входящего в @xmath113. \\(c ) если @xmath112 является дочерним элементом @xmath103 в @xmath113, случай тривиален. предположим, что существует внутренний узел @xmath231 между @xmath103 и @xmath112 в @xmath113. по факту ( a), @xmath231 не виден. если @xmath258, то @xmath110 и его дочерний элемент в @xmath259 оба не видны, что противоречит тому, что @xmath27 является почти стабильной сетью.   , в то время как стрелки с квадратными точками и кривые представляют удаленные ребра и пути. путь от @xmath110 до @xmath115 - это перекрестный путь, заканчивающийся на узле в тривиальном пути, выходящем из @xmath103 [ рис. 6],scaledwidth=90,0% ] [ ns_4 ] для внутреннего узла @xmath103 степени @xmath260 в @xmath128, \\(a ) @xmath261 и @xmath262. \\(b ) если @xmath263, то @xmath264, где @xmath265. \\(c ) если @xmath266 и @xmath119, то @xmath120. более того, предположим, что @xmath267 является предком степени 3 @xmath103, таким образом, что @xmath268. тогда @xmath269. \\(d ) если @xmath270, то @xmath271 и @xmath123. \\(a ) мы только докажем, что @xmath261. если нет непересекающегося ребра, перепрыгивающего через начальный узел перекрестного пути, вводим @xmath134, по уравнению. ( [ weight_def ] ), вес @xmath134 не более 3. если существует непересекающееся ребро, перепрыгивающее через начальный узел @xmath110 перекрестного пути @xmath272, заканчивающегося на узле @xmath115 в @xmath134, согласно факту (d) леммы [ ns_2 ], @xmath272 равно единственному ребру @xmath273. следовательно, @xmath115 имеет не более одного родительского элемента сетки, который находится в @xmath134, если существует. по уравнению. ( [ weight_def ] ), @xmath261. \\(b ) предположим, что @xmath274. тогда существует перекрестный путь @xmath272 от @xmath110 к @xmath115, где @xmath115 находится в @xmath134. если нет непересекающегося ребра, перепрыгивающего через @xmath110, с помощью уравнения. ( [ weight_def ] ), у @xmath115 есть два родительских элемента сетки (рисунок [ fig6]a ).    если существует непересекающееся ребро, перепрыгивающее через @ xmath110, то по факту (d) леммы [ ns_2 ], @xmath272 равно единственному ребру @xmath273 и по уравнению. ( [ weight_def ] ), у @xmath115 есть один родительский элемент сетки @xmath230 в @xmath134 (рисунок [ fig6]b ). согласно факту (b) леммы [ ns_33 ], нет перекрестного пути, который входит в @xmath113, подразумевая @xmath275. \\(c ) предположим, что @xmath266 и @xmath119. пусть @xmath233 - перекрестный путь от @xmath140 до @xmath234, с @xmath234 в @xmath276. поскольку @xmath119, согласно факту (b) леммы [ ns_33 ], между @xmath103 и @xmath234 нет узла сетки для каждого @xmath277. следовательно, для каждого @xmath277 либо родительский элемент @xmath234 в @xmath233 является узлом сетки и не виден (рисунок [ fig6]c ), либо существует непересекающееся ребро @xmath278, перепрыгивающее через @xmath279 (рисунок [ fig6]e).    согласно фактам (a ) и (b) леммы [ ns_33 ], либо @xmath234 является дочерним элементом @xmath103 в @xmath130, либо существует узел дерева @xmath238 между @xmath103 и @xmath234 в @xmath130 для @xmath265. предположим, что существует узел дерева @xmath238 между @xmath103 и @xmath234 в @xmath130, @xmath265. пусть @xmath236. если @xmath240 имеет внутренний узел, который является сеткой, то по факту (c) леммы [ ns_33 ], @xmath280.    если существует непересекающееся ребро, перепрыгивающее через @ xmath241, то из факта (d) леммы [ ns_2 ], что @xmath281 подразумевает, что конечные точки непересекающегося ребра также находятся между @xmath103 и @xmath234, это невозможно, поскольку между @xmath103 и @xmath234 есть только @xmath238. @xmath234. следовательно, @xmath280. аналогично, @xmath282.    мы доказали, что для @xmath283 @xmath140 не находится между @xmath103 и @xmath242. таким образом, @xmath140 находится либо ниже @xmath242, либо существует путь от @xmath73 к @xmath140, который не проходит @xmath103. следовательно, согласно лемме [lemma22 ], существует путь от @xmath73 до @xmath41, не проходящий через @xmath103 для любого листа ниже либо @xmath115, либо @xmath112. для любого листа @xmath41 ниже ни @xmath115, ни @xmath112, поскольку он не находится ниже @xmath103 в @xmath128, @xmath136 не содержит @xmath103. следовательно, @xmath103 не виден. это также подразумевает, что @xmath115 и @xmath112 являются дочерними элементами @xmath103. предположим, что @xmath267 является начальным узлом @xmath116 и @xmath268. далее мы докажем, что @xmath116 состоит только из ребра @xmath284 в @xmath27. предположим, что, наоборот, есть узлы между @xmath267 и @xmath103 в @xmath285. мы рассматриваем родительский @xmath204 ( @xmath286 ) из @xmath103 в тривиальном пути @xmath285. если @xmath204 является узлом сетки, то то, что @xmath103 не виден, подразумевает, что @xmath204 также не виден, противоречие. следовательно, @xmath204 должен быть узлом дерева в @xmath27. мы рассмотрим следующие два случая.    * случай 1*. @xmath204 равен @xmath140 или равен другой родительский элемент внутреннего узла @xmath233 для некоторого @xmath287.    без потери общности мы можем предположить @xmath247 (рисунок [ fig7]a и b). это подразумевает, что нет непересекающегося ребра, перепрыгивающего через перекрестный путь @xmath272, и в @xmath272 есть узел сетки @xmath288. когда @xmath289, пусть @xmath290 будет ребром, удаленным из @xmath288 на первом этапе. поскольку @xmath291 является родительским для @xmath288, если @xmath291 находится ниже @xmath204, он должен быть ниже @xmath112. когда @xmath292, @xmath110 находится ниже @xmath112, если он находится ниже @xmath204. аналогично, @xmath114 находится ниже @xmath115 и, следовательно, ниже @xmath288, если он находится ниже @xmath204. множество узлов сетки @xmath293 и @xmath204 и удовлетворяют условию в лемме [ лемма22 ], поэтому существует путь от @xmath73 к @xmath41, который позволяет избежать @xmath204 для любого листа @xmath41 ниже @xmath288 и @xmath112. если @xmath41 не находится ниже ни @xmath288, ни @xmath112, это не ниже @xmath204, и @xmath136 не проходит через @xmath204. следовательно, @xmath204 не виден.    * случай 2*. @xmath204 не является ни @xmath140, ни другим родительским элементом внутреннего узла @xmath233 для каждого @xmath283 (рисунок [ fig7]c ).    в этом случае для каждого @xmath283 @xmath234 находится либо ниже @xmath242, либо существует путь от @xmath73 до @xmath140, который позволяет избежать @xmath204. применяя лемму [ lemma22 ] к набору сеток @xmath294 и @xmath204, мы приходим к выводу, что существует путь от @xmath73 к @xmath41, который позволяет избежать @xmath204 для любого листа @xmath41 ниже @xmath115 или @xmath112. очевидно, что для любого листа @xmath41, расположенного не ниже @xmath115 или @xmath112, @xmath208 избегает @xmath204. следовательно, @xmath204 должен быть невидим. то, что @xmath204 и @xmath103 являются двумя последовательными узлами и не видны, противоречит тому, что @xmath27 почти стабилен.    после доказательства того, что путь @xmath285 на самом деле является ребром @xmath284, мы теперь докажем, что @xmath269. предположим, что наоборот @xmath295. тогда дочерний элемент @xmath296 из @xmath267 в @xmath297 должен быть узлом сетки (рисунок [ fig7]d ). тогда набор сеток @xmath298 и @xmath267 удовлетворяет условиям леммы [лемма22], поэтому существует путь от @xmath73 до @xmath41, который не проходит через @xmath267 для любого листа @xmath41 ниже @xmath267 в @xmath128. для любого листа @xmath41, расположенного не ниже @xmath267, путь к дереву @xmath136 не проходит через @xmath267. следовательно, @xmath267 не виден. то, что @xmath267 и @xmath103 не видны, противоречит тому, что @xmath27 является почти стабильной сетью. \\(d ) если @xmath270, то @xmath103 является предком любого узла степени 3 в @xmath128. поскольку @xmath27 ациклический, не существует никакого перекрестного пути @xmath299 от @xmath89 к @xmath177, такого, что @xmath300, в то время как @xmath301 для @xmath145. следовательно, @xmath147. если вес @xmath134 и @xmath113 равны 2, и если @xmath279 является начальным узлом перекрестного пути @xmath302, который вводит @xmath106 для @xmath303, либо @xmath110, либо @xmath114 является узлом в @xmath78. следуя доказательству факта (c), мы приходим к выводу, что @xmath103 и его родительский элемент в @xmath78 оба не видны, что является противоречием.   . путь от @xmath279 до @xmath304 - это перекрестный путь, заканчивающийся на @xmath304 в тривиальном пути @xmath106, оставляющий @xmath103 для @xmath108. ( * a * ) @xmath110 - это внутренний узел в @xmath116. ( * b * ) @xmath204 является другим родительским элементом уникального внутреннего узла перекрестного пути от @xmath110 до @xmath115. ( * c * ) ни @xmath110, ни @xmath114 не равны @xmath204 и имеют общего дочернего элемента с @xmath204. ( * d * ) @xmath267 является родительским для @xmath103 и имеет узел сетки @xmath296 в качестве другого дочернего элемента. сплошные стрелки и кривые представляют ребра и пути в @xmath128, стрелки с круглыми точками представляют ребра в @xmath49, которые были удалены для формирования @xmath42, а стрелки с квадратными точками и кривые представляют ребра и пути, которые были удалены для преобразования @xmath42 в @xmath128. [ рис. 7],scaledwidth=90,0% ] пусть @xmath27 будет почти стабильной сетью с выходами @xmath0. затем, @xmath305, пусть @xmath150 обозначает набор внутренних узлов степени 3 в @xmath128, и пусть @xmath306 для любого @xmath307, мы определяем @xmath159 как начальный узел тривиального пути @xmath160, который входит в @xmath9. согласно предложению [ ns_4 ] (c ) и (d ), что @xmath308 подразумевает @xmath309. кроме того, в @xmath163 есть не более двух разных узлов @xmath310 и @xmath311, таких что @xmath312, поскольку есть только два тривиальных пути, покидающих узел дерева степени 3 в @xmath128; для разных @xmath310 и @xmath311, если @xmath313 и @xmath314 находятся в @xmath315, то @xmath316. взятые вместе, эти два факта подразумевают, что @xmath317.    начиная с @xmath147, @xmath318\\\\ & = & |v_1|+2|v_2|+3|v_3|+4|v_4| \\\\ & \\leq & 2|v_0|+2|v_1|+3|v_2|+3|v_3|+3|v_4|\\\\ & \\leq & 3(|v_0|+|v_1|+|v_2|+|v_3|+|v_4|)\\\\ & = & 3(n-1 ). \\end{array}\\ ] ] стабильная дочерняя сеть, показанная на рисунке [ fig8]a, имеет столько же узлов сетки, сколько @xmath3. в этом разделе мы докажем, что стабильная дочерняя сеть может иметь не более 3 узлов ретикуляции @xmath3. сначала мы преобразуем стабильную дочернюю сеть в сеть с видимой сеткой, а затем в бинарное дерево с одинаковыми листьями, удаляя некоторые ребра в узлы сетки. если он не виден : ( * b * ) @xmath45 и его дочерний элемент @xmath319 имеют общего родителя. ( * c * ) @xmath45 имеет родителя @xmath320 и родственника @xmath55 под @xmath320, так что @xmath55 и @xmath320 имеют общего родителя @xmath89. ( * d * ) ни ( * b * ), ни ( * c * ) не являются истинными. ( * e * ) и ( * b * ), и ( * c * ) происходят одновременно [ рис. 8], scaledwidth=60,0% ] [ sc_1 ] пусть @xmath27 будет стабильной дочерней сетью. существует набор ребер @xmath49, такой, что ( 1 ) @xmath50 является подразделением сети, видимой при ретикуляции, на тех же листьях, что и @xmath27, и ( 2 ) @xmath49 содержит точно входящее ребро для узла ретикуляции, если оно не видно в @xmath27.    для узла ретикуляции @xmath45, который не виден в @xmath27, его уникальным дочерним узлом должен быть видимый узел ретикуляции. кроме того, поскольку у каждого узла есть видимый дочерний элемент, оба его родителя имеют видимый дочерний элемент, отличный от @xmath45, и оба являются узлом дерева. чтобы преобразовать @xmath27 в сеть с видимой сеткой, мы удалим одно или два ребра вокруг сетки, если она не видна. для каждого узла сетки @xmath45, который не виден, мы рассмотрим следующие три случая. если @xmath45 и его уникальный дочерний элемент @xmath319 имеют общего родителя @xmath320 (рисунок [ fig8]b ), то @xmath321 удаляется.    если у @xmath45 и его дочернего элемента @xmath319 нет общего родителя, но у @xmath45 есть сетчатый родственник @xmath55, такой, что родительский элемент @xmath89 общего родительского элемента @xmath320 из @xmath45 и @xmath55 является другим родительским элементом @xmath55 (рисунок [ fig8]c ), @xmath322 и @xmath55 являются дочерними элементами @xmath55. @xmath323 затем удаляются одновременно.    когда не происходит ни того, ни другого (рисунок [ fig8]d ), мы произвольно выбираем входящее ребро из @xmath45 для удаления. ребра, удаленные в описанном выше процессе, называются _ sc - edges_. каждое sc - ребро ведет от узла дерева к узлу сетки. sc - ребро _ скрыто _, если головка является видимым узлом сетки; в противном случае оно _ открыто _. обратите внимание, что скрытое sc - ребро удаляется только в том случае, если выполняется условие, показанное на рисунке [fig8]c. следовательно, скрытый sc - край перепрыгивает через связанный с ним открытый sc - край, который удаляется одновременно. нетрудно видеть, что sc - края, которые удаляются при рассмотрении разных узлов сетки, различны. пусть @xmath49 - набор sc - ребер. во-первых, мы удалили только входящее ребро для каждого узла сетки и не удаляли входящее ребро для каждого узла дерева, поэтому результирующая сеть @xmath50 подключена. во-вторых, @xmath50 имеет те же листья, что и @xmath27. причины этого заключаются в том, что (i ) мы не удаляем ни одно исходящее ребро узла сетки, и (ii ) для любого узла дерева @xmath103, если его исходящее ребро удалено, другое исходящее ребро входит в другой узел дерева и, таким образом, никогда не удалялось. теперь мы покажем, что @xmath50 является подразделением бинарной сети с видимой сеткой. поскольку мы удалили входящее ребро для узла сетки, если оно не видно, все остальные узлы сетки видны. @xmath50 видна сетка. мы также можем показать, что нет двух внутренне непересекающихся путей от общего узла дерева к общему узлу сетки, в котором каждый внутренний узел имеет степень 2, подразумевая, что @xmath50 является подразделением бинарной видимой сети сетки. предположим, напротив, что между @xmath8 и @xmath9 есть два внутренне непересекающихся пути @xmath259 и @xmath324, так что все их внутренние узлы имеют степень 2. если ни @xmath259, ни @xmath324 не являются одним ребром, то два дочерних элемента @xmath8 в @xmath259 и @xmath324 оба не являются ребрами. видимый, противоречащий тому, что @xmath27 является стабильной дочерней сетью. следовательно, либо @xmath259, либо @xmath324 являются одним ребром из @xmath8 и @xmath9.    без потери общности мы можем предположить, что @xmath324 равно ребру @xmath175. согласно трем правилам, которые мы использовали для удаления ребер в @xmath49, если входящее ребро узла удалено, его дочерний элемент в @xmath50 виден в @xmath27. это означает, что @xmath50 не содержит путь, состоящий из двух или более узлов степени 2, которые не видны в @xmath27. следовательно, @xmath259 имеет ровно один внутренний узел @xmath177. если @xmath177 является узлом дерева в @xmath27, то мы удалили исходящее ребро @xmath177 в соответствии либо со вторым, либо с третьим случаем. в первом случае мы одновременно удаляем @xmath325. в последнем случае @xmath47 не существует в @xmath27. это невозможно. когда @xmath177 является узлом сетки, мы удалили входящее в него ребро. опять же, ребро @xmath47 не существует в @xmath27 в каждом возможном случае, противоречие. мы доказали, что @xmath50 является подразделением бинарной сети. пусть @xmath326 - подсеть, полученная после удаления ребер в @xmath49. @xmath42 - подразделение бинарной сети.на поверхности видна сетчатая сетка. согласно теореме [ stable_1 ], существует набор путей @xmath197 такой, что (i) @ xmath327 является поддеревом @ xmath27 с одинаковыми листьями и ( ii ) все внутренние узлы в каждом пути в @xmath197 имеют степень 2. опять же, мы используем @xmath328 для обозначения тривиального пути в @xmath128, где @xmath78 обозначает тривиальный путь, начинающийся с @xmath28. как и в предыдущем разделе, путь в @xmath197 называется непересекающимся путем, если его начальный и конечный узлы находятся в @xmath188 для некоторого @xmath277; в противном случае он называется перекрестным путем. [ sc_2 ] пусть @xmath36 будет путем в @xmath197. \\(a ) каждый внутренний узел в @xmath36 не виден в @xmath27. \\(b ) если @xmath36 - это непересекающийся путь, то это просто ребро. \\(c ) если @xmath36 является перекрестным путем и заканчивается на узле @xmath177 в тривиальном пути @xmath188, каждый узел между начальным узлом @xmath188 и @xmath177 в @xmath128 не виден в @xmath27. \\(d ) если @xmath36 является перекрестным путем и существует непересекающийся путь @xmath178, пересекающий его, то либо @xmath36 является ребром, либо начальный узел @xmath36 является родительским для конечного узла @xmath178 в @xmath128. \\(a ) и ( b ) по сути являются повторением факта (a ) и (c ) в лемме [ ns_2 ]. \\(c ) пусть @xmath204 будет узлом между начальным узлом @xmath188 и @xmath177 в @xmath128. для любого листа @xmath41, который не находится ниже @xmath177 в @xmath128, @xmath249 - это путь, который не проходит @xmath177 и, следовательно, @xmath204. для любого листа @xmath41 ниже @xmath177 в @xmath128 путь @xmath329 избегает @xmath204, поскольку @xmath89 является начальным узлом @xmath36 в тривиальном пути, отличном от @xmath188. следовательно, @xmath204 не виден в @xmath27. \\(d ) по ( b ), @xmath178 - это просто ребро @xmath47 в @xmath42. пусть @xmath36 начинается с узла @xmath89. если ни @xmath330, ни @xmath36 не являются единым ребром, два дочерних элемента @xmath89 в @xmath36 и @xmath331 оба не видны, что противоречит тому, что @xmath27 является стабильным дочерним элементом. пусть @xmath45 является узлом сетки и не виден в @xmath27. затем выявленный sc - edge @xmath332 был удален из @xmath45, чтобы получить @xmath42 из @xmath27. мы определяем стоимость @xmath333 для @xmath45 как : @xmath334 напомним, что @xmath335. мы можем определить стоимость перекрестного пути @xmath219 от @xmath89 до @xmath177 следующим образом: @xmath336 далее мы относим стоимость @xmath225 к тривиальному пути @xmath90, к которому принадлежит @xmath177, и называем это весом @xmath90, записанным @xmath100. если нет перекрестного пути, вводящего @xmath90, вес @xmath90 устанавливается равным 0.    что касается почти стабильных сетей, у нас есть @xmath337 для внутреннего узла @xmath103 со степенью-3 в @xmath128, мы по-прежнему используем @xmath134 и @xmath338 для обозначения тривиальных путей, выходящих из @xmath103 и @xmath116 для обозначения тривиального пути, входящего в @xmath103.    [ sc_3 ] для каждого внутреннего узла @xmath103 степени 3 в @xmath128, \\(a ) @xmath339, @xmath142. \\(b ) @xmath340. \\(c ) если @xmath266 и @xmath341, то @xmath271. более того, предположим, что @xmath267 является начальным узлом @xmath116 и @xmath268. тогда @xmath342. \\(d ) если @xmath270, то @xmath271 и @xmath343. \\(a ) мы докажем только, что @xmath344. пусть @xmath272 обозначает пересылку по перекрестному пути в узле @xmath115 в @xmath134. пусть @xmath110 будет начальным узлом @xmath272 в тривиальном пути, отличном от @xmath134. обратите внимание, что @xmath345.    если нет непересекающегося ребра, перепрыгивающего через @xmath110, то в @xmath346 не более 2 элементов, и каждый элемент может иметь не более двух удельных затрат. таким образом, по уравнению. ( [ scformula ] ), @xmath347. если есть непересекающееся ребро, @xmath183 перепрыгивает через @xmath110. согласно факту ( b) в лемме [ sc_2 ], @xmath348 является пустым или одноэлементным. более того, согласно факту (d ) в лемме [ sc_2 ] ( d ), либо @xmath272 является ребром, либо @xmath349 является ребром в @xmath128. если @xmath272 является ребром, то @xmath350. если @xmath349 является ребром, то @xmath351. оба подразумевают, что @xmath352. следовательно, по уравнению. ( [ scformula ] ), @xmath353. мы отмечаем, что если родительский элемент @xmath115 в @xmath128 не является узлом ретикуляции в @xmath27, то @xmath354 и, следовательно, @xmath355. равенство выполняется только в том случае, если существует непересекающееся ребро, перепрыгивающее через @xmath177. \\(b ) если @xmath356 и @xmath357, мы предполагаем, что перекрестный путь @xmath302, заканчивающийся на узле @xmath115 в @xmath106, начинается на @xmath279 для @xmath108. согласно факту (c) леммы [ sc_2 ], каждый внутренний узел в @xmath358 и @xmath359 не виден. если есть узел между @xmath103 и @xmath304 для каждого @xmath360, то два дочерних элемента @xmath103 не видны в @xmath27, что противоречит тому, что @xmath27 является стабильным дочерним элементом. таким образом, @xmath103 является родителем либо @xmath115, либо @xmath112. без потери общности мы можем предположить, что @xmath103 является родителем @xmath115 в @xmath128. по замечанию в конце доказательства (a), @xmath355 и, следовательно, @xmath361. \\(c ) предположим, что @xmath266 и @xmath267 являются начальными узлами @xmath116, такими что @xmath268. если @xmath341, по ( a ), веса @xmath134 и @xmath113 оба не равны нулю. следовательно, существует перекрестный путь @xmath302, заканчивающийся на узле @xmath304 в @xmath106 и начинающийся на узле @xmath279 в тривиальном пути, отличном от @xmath106 для каждого @xmath362. сначала мы покажем, что @xmath279 либо (i ) ниже @xmath363, либо (ii ) ни в @xmath116, ни ниже @xmath103 для @xmath364 и @xmath224. без потери общности мы предполагаем, что @xmath364. * случай 1*. @xmath110 находится в @xmath359 (рисунок [ fig9]a ). если есть непересекающееся ребро @xmath183, перепрыгивающее через @xmath110, @xmath111 находится либо в @xmath365, либо @xmath111 находится ниже @xmath112 в @xmath113. первое подразумевает, что @xmath111 не виден, тогда как второе подразумевает, что @xmath112 не виден. это противоречит тому, что и @xmath111, и @xmath112 видны в @xmath42. поскольку @xmath110 является внутренним узлом между @xmath103 и @xmath112 в @xmath128, то @xmath103 является родительским для @xmath115 в @xmath128. по факту (a ) и (c) леммы [ sc_2 ], каждый внутренний узел в @xmath272 или @xmath365 не виден. таким образом, @xmath366 или @xmath367 являются ребром. в противном случае два дочерних элемента @xmath110 не видны, что противоречит тому, что @xmath27 является стабильной дочерней сетью.    если @xmath366 является ребром в @xmath27, то @xmath368 и, следовательно, @xmath343 - противоречие. если @xmath367 является ребром, то @xmath369. поскольку @xmath110 не является сеткой, согласно замечанию в конце доказательства (a), @xmath370. следовательно, @xmath343. это невозможно.    * случай 2*. @xmath110 - это узел в пути @xmath116.    без потери общности мы можем предположить, что @xmath110 ниже, чем @xmath114, если @xmath114 также находится в @xmath116. мы утверждаем, что @xmath103 и все внутренние узлы в @xmath371 не видны. пусть @xmath8 будет либо @xmath103, либо внутренним узлом в @xmath371. если @xmath114 находится в @xmath372, случай симметричен случаю 1. таким образом, следует учитывать два случая: либо @xmath114 находится ниже @xmath115 (рисунок [ fig9]b), либо @xmath114 не ниже @xmath110 (рисунок [ fig9]c ). в обоих случаях набор узлов сетки @xmath373 находится ниже узла @xmath8 и удовлетворяет условию в лемме [лемма22 ], поэтому @xmath8 не виден относительно каждого листа @xmath41 ниже либо @xmath115, либо @xmath112. для любого лист @xmath41 не ниже @xmath115 или @xmath112, путь @xmath208 избегает @xmath8. следовательно, @xmath8 не виден в @xmath27. из этого результата вытекают некоторые наблюдения. во-первых, нет непересекающегося ребра @xmath183, перепрыгивающего через @xmath110, в противном случае @xmath111 не виден. во-вторых, дочерний элемент @xmath110 в @xmath116 не виден, и поэтому перекрестный путь @xmath272 - это просто ребро. в противном случае, согласно факту (a) леммы [ sc_2 ], два дочерних элемента @xmath110 оба не видны в @xmath27.    согласно (b) леммы [ sc_2 ], либо @xmath374, либо @xmath375 является ребром в @xmath128. если @xmath103 является родительским для @xmath115 в @xmath128, то @xmath376 в соответствии с уравнением. ( [ scformula ] ). по ( a ), @xmath343. если @xmath103 является родительским для @xmath112, @xmath369 и @xmath370 в соответствии с замечанием в конце доказательства (a). взятые вместе, оба факта подразумевают, что @xmath343, что противоречит предположению, что @xmath341. * случай 3*. @xmath110 находится ниже @xmath112, а @xmath114 находится ниже @xmath115 (рисунок [ fig9]d ). этот случай невозможен, поскольку в @xmath27 есть цикл, противоречащий @xmath27, является ациклическим.    подводя итог, @xmath341 подразумевает, что либо (i ), либо ( ii ) истинно. но в обоих случаях, если мы позволим @xmath8 быть либо @xmath103, либо любым внутренним узлом в @xmath116, набор сеток @xmath294 находится ниже @xmath8 и удовлетворяет условию в лемме [ лемма22 ]. следовательно, @xmath103 и любой внутренний узел в @xmath116 не видны. из этого результата вытекают два наблюдения. во-первых, @xmath271, потому что нет перекрестного пути, который заканчивается на @xmath116. (в противном случае перекрестный путь входит в @xmath116 в сетке, которая не видна в @xmath27. ) во-вторых, дочерний элемент @xmath267 в @xmath268 не виден.    очевидно, что @xmath377, если нет перекрестного пути, который заканчивается на @xmath297. предположим, что существует перекрестный путь @xmath378 от @xmath379 до @xmath380 с @xmath380 в @xmath297. по (c) леммы [ sc_2 ], каждый внутренний узел в @xmath381 не виден. но дочерний элемент @xmath267 в @xmath285 не виден. следовательно, @xmath382 является ребром в @xmath128. тогда, согласно замечанию в конце доказательства (a), @xmath342. ( d ) если @xmath270, то @xmath103 является предком любого узла степени 3 в @xmath128. поскольку @xmath27 ациклический, не существует не существует никакого перекрестного пути @xmath383, такого, что @xmath384 для @xmath145 и @xmath385. следовательно, @xmath147.    если @xmath341, то каждый узел в @xmath78 не виден в @xmath27, как показано в ( c ). это противоречит тому, что @xmath78 содержит сетевой корень @xmath28, а @xmath28 виден относительно каждого листа в @xmath27. . ( * a * ) @xmath110 находится между @xmath103 и @xmath112. ( * b * ) @xmath110 - это тривиальный путь @xmath116, входящий в @xmath103, и @xmath114 находится ниже @xmath115. ( * c * ) @xmath110 находится в @xmath116, и @xmath114 находится не ниже @xmath115. ( * d * ) @xmath110 находится ниже @xmath114, и @xmath114 также находится ниже @xmath115. это невозможно в сети [рис. 9],scaledwidth=80,0% ] пусть @xmath27 будет стабильной дочерней сетью с листьями @xmath0. затем @xmath386 пусть @xmath150 обозначает множество внутренних узлов @xmath151 степени 3 в @xmath128. определите @xmath387 предложением [ sc_3 ] ( b ), @xmath388. следовательно, @xmath389 и, следовательно, @xmath390. пусть @xmath159 является начальным узлом тривиального пути, входящего в @xmath9 в @xmath128. по предложению [ sc_3 ] (c ) и ( d ), если @xmath391, то @xmath392 для каждого @xmath393. согласно предложению [ sc_3 ] ( c ), в соответствии с отображением @xmath162, не более двух узлов в @xmath394 сопоставляются с одним и тем же узлом в @xmath164, и только один узел может быть сопоставлен с @xmath395. таким образом, @xmath396 начиная с @xmath147, приведенное выше неравенство подразумевает, что @xmath397\\\\ & = & \\sum_{i=0}^{10 } i |v_i| \\\\ & \\leq & |v_1|+2|v_2|+3|v_3|+4|v_4| + 7 \\sum_{i=5}^{10 } |v_i| + |v_8| + 2|v_9| + 3|v_{10}| ) \\\\ & \\leq & |v_1|+2|v_2|+3|v_3|+4|v_4| + 7 \\sum_{i=5}^{10 } |v_i| + 6 |v_0| + 3\\sum_{i=1}^4 |v_i| \\\\ & = & 6|v_0|+4|v_1|+5|v_2|+6|v_3|+7|v_4| + 7 \\sum_{i=5}^{10 } |v_i| \\\\ & \\leq & 7\\sum_{i=0}^{10 } |v_i|\\\\ & = & 7(n-1 ). \\end{выровнено}\\ ] ] мы установили жесткие верхние границы для размеров поврежденных, почти стабильных и стабильно дочерних сетей. поскольку число внутренних узлов дерева равно числу листьев плюс число узлов сетки в бинарной сети, мы можем обобщить наши результаты в таблице [табл.1 ]. без сомнения, эти жесткие границы дают представление об изучении комбинаторных и алгоритмических аспектов сетевых классов, определяемых свойством видимости..жесткие верхние границы размеров бинарных сетей с @xmath0 остаются определенными свойством visibility. граница видимой сети ретикуляции найдена в работе Бордевича и Сэмпла (2015). 

филогенетические сети - это математические структуры для моделирования и визуализации процессов ретикуляции при изучении эволюции. поврежденные сети, сети с видимой сеткой, почти стабильные сети и сети стабильных дочерних элементов - это четыре класса филогенетических сетей, которые недавно были введены для изучения топологических и алгоритмических аспектов филогенетических сетей. мы доказываем следующие результаты.    * бинарная поврежденная сеть с листьями @xmath0 имеет не более узлов сетки @xmath1. * бинарная почти стабильная сеть с листьями @xmath0 имеет не более узлов сетки @xmath2. * бинарная стабильная дочерняя сеть с листьями @xmath0 имеет не более узлов ретикуляции @xmath3.