скоординированные сети мобильных роботов уже используются для мониторинга окружающей среды и складской логистики. в ближайшем будущем автономные роботизированные команды произведут революцию в перевозках пассажиров и товаров, поисково-спасательных операциях и других приложениях. у этих задач есть общая черта: роботам предлагается предоставлять услуги в пространстве. возникает один вопрос: когда группа роботов ожидает поступления запроса на выполнение задачи, как они могут наилучшим образом позиционировать себя, чтобы быть готовыми ответить? задача разделения распределенной среды для роботизированных сетей состоит в разработке индивидуальных законов управления и коммуникации таким образом, чтобы команда разделяла большое пространство на регионы. как правило, разделение выполняется таким образом, чтобы оптимизировать функцию затрат, которая измеряет качество обслуживания, предоставляемого во всех регионах. _ контроль покрытия _ дополнительно оптимизирует позиционирование роботов внутри области, как показано на рис.  [рис. : cover_example ]. в этой статье описывается алгоритм распределенного разделения и контроля покрытия для сети роботов, позволяющий минимизировать ожидаемое расстояние между ближайшим роботом и пространственно распределенными событиями, которые будут появляться в дискретных точках в невыпуклой среде. оптимальность определяется со ссылкой на соответствующую функцию затрат `мультицентра\". как и во всех приложениях для координации работы с несколькими роботами, проблема заключается в снижении требований к коммуникации: предлагаемый алгоритм требует только связи на короткие расстояния, т.е. асинхронной и ненадежной связи между находящимися поблизости роботами. разделение территории и контроль покрытия находят применение во многих областях. в киберфизических системах приложения включают автоматизированный мониторинг окружающей среды @xcite, выборку и доставку @xcite, строительство @xcite и другие сценарии маршрутизации транспортных средств @xcite. в более общем плане, охват дискретных наборов также тесно связан с литературой по кластеризации данных и @xmath0-означает @xcite, а также с местоположением объекта или @xmath0-проблемой центра @xcite. разбиение графиков на части - это отдельная область исследований, обзор смотрите на @xcite. разбиение территории посредством локальных взаимодействий также изучается для групп животных, см., например, @xcite. широкое обсуждение алгоритмов секционирования и контроля покрытия в роботизированных сетях представлено в @xcite, который основан на классической работе Ллойда @xcite об оптимальном выборе квантователя посредством центрирования и секционирования. \" подход lloyd был впервые адаптирован для управления распределенным покрытием в @xcite. с самого начала аналогичные алгоритмы применялись к невыпуклым средам @xcite, неизвестным функциям плотности @xcite, справедливому разбиению @xcite и построению объектов, похожих на фермы @xcite. существуют также многоагентные алгоритмы разделения, построенные на рыночных принципах или аукционах, обзор смотрите на @xcite. хотя алгоритмы итеративной оптимизации lloyd популярны и хорошо работают при моделировании, они требуют синхронной и надежной связи между соседними роботами. поскольку роботы со смежными областями могут находиться сколь угодно далеко друг от друга, эти требования к связи являются обременительными и нереалистичными для развернутых роботизированных сетей. в ответ на этот вопрос в @xcite авторы показали, как группа роботизированных агентов может оптимизировать разбиение выпуклого ограниченного множества, используя алгоритм Ллойда с передачей сплетен. алгоритм Ллойда с gossip communication также был применен для оптимизации разбиений невыпуклых сред в @ xcite, ключевая идея которого заключается в преобразовании задачи покрытия в евклидовом пространстве в задачу покрытия на графе с геодезическими расстояниями. распределенные методы Ллойда построены на отдельных этапах разбиения и центрирования, и они привлекательны тем, что существуют известные способы охарактеризовать их равновесные множества (так называемые центроидные разбиения Вороного) и доказать сходимость. к сожалению, даже для очень простых сред (как непрерывных, так и дискретных) набор центроидных разбиений Вороного может содержать несколько неоптимальных конфигураций. таким образом, мы заинтересованы в изучении (дискретных) алгоритмов освещения сплетен по двум причинам: (1) они применимы к более реалистичным моделям сетей роботов с очень ограниченной связью в больших невыпуклых средах, и (2) они более гибкие, чем типичные алгоритмы Ллойда, что означает, что они могут избежать плохих неоптимальных конфигураций и повысить производительность. в этой статье представлены три основных вклада. во-первых, мы представляем алгоритм дискретного разделения и оптимизации покрытия для мобильных роботов с ненадежной, асинхронной связью и малой дальностью действия. наш алгоритм состоит из двух компонентов: _ протокола движения _, который заставляет роботов встречаться со своими соседями, и _ правила попарного разбиения _ для обновления территорий при встрече двух роботов. правило разбиения оптимизирует покрытие набора точек, соединенных ребрами, для формирования графика. гибкость графиков позволяет алгоритму работать в невыпуклых, не полигональных средах с отверстиями. наш подход к оптимизации разбиения графа также может быть применен к неплоским задачам, существующим транспортным или логистическим сетям или более общим наборам данных. во-вторых, мы проводим анализ как свойств сходимости, так и вычислительных требований алгоритма. изучая динамическую систему разбиений вершин графа, мы доказываем, что почти наверняка алгоритм сходится к попарно- оптимальному разбиению за конечное время. показано, что множество попарно- оптимальных разбиений является правильным подмножеством хорошо изученного множества центроидных разбиений Вороного. далее мы опишем, как наше правило попарного разбиения может быть реализовано для запуска в любое время и как вычислительные требования алгоритма могут быть увеличены для больших доменов и больших команд. в-третьих, мы подробно описываем экспериментальные результаты нашей реализации алгоритма в системе управления роботом player/stage. мы представляем симуляцию с участием 30 роботов, обеспечивающих покрытие части кампуса колледжа, чтобы продемонстрировать, что наш алгоритм может работать с большими командами роботов, и эксперимент с аппаратным обеспечением в цикле, проведенный в нашей лаборатории, который учитывает шум датчиков и неопределенность положения робота. с помощью численного анализа мы также показываем, как наш новый подход к разбиению на разделы обеспечивает значительное улучшение производительности по сравнению как с обычными методами типа lloyd, так и с недавними результатами в @ xcite. настоящая работа отличается от метода gossip lloyd @xcite в трех аспектах. во-первых, в то время как @ xcite фокусируется на разбиении территории в выпуклой непрерывной области, здесь мы оперируем графом, который позволяет нашему подходу учитывать геодезические расстояния, работать в невыпуклых средах и поддерживать связанные территории. во-вторых, вместо попарного обновления, подобного обновлению Ллойда, мы используем итеративный оптимальный подход с двумя разделами, который дает лучшие конечные решения. в-третьих, мы также представляем протокол motion для создания спорадических попарных сообщений, необходимых для нашего алгоритма gossip, и характеризуем вычислительную сложность нашего предложения. предварительные версии этой статьи появились в @xcite и @xcite. по сравнению с этим, новый контент здесь включает в себя: (1) протокол движения; (2 ) упрощенное и улучшенное правило попарного разбиения; (3 ) доказательства результатов сходимости; и (4) описание нашей реализации и эксперимента с аппаратным обеспечением в цикле. в разделе [ sec : предварительная информация ] мы рассматриваем и адаптируем покрытие и геометрические концепции (например, центроиды, разбиения Вороного) к дискретной среде, такой как график. мы формально описываем нашу модель сети роботов и проблему дискретного разбиения в разделе [sec: алгоритм], а затем излагаем наш алгоритм покрытия и его свойства. раздел [ sec : конвергенция ] содержит доказательства основных результатов конвергенции. в разделе [sec: результаты ] мы подробно описываем нашу реализацию алгоритма и представляем эксперименты и сравнительный анализ. некоторые выводы приведены в разделе [ sec : заключение].    в нашей записи @xmath1 обозначает множество неотрицательных действительных чисел, а @xmath2 - множество неотрицательных целых чисел. учитывая множество @xmath3, @xmath4 обозначает количество элементов в @xmath3. учитывая множества @xmath5, их разность равна @xmath6. многозначное отображение, обозначаемое @xmath7, связывает с элементом @xmath3 подмножество @xmath8. нам дана команда роботов @xmath9, которым поручено обеспечить покрытие конечного набора точек в невыпуклой и неполигональной среде. в этом разделе мы переводим концепции, используемые при покрытии непрерывных сред, в графики. пусть @xmath10 - конечный набор точек в непрерывной среде. эти точки представляют интересующие местоположения и предполагается, что они соединены взвешенными ребрами. пусть @xmath11 - (неориентированный) взвешенный граф с набором ребер @xmath12 и отображением веса @xmath13; пусть @xmath14 - вес ребра @xmath15. мы предполагаем, что @xmath16 подключен, и думаем о весах ребер как о расстояниях между местоположениями. [ rem : дискретизация ] для примеров в этой статье мы будем использовать грубую карту сетки занятости в качестве представления непрерывной среды. в сетке занятости @xcite каждая ячейка сетки является либо свободным пространством, либо препятствием (занято). для формирования взвешенного графа каждая свободная ячейка становится вершиной, а свободные ячейки соединяются ребрами, если они граничат друг с другом в сетке. веса ребер - это расстояния между центрами ячеек, т.е. разрешение сетки. существует множество других методов дискретизации пространства, включая триангуляризацию и другие подходы из computational geometry @xcite, которые также могут быть использованы.    в любом взвешенном графе @xmath16 существует стандартное понятие расстояния между вершинами, определяемое следующим образом. _ path _ в @xmath17 - это упорядоченная последовательность вершин, такая, что любая последовательная пара вершин является ребром @xmath17. _ вес пути _ - это сумма весов ребер в пути. заданная вершинаces @xmath18 и @xmath0 в @xmath17 _ расстояние _ между @xmath18 и @xmath0, обозначаемое @xmath19, является весом пути с наименьшим весом между ними, или @xmath20, если пути нет. если @xmath17 подключен, то расстояние между любыми двумя вершинами в @xmath17 конечно. по соглашению, @xmath21, если @xmath22. обратите внимание, что @xmath23, для любого @xmath24. мы будем разбивать @xmath10 на связанные подмножества или области @xmath9, каждая из которых будет покрыта отдельным роботом. для этого нам нужно определить расстояния на индуцированных подграфах @xmath16. учитывая @xmath25, подграф _, вызванный ограничением @xmath17 на @xmath26 _, обозначаемый @xmath27, является графом с набором вершин, равным @xmath26, и набором ребер, содержащим все взвешенные ребра @xmath17, где обе вершины принадлежат @xmath26. другими словами, мы устанавливаем @xmath28. индуцированный подграф представляет собой взвешенный граф с понятием расстояния между вершинами: учитывая @xmath29, мы пишем @xmath30 обратите внимание, что @xmath31 мы определяем _ связное подмножество @xmath10 _ как подмножество @xmath32, такое, что @xmath33 и @xmath34 связаны. затем мы можем разбить @xmath10 на связанные подмножества следующим образом. [ def : conpartitions ] учитывая график @xmath35, мы определяем _ связную @xmath36 часть @xmath10 _ как коллекцию @xmath37 из @xmath9 подмножеств @xmath10, такую, что 1. @xmath38 ; 2. @xmath39, если @xmath40 ; 3. @xmath41 для всех @xmath42 ; и 4. @xmath43 подключен для всех @xmath42. пусть @xmath44 будет набором подключенных @xmath36частей из @xmath10.    свойство ( ii ) подразумевает, что каждый элемент @xmath10 принадлежит только одному @xmath43, т.е. каждое местоположение в среде контролируется только одним роботом. обратите внимание, что каждый @xmath45 индуцирует связанный подграф в @xmath16. в последующих ссылках на @xmath43 мы часто будем иметь в виду @xmath46, и на самом деле мы ссылаемся на @xmath47 как на _ доминирующий подграф _ или _ область _ робота @xmath48-го во время @xmath49.    среди способов разбиения на разделы @xmath10 есть некоторые, которые заслуживают особого внимания. учитывая вектор различных точек @xmath50, раздел @xmath51 называется разделом Вороного q, сгенерированным c _ если для каждого @xmath43 и всех @xmath52 у нас есть @xmath53 и @xmath54, @xmath55. обратите внимание, что разбиение Вороного, сгенерированное @xmath56, не уникально, поскольку способ распределения связанных вершин не определен.      для наших алгоритмов gossip нам нужно ввести понятие смежных подграфов. два различных связанных подграфа @xmath43, @xmath57 называются _ смежными _, если есть две вершины @xmath58, @xmath59, принадлежащие, соответственно, @xmath43 и @xmath57 таким образом, что @xmath60. обратите внимание, что если @xmath43 и @xmath57 смежны, то @xmath61 подключен. аналогично, мы говорим, что роботы @xmath48 и @xmath62 смежны или являются соседями, если их подграфы @xmath43 и @xmath57 смежны. соответственно, мы вводим следующее полезное понятие.    для @xmath63 мы определяем _ граф смежности _ между областями раздела @xmath64 как @xmath65, где @xmath66, если @xmath43 и @xmath57 смежны. обратите внимание, что @xmath67 всегда подключен, поскольку подключен @xmath16. мы определяем три функции стоимости покрытия для графиков: @xmath68, @xmath69 и @xmath70. пусть функция _ weight _ @xmath71 присвоит относительный вес каждому элементу @xmath10. функция _ one - center _ @xmath68 дает стоимость для робота, чтобы покрыть подключенное подмножество @xmath32 из вершины @xmath72 с относительным приоритетом, установленным @xmath73 : @xmath74 для решения проблемы минимизации @xmath75 необходимо техническое допущение: с этого момента мы предполагаем, что _ всего отношение order _, @xmath76, определено в @xmath10, т.е. в @xmath77. с этим предположением мы можем детерминистически выбрать вершину в @xmath3, которая минимизирует @xmath68 следующим образом. [ def : centroid ] пусть @xmath10 - полностью упорядоченное множество, и пусть @xmath32. мы определяем множество обобщенных центроидов @xmath3 как множество вершин в @xmath3, которые минимизируют @xmath68, т.е. @xmath78 далее, мы определяем отображение @xmath79 как @xmath80. мы называем @xmath81 _ обобщенным центроидом _ из @xmath3.    при последующем использовании мы опускаем слово \"обобщенный\" для краткости. обратите внимание, что при таком определении центр тяжести четко определен, а также что центр тяжести региона всегда принадлежит этому региону. с небольшим нарушением нотации мы определяем @xmath82 как карту, которая связывает с разделом вектор центроидов его элементов. мы определяем _ многоцентровую функцию _ @xmath69 для измерения затрат роботов @xmath9 на покрытие подключенного @xmath9-раздела @xmath64 из набора вершин @xmath83 : @xmath84 мы стремимся минимизировать функцию производительности @xmath69 как для вершин @xmath56, так и для раздела @xmath64. теперь мы можем сформулировать функцию стоимости покрытия, которой мы будем заниматься в остальной части этой статьи. пусть @xmath85 определяется @xmath86 в рассматриваемом нами мотивационном сценарии каждого робота периодически будут просить выполнить задачу где-нибудь в его регионе, причем задачи будут появляться в соответствии с распределением @xmath73. в режиме ожидания роботы будут располагаться в центре тяжести своего региона. разделив @xmath17 таким образом, чтобы свести к минимуму @xmath70, команда роботов сведет к минимуму ожидаемое расстояние между задачей и роботом, который будет ее обслуживать. мы вводим два понятия оптимальных разбиений: центроидальное Вороного и попарно- оптимальное. наше обсуждение начинается со следующего простого результата о многоцентровой функции затрат. [ prop : оптимальный - для - hgeneric ] пусть @xmath63 и @xmath50. если @xmath87 - это разбиение Вороного, сгенерированное @xmath56, а @xmath88 таково, что @xmath89, то @xmath90 второе неравенство строго, если есть @xmath91.    предложение [ prop : optimal - for - hgeneric ] подразумевает следующее необходимое условие: если @xmath92 минимизирует @xmath69, то @xmath93 и @xmath64 должны быть разделом Вороного, сгенерированным @xmath56. таким образом, @xmath70 обладает следующим свойством как непосредственным следствием предложения [ prop : optimal - for - hgeneric ]: учитывая @xmath63, если @xmath94 является разделом Вороного, сгенерированным @xmath95, то @xmath96 этот факт мотивирует следующее определение. @xmath63 является _центроидальным разделом Вороного _ из @xmath10, если существует @xmath97, такой, что @xmath64 является разделом Вороного, сгенерированным @xmath56 и @xmath98. набор _ попарно - оптимальных разбиений _ предоставляет альтернативное определение оптимальности разбиения: разбиение является попарно - оптимальным, если для каждой пары смежных областей невозможно найти лучшее двухсекционное объединение двух областей. это условие формально формулируется следующим образом. @xmath63 является _ попарно - оптимальным разделением _, если для каждого @xmath66, @xmath99 следующее предложение утверждает, что множество попарно - оптимальных разделов на самом деле является подмножеством множества центроидных разделов Вороного. доказательство включено и отложено до приложения [ sec : appendix_c ]. смотрите рис. [ рис. : вороной ] для примера, который демонстрирует, что включение является строгим. [ prop : optpair ] пусть @xmath51 будет попарно - оптимальным разделением. тогда @xmath64 также является центроидальным разделением Вороного.    для данной среды @xmath10 пара, состоящая из центроидального разбиения Вороного @xmath64 и соответствующего вектора центроидов @xmath56, локально оптимальна в следующем смысле: @xmath70 нельзя уменьшить, изменив независимо ни @xmath64, ни @xmath56. попарно - оптимальное разделение достигает этого свойства и добавляет, что для каждой пары соседних роботов @xmath100 не существует двух разделов @xmath101 с более низкой стоимостью покрытия. другими словами, размещение роботов в центроидах центроидального раздела Вороного (локально) минимизирует ожидаемое расстояние между задачей, появляющейся случайным образом в @xmath10 в соответствии с относительными весами @xmath73, и роботом, которому принадлежит вершина, в которой появляется задача. расположение в центроидах попарно - оптимального разбиения повышает производительность за счет уменьшения количества неоптимальных решений, к которым может прийти команда. мы стремимся разделить @xmath10 между роботизированными агентами @xmath9, используя только асинхронную, ненадежную связь на короткие расстояния. в разделе [sec: модель ] мы описываем вычислительные, двигательные и коммуникационные возможности, требуемые от команды роботов, а в разделе [ sec: формулировка проблемы] мы формально формулируем проблему, которую мы решаем. в разделе [ sec : алгоритм ] мы предлагаем наше решение, алгоритм дискретного покрытия сплетен, а в [ sec: иллюстративный ] мы приводим иллюстрацию. в разделах [ sec : convprop ] и [ sec : вычисление ] мы описываем свойства сходимости и сложности алгоритма. для нашего алгоритма дискретного освещения сплетен требуется команда роботов-агентов @xmath9, где каждый агент @xmath42 обладает следующими базовыми вычислительными возможностями и возможностями перемещения: 1. агент @xmath48 знает свой уникальный идентификатор @xmath48; 2. агент @xmath48 имеет процессор с возможностью хранить @xmath16 и выполнять операции с подграфами данных. @xmath102 ; и 3. агент @xmath48 может определить, какую вершину в @xmath10 он занимает, и может перемещаться со скоростью @xmath103 вдоль ребер @xmath16 к любой другой вершине в @xmath10. требования к локализации в (c3) на самом деле довольно расплывчаты. локализация используется только для навигации, а не для обновления разделов, поэтому ошибки локализации ограниченной продолжительности не являются проблемой.    предполагается, что роботизированные агенты способны взаимодействовать друг с другом в соответствии с моделью связи сплетен с ограниченным диапазоном, которая описывается следующим образом: 1. при заданном диапазоне связи @xmath104, когда любые два агента находятся некоторое положительное время на расстоянии @xmath105, они общаются в выборочное время пуассоновского процесса с интенсивностью @xmath106. напомним, что однородный пуассоновский процесс - это широко используемая стохастическая модель для событий, которые происходят случайным образом и независимо во времени, где ожидаемое количество событий за период @xmath107 равно @xmath108. [ rem : comm ] ( 1 ) tего коммуникационные возможности являются минимально необходимыми для нашего алгоритма, любые дополнительные возможности могут только сократить время, необходимое для конвергенции. например, было бы приемлемо, чтобы интенсивность @xmath109 зависела от расстояния между роботами таким образом, чтобы @xmath110 для @xmath105. ( 2) мы используем расстояния на графике для моделирования связи на ограниченном расстоянии. предполагается, что эти графические расстояния приближают геодезические расстояния в базовой непрерывной среде и, таким образом, расстояния пути для дифрагирующей волны или движущегося робота. предположим, что для всех @xmath111 каждый агент @xmath42 поддерживает в памяти подключенное подмножество @xmath47 среды @xmath10. наша цель состоит в разработке распределенного алгоритма, который итеративно обновляет раздел @xmath112 при решении следующей задачи оптимизации: @xmath113 с учетом ограничений, налагаемых моделью сети роботов с ограниченной дальностью передачи сплетен из раздела [ sec : модель].      при разработке алгоритма для задачи минимизации необходимо решить два основных вопроса. во-первых, учитывая ограниченные возможности коммуникации в (c4), как роботы должны перемещаться внутри @xmath10, чтобы гарантировать достаточно частые встречи между парами роботов? во-вторых, когда два робота общаются, какой информацией они должны обмениваться и как они должны обновлять свои регионы?    в этом разделе мы представляем \"алгоритм дискретного распространения слухов\", который, следуя этим двум вопросам, состоит из двух компонентов: 1. \"протокол случайного назначения и ожидания движения\"; и 2. \"правило попарного разбиения\".    параллельная реализация протокола случайного назначения и ожидания движения и правила попарного разделения определяет эволюцию позиций и подграфов доминирования агентов, как мы сейчас формально описываем. начнем с протокола случайного назначения и ожидания движения.    ' \" \" ширина высота.4pt * протокол случайного назначения и ожидания движения * ' \" \" ширина высота.4pt каждый агент @xmath114 определяет свое движение, многократно выполняя следующие действия: агент @xmath48 выбирает _ вершину назначения _ @xmath58 из равномерного распределения по своему доминирующему подграфу @xmath43 ; агент @xmath48 перемещается в вершину @xmath58 по кратчайшему пути в @xmath43, соединяющему вершину, которую он в данный момент занимает, и @xmath58; и агент @xmath48 ожидает в @xmath58 в течение времени @xmath115.    ' \" \" ширина высота.4pt если агент @xmath48 перемещается из одной вершины в другую, мы говорим, что агент @xmath48 находится в состоянии _ перемещения_, в то время как если агент @xmath48 ожидает в какой-либо вершине, мы говорим, что он находится в состоянии _ ожидания_. протокол движения разработан таким образом, чтобы обеспечить достаточно частую связь между парами роботов. в общем, можно использовать любой протокол движения, который удовлетворяет этому требованию, поэтому @xmath48 может выбрать @xmath58 из границы @xmath43 или использовать некоторое эвристическое неравномерное распределение по @xmath43.    если какие-либо два агента @xmath48 и @xmath62 находятся в двух вершинах на графическом расстоянии, меньшем, чем @xmath116, в течение некоторого положительного времени, то во время выборки соответствующего коммуникационного пуассоновского процесса два агента обмениваются достаточной информацией для обновления своих соответствующих подграфов доминирования @xmath43 и @xmath57 с помощью правила попарного разбиения.    ' \" \" ширина высота.4pt * правило попарного разбиения * ' \" \" ширина высота.4pt предположим, что в момент времени @xmath111 агент @xmath48 и агент @xmath62 обмениваются данными. без потери общности предположим, что @xmath117. пусть @xmath47 и @xmath118 обозначают текущие подграфы доминирования @xmath48 и @xmath62 соответственно. более того, пусть @xmath119 обозначает момент времени сразу после @xmath49. затем агенты @xmath48 и @xmath62 выполняют следующие задачи: агент @xmath48 передает @xmath47 агенту @xmath62 и наоборот, инициализирует @xmath120, @xmath121, @xmath122, @xmath123, вычисляет @xmath124 и упорядоченный список @xmath125 всех пар вершин в @xmath126, вычисляет множества + @xmath127 + @xmath128 * если * @xmath129 + @xmath130 *, то * @xmath131 @xmath132 ' \" \" ширина высота.4. теперь уместны некоторые замечания. ( 1 ) правило попарного разбиения предназначено для нахождения минимального по стоимости двухсекционного разбиения @xmath126. более формально, если список @xmath125 и наборы @xmath133 и @xmath134 для @xmath135 определены как в правиле попарного разбиения, то @xmath133 и @xmath134 являются оптимальным двухсекционным разбиением @xmath136. @xmath126. \\(2 ) хотя цикл на шагах 4-7 должен выполняться до завершения, чтобы гарантировать, что @xmath133 и @xmath134 являются оптимальными двумя разделами @xmath126, цикл предназначен для возврата промежуточного неоптимального результата, если это необходимо. если @xmath43 и @xmath57 изменятся, то @xmath70 уменьшится, и этого достаточно, чтобы обеспечить возможную конвергенцию. ( 3) в правиле попарного разбиения мы делаем упрощающее предположение, что как только два агента обмениваются данными, применение правила разбиения происходит мгновенно. мы обсуждаем фактическое требуемое время вычислений в разделе [ сек : вычисления ] и некоторые детали реализации в разделе [ сек : результаты]. ( 4) обратите внимание, что простое присвоение @xmath133 @xmath48 и @xmath134 @xmath62 может привести к тому, что роботы `перейдут на другую сторону\" в @xmath126. несмотря на то, что конвергенция гарантирована в любом случае, переключение может быть нежелательным в некоторых приложениях. в этом случае может быть вставлено любое интеллектуальное сопоставление @xmath133 и @xmath134 с @xmath48 и @xmath62. ( 5) агенты, которые не являются смежными, могут взаимодействовать, но правило разделения не изменит их регионы. действительно, в этом случае @xmath133 и @xmath134 не будут отличаться от @xmath47 и @xmath118. стоит упомянуть о некоторых возможных модификациях и расширениях алгоритма.    в случае, если роботы имеют неоднородную динамику, строка 5 может быть изменена, чтобы учесть время перемещения каждого робота между вершинами. например, @xmath136 можно было бы заменить ожидаемым временем прохождения роботом @xmath48 пути от @xmath137 до @xmath138, в то время как @xmath139 рассматривал бы робота @xmath62.    здесь мы фокусируемся на разделении территории, но этот алгоритм можно легко объединить с методами предоставления сервиса в @xmath10, как в @xcite. агенты могли бы распределить свое время между переездом, чтобы встретиться со своими соседями и обновить территорию, и выполнением запрошенных задач в своем регионе. моделирование на рис. [ рис. : sim_four ] показывает четырех роботов, разделяющих квадратную среду препятствиями, где свободное пространство представлено сеткой @xmath140. в исходном разделе, показанном на левой панели, робот в правом верхнем углу контролирует большую часть окружающей среды, в то время как робот в левом нижнем углу контролирует очень мало. затем роботы перемещаются в соответствии с протоколом random destination & wait motion и общаются в соответствии с моделью передачи сплетен с ограниченным диапазоном с помощью @xmath141 (четыре ребра на графике). первый попарный обмен территориями показан на второй панели, где робот слева внизу требует некоторую территорию у робота слева вверху. более поздний обмен между двумя роботами сверху показан на следующих двух панелях. обратите внимание, что голубой робот в правом верхнем углу выдает вершину, которую он занимает в данный момент. в таком сценарии мы направляем робота следовать кратчайшему пути в @xmath16 к его обновленной территории, прежде чем продолжить движение к случайному пункту назначения. после 9 парных обменов территориями роботы достигают оптимального для пар раздела, показанного справа на рис.  [ рис. : sim_four ]. ожидаемое расстояние между случайной вершиной и ближайшим роботом уменьшается с @xmath142 до @xmath143. сильной стороной алгоритма дискретного покрытия сплетен является возможность обеспечения того, чтобы разбиение сходилось к попарно оптимальному разбиению посредством попарного обмена территориями. в теореме [ th : main ] мы суммируем это свойство сходимости с доказательствами, приведенными в разделе [sec: конвергенция]. [ th : main ] рассмотрим сеть роботизированных агентов @xmath9, наделенных вычислительными возможностями и возможностями перемещения (c1 ), ( c2 ), ( c3 ) и коммуникационными возможностями (c4). предположим, что агенты реализуют алгоритм дискретного распространения сплетен, состоящий из параллельной реализации случайного назначения. & протокол ожидания движения _ и правило попарного разбиения на разделы_. тогда a. [ элемент : корректность ] разбиение @xmath144 остается связанным и описывается @xmath145 и b. [ элемент : сходимость ] @xmath144 почти наверняка сходится за конечное время к попарно - оптимальному разбиению.    по определению, попарно - оптимальное разбиение является оптимальным в том смысле, что @xmath70 нельзя улучшить, изменив только две области в разбиении.    для простоты мы предполагаем одинаковую скорость робота, процессы связи и время ожидания. расширение на неоднородные процессы было бы простым.      в этом подразделе мы исследуем вычислительные требования алгоритма дискретного покрытия сплетен и сделаем несколько замечаний по реализации. функция стоимости @xmath146 - это сумма расстояний между @xmath18 и всеми остальными вершинами в @xmath43. это вычисление расстояний от одного до всех является основным вычислением алгоритма. для большинства интересующих графиков общее количество ребер @xmath147 пропорционально @xmath148, поэтому мы определим границы этого вычисления в терминах @xmath149. для вычисления расстояний \"один ко всем\" требуется одно из следующих действий: * если все веса ребер в @xmath16 одинаковы (например, для график из таблицы занятости ), можно использовать подход поиска в ширину, который требует @xmath150 во времени и памяти; * в противном случае необходимо использовать алгоритм Дейкстры, который требует @xmath151 во времени и @xmath150 в памяти. пусть @xmath152 - это время для вычисления расстояний от одного до всех в @xmath43, тогда для вычисления @xmath146 требуется @xmath153 во времени. [ prop : вычисление ] протокол движения требует @xmath150 в памяти и @xmath153 во времени вычисления. правило разделения требует @xmath154 в пропускной способности связи между роботами @xmath48 и @xmath62, @xmath154 в памяти и может быть запущен в любое время. сначала мы докажем утверждения для протокола движения. шаг 2 является единственным нетривиальным шагом и требует нахождения кратчайшего пути в @xmath43, что эквивалентно вычислению взаимно однозначных расстояний от текущей вершины робота. следовательно, для этого требуется @xmath153 во времени и @xmath155 в памяти. теперь мы докажем утверждения для правила разбиения на разделы. на шаге 1 роботы @xmath48 и @xmath62 передают свои подграфы друг другу, что требует @xmath154 в полосе пропускания связи. для шага 3 роботы определяют @xmath156, для хранения которого требуется @xmath154 в памяти. шаг 4 - это начало цикла, который выполняет @xmath157 раз, что влияет на временную сложность шагов 5, 6 и 7. шаг 5 требует двух вычислений расстояний от одного до всех в @xmath126, каждое из которых принимает @xmath158. Шаг 6 включает в себя четыре вычисления @xmath68 над разными подмножествами @xmath126, однако значения для @xmath133 и @xmath134 могут быть сохранены из предыдущих вычислений. поскольку @xmath159 и @xmath160 являются строгими подмножествами @xmath126, шаг 5 занимает больше времени, чем шаг 6. шаг 7 тривиален, как и шаг 8. таким образом, общая временная сложность цикла равна @xmath161. однако цикл на этапах 4-7 может быть усечен после любого количества итераций. хотя он должен выполняться до завершения, чтобы гарантировать, что @xmath133 и @xmath134 являются оптимальными двумя разделами @xmath126, цикл предназначен для возврата промежуточного неоптимального результата, если это необходимо. если @xmath43 и @xmath57 изменятся, то @xmath70 уменьшится. наш результат сходимости сохранится при условии, что все элементы @xmath125 в конечном итоге будут проверены, если @xmath43 и @xmath57 не изменятся. таким образом, правило секционирования может выполняться в любое время, при этом для каждой итерации требуется @xmath158. все требования к вычислениям и коммуникации в предложении [ prop : computation ] не зависят от количества роботов и масштабируются в соответствии с размером раздела робота, что означает, что алгоритм дискретного освещения сплетен может легко масштабироваться для больших команд роботов в больших средах. этот раздел посвящен доказательству двух утверждений теоремы [ th : main ]. доказательство того, что правило попарного разбиения отображает связный @ xmath9-раздел в связный @ xmath9-раздел, является простым. доказательство сходимости более сложное и основано на применении леммы [ lem : finite - lasalle ] в приложении [ sec : appendix_a ] к алгоритму дискретного покрытия сплетен. лемма [ lem: finite - lasalle ] устанавливает сильные свойства сходимости для определенного класса многозначных отображений (многозначные отображения кратко рассмотрены в приложении [ sec : appendix_a ] ). мы начнем с доказательства того, что правило попарного разбиения корректно сформулировано в том смысле, что оно поддерживает связный раздел. чтобы доказать утверждение, нам нужно показать, что @xmath162 удовлетворяет пунктам (i)-(iv) определения [ def : conpartitions ]. из определения правила попарного разбиения мы имеем, что @xmath163 и @xmath164. более того, поскольку @xmath165 и @xmath166, из этого следует, что @xmath167 и @xmath168. эти наблюдения подразумевают достоверность пунктов (i), (ii ) и (iii ) для @xmath162. наконец, мы должны показать, что @xmath169 и @xmath170 связаны, т.е. @xmath162 также удовлетворяет пункту (iv). для этого мы покажем, что, учитывая @xmath171, любой кратчайший путь в @xmath172, соединяющий @xmath138 с @xmath173, полностью принадлежит @xmath133. мы исходим из противоречия. пусть @xmath174 обозначает кратчайший путь в @xmath175, соединяющий @xmath138 с @xmath173, и давайте предположим, что существует @xmath176 такой, что @xmath177. для @xmath178 быть в @xmath134 означает, что @xmath179. это подразумевает, что @xmath180 это противоречие для @xmath171. аналогичные соображения справедливы для @xmath134. остальная часть этого раздела посвящена доказательству сходимости. наш первый шаг - показать, что эволюцию, определяемую алгоритмом дискретного покрытия сплетнями, можно рассматривать как многозначную карту. с этой целью для любой пары роботов @xmath181, @xmath182 мы определяем карту @xmath183 с помощью @xmath184, где @xmath185 и @xmath186. если в момент времени @xmath187 пара @xmath100 и никакая другая пара роботов не выполняют итерацию правила попарного разбиения, то динамическая система в пространстве разделов описывается @xmath188. Мы определяем многозначную карту @xmath189 как @xmath190, которую затем можно переписать как @xmath191. в следующих двух предложениях излагаются факты, достоверность которых обеспечивается леммой [ lemma : onmotionprotocol ] приложения [ sec : appendix_b ], в которой указано ключевое свойство протокола случайного назначения и ожидания движения. [ prop : tk ] рассмотрим роботов @xmath9, реализующих алгоритм дискретного освещения сплетен. тогда почти наверняка существует возрастающая последовательность моментов времени @xmath192, такая, что @xmath193 для некоторого @xmath194. доказательство следует непосредственно из леммы [лемма : onmotionprotocol ], которая подразумевает, что время между двумя последовательными попарными сообщениями почти наверняка конечно. существование временной последовательности @xmath192 позволяет нам выразить эволюцию, генерируемую алгоритмом дискретного освещения сплетен, как дискретный временной процесс. пусть @xmath195 и @xmath196, затем @xmath197, где @xmath189 определяется как в .    учитывая @xmath198, пусть @xmath199 обозначает информацию, которая полностью характеризует состояние алгоритма покрытия дискретных сплетен сразу после @xmath0-й итерации правила разбиения, т.е. в момент времени @xmath200. в частности, @xmath199 содержит информацию, относящуюся к разделу @xmath201, позиции роботов в @xmath200 и находится ли каждый робот в состоянии _ ожидания _ или _ перемещения _ в @xmath200. следующий результат характеризует вероятность того, что, учитывая @xmath199, @xmath202-я итерация правила разбиения на разделы регулируется любым из отображений @xmath203, @xmath204. [ prop : pi ] рассмотрим команду роботов @xmath9 с возможностями ( c1 ), ( c2 ), (c3 ) и ( c4), реализующих алгоритм дискретного освещения сплетен. тогда существует действительное число @xmath205, такое, что для любых @xmath206 и @xmath204 @xmath207\\geq \\bar{\\pi}.\\ ] ] предположим, что в момент времени @xmath208 взаимодействует одна пара роботов. учитывая пару @xmath209, мы должны найти нижнюю границу вероятности того, что @xmath210 является сообщающейся парой. поскольку все пуассоновские коммуникационные процессы имеют одинаковую интенсивность, распределение вероятности общения является равномерным по парам, которые `способны общаться\", т.е. находятся ближе, чем @xmath116 друг к другу. таким образом, мы должны только показать, что @xmath210 имеет положительную вероятность того, что сможет общаться в момент времени @xmath208, что эквивалентно показу того, что @xmath210 способен общаться в течение положительной доли времени с положительной вероятностью. доказательство леммы [лемма : onmotionprotocol ] подразумевает, что с вероятностью, по крайней мере, @xmath211 любая пара в @xmath212 способна взаимодействовать в течение доли времени, не меньшей, чем @xmath213, где @xmath214 и @xmath107 определены в доказательстве леммы [ лемма : onmotionprotocol ]. отсюда следует результат.    свойство в предложении [ prop : pi ] также может быть сформулировано следующим образом. пусть @xmath215 - стохастический процесс, такой, что @xmath216 является взаимодействующей парой в момент времени @xmath0. тогда последовательность пар роботов, выполняющих правило разделения в моменты времени @xmath192, можно рассматривать как реализацию процесса @xmath217, который удовлетворяет @xmath218 \\geq \\bar{\\pi}\\ ] ] для всех @xmath204. далее мы покажем, что функция стоимости уменьшается всякий раз, когда применение @xmath219 from изменяет разбиение территории. этот факт является ключевым элементом для применения леммы [ lem : finite - lasalle ]. [ лемма : tdecr ] пусть @xmath220 и пусть @xmath221. если @xmath222, то @xmath223.    без потери общности предположим, что @xmath100 - это пара, выполняющая правило попарного разбиения. тогда @xmath224 в соответствии с определением правила попарного разбиения мы имеем, что если @xmath225, @xmath226, то @xmath227, из которого следует утверждение. теперь мы завершаем доказательство основного результата, теоремы [ th : main ]. Обратите внимание, что алгоритм развивается в конечном пространстве разбиений, и согласно утверждению теоремы [ th : main ] ( [ item : корректность ] ), множество @xmath44 строго положительно инвариантно. этот факт подразумевает, что выполняется предположение (i) леммы [ lem : finite - lasalle ]. из леммы [лемма: tdecr ] следует, что предположение (ii) также выполняется, причем @xmath70 играет роль функции @xmath126. наконец, свойство в эквивалентно свойству _ постоянных случайных переключений _, указанному в предположении (iii) леммы [ lem : finite - lasalle ], для особого случая @xmath228. следовательно, мы в состоянии применить лемму [ lem : finite - lasalle ] и завершить сходимость за конечное время к элементу пересечения равновесий отображений @ xmath203, который по определению является множеством попарно- оптимальных разбиений. чтобы продемонстрировать полезность и изучить практические вопросы алгоритма дискретного освещения сплетен, мы реализовали его с использованием системы управления роботом player / stage с открытым исходным кодом @xcite и библиотеки boost graph (bgl) @xcite. все представленные здесь результаты были сгенерированы с использованием player 2.1.1, stage 2.1.1 и bgl 1.34.1. для вычисления расстояний на графиках с равномерным весом ребер мы расширили процедуру поиска bgl в ширину с помощью посетителя события записи расстояний.      чтобы оценить эффективность нашего алгоритма освещения сплетен в больших командах, мы протестировали 30 смоделированных роботов, разбивающих карту, представляющую часть кампуса Калифорнийского университета в Санта-Барбаре. как показано на рис. [ рис. : large_sim ], роботам поручено обеспечить покрытие открытого пространства вокруг некоторых зданий кампуса, пространства, которое включает в себя пару открытых квадроциклов, несколько более узких проходов между зданиями и несколько тупиковых ответвлений. для этой большой среды моделируемые роботы находятся на расстоянии @xmath230 сбоку и могут перемещаться на расстоянии @xmath231. каждая ячейка территории равна @xmath232.    в этом моделировании мы обрабатываем связь и разделение следующим образом. диапазон связи устанавливается равным @xmath233 (10 ребер на графике) с помощью @xmath234. роботы ожидают в своих конечных вершинах @xmath235. это значение для @xmath236 было выбрано таким образом, чтобы в среднем четверть роботов ожидали в любой момент. более низкие значения @xmath236 означают, что роботы перемещаются большую часть времени и, как следствие, чаще пропускают соединения, в то время как при более высоких значениях @xmath236 роботы проводят больше времени неподвижно, что также снижает скорость сближения. с целью улучшения коммуникации мы внедрили небольшую модификацию в протокол движения: каждый робот выбирает свой случайный пункт назначения из ячеек, образующих открытую границу - это набор вершин в @xmath43, которые примыкают по крайней мере к одной вершине, принадлежащей другому агенту. ] его территории. в нашей реализации полный цикл разбиения может занять @xmath237 секунд для самых больших начальных территорий на рис. [ рис. : large_sim ]. мы решили остановить цикл через четверть секунды для этого моделирования, чтобы проверить утверждение о вычислении anytime: 30 роботов начинают группироваться в центре карты между engineering ii и broida hall, и из этих начальных позиций генерируется начальное распределение Вороного. это начальное разбиение показано слева на рис. [ рис. : large_sim ] с роботами, расположенными в центроидах их начальных областей. стоимость начального разбиения составляет @xmath238. команда тратит около 27 минут на перемещение и общение в соответствии с алгоритмом дискретного освещения сплетен, прежде чем остановиться на последнем разделе справа от рис. [ рис. : large_sim ]. стоимость покрытия конечного равновесия улучшилась с @xmath239 до @xmath240. визуально конечное разбиение также значительно более однородно, чем исходное условие. этот результат демонстрирует, что алгоритм эффективен для больших команд в больших невыпуклых средах.     с течением времени для моделирования на рис. [ рис. : large_sim].,высота=125 ] рис. [ рис. : large_sim_cost ] показывает эволюцию @xmath70 во время моделирования. наибольшее снижение затрат происходит на ранней стадии, когда роботы, владеющие большими территориями слева и справа от карты, общаются с соседями с гораздо меньшими территориями. эти значительные территориальные изменения затем распространяются по сети по мере того, как роботы встречаются и подталкиваются к разделу с меньшими затратами. мы провели эксперимент по тестированию алгоритма с использованием трех физических роботов в нашей лаборатории, дополненный шестью моделируемыми роботами в синтетической среде, выходящей за пределы лаборатории. наше лабораторное пространство находится сбоку от @xmath241 и представлено верхней левой частью карты территории на рис. [ рис. : эксперимент ]. график территории огибает центральный островок из столов. мы расширили лабораторное пространство за счет трех подключений в имитируемую среду вокруг лаборатории, создав среду @xmath242. карта окружающей среды была задана с помощью растрового изображения @xmath243, которое мы наложили на сетку занятости с разрешением @xmath244, представляющую свободную территорию для роботов. результатом является решетчатый граф с весами всех ребер, равными @xmath244. разрешение @xmath244 было выбрано таким образом, чтобы наши физические роботы легко помещались внутри ячейки. дополнительные подробности нашей реализации приведены ниже. мы используем неустойчивых мобильных роботов от videre design, как показано на рис. [ рис. : робот ]. платформа транспортного средства имеет примерно квадратную площадь @xmath245, с двумя ведущими колесами с дифференциалом и одним задним роликом. каждый робот оснащен бортовым компьютером с процессором core 2 duo с тактовой частотой 1,8 ГГц, 1 Гб оперативной памяти и беспроводной связью стандарта 802.11 g. для навигации и локализации каждый робот оснащен лазерным дальномером hokuyo urg-04lx. дальномер сканирует точки @xmath246 поверх @xmath247 на @xmath248 с дальностью действия @xmath249 метров. наши смешанные эксперименты с физическими и виртуальными роботами проводятся с центрального компьютера, подключенного к беспроводному маршрутизатору, чтобы он мог взаимодействовать с физическими роботами. центральный компьютер создает симулированный мир, используя сцену, которая отражает и расширяет реальное пространство, в котором работают физические роботы. центральный компьютер также моделирует виртуальных членов команды роботов. эти виртуальные роботы смоделированы на основе нашего оборудования: они имеют дифференциальный привод с той же геометрией, что и платформа erratic, и используют имитационные дальномеры hokuyo urg-04lx. мы используем драйвер amcl в player, который реализует адаптивную локализацию по методу Монте-Карло @xcite. физическим роботам предоставляется карта нашей лаборатории с разрешением @xmath250 и указывается их начальная позиция на карте. мы устанавливаем стандартное отклонение начальной позы, равное @xmath251 в положении и @xmath252 в ориентации, и запрашиваем обновления локализации, используя @xmath253 измерений диапазона датчика для каждого изменения @xmath254 в положении или @xmath255 в ориентации, о которых сообщает система одометрии робота. затем мы используем наиболее вероятную оценку позы, полученную с помощью \"amcl\", в качестве местоположения робота. для простоты и снижения вычислительных затрат мы предоставляем виртуальным роботам доступ к точной информации о локализации. каждый робот непрерывно выполняет протокол случайного назначения и ожидания движения, при этом навигация осуществляется драйвером snd в player, который реализует плавную навигацию по диаграмме близости @xcite. для параметра \"snd\" мы устанавливаем радиус робота равным @xmath256, расстояние обхода препятствий - @xmath257, а максимальные скорости - @xmath258 и @xmath259. драйвер `snd` является локальным планировщиком обхода препятствий, поэтому мы вводим в него серию путевых точек через каждые пару метров вдоль путей, найденных в @xmath16. мы считаем, что робот достиг своего целевого местоположения, когда он находится в пределах @xmath260, и затем он будет ждать @xmath235. для физических роботов протокол движения и навигационные процессы выполняются на борту, в то время как для каждого виртуального робота на центральном компьютере существуют отдельные потоки. по мере перемещения роботов центральный процесс отслеживает их положение и моделирует модель обмена информацией с ограниченным диапазоном как между реальными, так и виртуальными роботами. мы установили @xmath141 и @xmath261. эти параметры были выбраны таким образом, чтобы роботы, скорее всего, общались, когда их разделяет не более четырех ребер, но также иногда не могли подключиться, несмотря на близость. когда этот процесс определяет, что два робота должны взаимодействовать, он информирует роботов, которые затем выполняют правило попарного разделения. наша реализация парной коммуникации блокируется: если робот @xmath48 обменивается территорией с @xmath62, то он сообщает процессу установления соответствия, что он недоступен до завершения обмена. результаты нашего эксперимента с тремя физическими роботами и шестью моделируемыми роботами показаны на рис. [ рис. : эксперимент ] и [ рис. : exp_cost ]. левая колонка на рис. [рис. : эксперимент ] показаны начальные позиции команды роботов, при этом физические роботы, помеченные как 1, 2 и 3, выстроились в углу лаборатории, а смоделированные роботы выстроились вокруг них. начальные позиции используются для создания начального раздела среды Вороного. физическим роботам принадлежат оранжевые, синие и лимонно-зеленые территории в верхнем левом квадранте. мы выбрали эту начальную конфигурацию, чтобы обеспечить высокую стоимость покрытия, гарантируя при этом, что физические роботы останутся в лаборатории по мере развития раздела.    в среднем столбце роботы 1 и 2 встретились вдоль своей общей границы и обмениваются территорией. на карте территорий сплошная красная линия указывает на то, что 1 и 2 общаются, а их обновленные территории выделены сплошным оранжевым и синим цветом соответственно. изображение с камеры подтверждает, что два робота встретились на ближней стороне центрального островка столов.    конечная перегородка справа на рис. [ рис. : эксперимент ] достигается через 262 минуты. все роботы расположены в центроидах своих конечных территорий. три физических робота перешли от скопления в одном углу лаборатории к более равномерному распределению по всему пространству.   . общая стоимость @xmath70 показана выше черным цветом, в то время как @xmath68 для каждого робота показана ниже цветом робота. ] [ рис. : exp_cost ] показывает эволюцию функции затрат @xmath70 по ходу эксперимента, включая затраты для каждого робота. как и ожидалось, общая стоимость никогда не увеличивается, а разница в затратах на отдельных роботов со временем сокращается, пока не достигнет оптимального для пары распределения.    в этом эксперименте драйверы amcl и snd эффективно справлялись с аппаратными проблемами, связанными с шумом датчиков, навигацией и неопределенностью местоположения. алгоритм покрытия взял на себя роль планировщика более высокого уровня, принимая данные о местоположении из \"amcl\" и направляя \"snd\". безусловно, наиболее требовательным к вычислениям компонентом был \"amcl\", но гипотезы о местоположении из \"amcl\" на самом деле не нужны: наш алгоритм покрытия требует только знания вершины робот занимает. если бы был доступен менее интенсивный метод локализации, алгоритм мог бы работать на роботах со значительно меньшей вычислительной мощностью.      в этом подразделе мы представляем численное сравнение производительности алгоритма дискретного освещения сплетен и следующих двух алгоритмов типа Ллойда. этот метод взят из @xcite и @xcite, мы описываем его здесь для удобства. в каждый дискретный момент времени @xmath263 каждый робот @xmath48 выполняет следующие задачи: ( 1 ) @xmath48 передает свое местоположение и получает позиции всех соседних роботов; ( 2 ) @xmath48 вычисляет свою область Вороного @xmath43 на основе полученной информации; и ( 3 ) @xmath48 перемещается в @xmath264. этот метод взят из @xcite. это алгоритм сплетен, и поэтому мы использовали ту же модель коммуникации и протокол случайного назначения и ожидания движения для создания встреч между роботами. скажем, роботы @xmath48 и @xmath62 встречаются во время @xmath49, тогда правило парного разбиения Ллойда работает следующим образом: ( 1 ) robot @xmath48 trпреобразует @xmath47 в @xmath62 и наоборот; ( 2 ) оба робота определяют @xmath265 ; ( 3 ) робот @xmath48 устанавливает @xmath169 в качестве своей области Вороного в @xmath126 на основе @xmath266 и @xmath267, а @xmath62 выполняет эквивалент.    для обоих алгоритмов Ллойда мы используем одно и то же правило разрыва связей при создании областей Вороного, которое присутствует в правиле попарного разбиения: связи переходят к роботу с наименьшим индексом. наш первый численный результат использует метод оценки вероятности по методу Монте-карло от @ xcite, чтобы установить вероятностные границы производительности двух алгоритмов gossip. напомним, что граница Черноффа описывает минимальное количество случайных выборок @xmath268, необходимое для достижения определенного уровня точности оценки вероятности по независимым тестам Бернулли. для точности @xmath269 и достоверности @xmath270 количество выборок указано @xmath271 для @xmath272 и @xmath273 требуется не менее 116 выборок. на рисунке [ fig : bad_start ] показано как начальное разбиение территории используемой расширенной лабораторной среды, так и гистограмма конечных результатов для следующего теста Монте-Карло. используемые модели окружения и движения робота описаны в разделе [sec : реализация]. начиная с указанного начального условия, мы выполнили 116 симуляций обоих алгоритмов gossip. случайность в тесте обусловлена последовательностью попарных взаимодействий. эти последовательности были сгенерированы с использованием: ( 1 ) протокола случайного назначения и ожидания движения с @xmath58, равномерно отобранного с открытой границы @xmath43 и @xmath235; и ( 2 ) модели передачи сплетен с ограниченным диапазоном с @xmath141 и @xmath261.    стоимость начального раздела на рис. [ рис. : bad_start ] равна @xmath274, в то время как стоимость наиболее известного раздела для этой среды составляет чуть менее @xmath275. гистограмма на рис. [ рис. : bad_start ] показаны конечные равновесные затраты для 116 симуляций алгоритма дискретного освещения сплетен (черный ) и алгоритма сплетен Ллойда (серый). он также показывает конечную стоимость с использованием децентрализованного алгоритма Ллойда (красная пунктирная линия), который определяется исходя из заданного начального условия. ячейки гистограммы имеют ширину @xmath276 и начинаются с @xmath277. для алгоритма дискретного покрытия сплетен @xmath278 из @xmath279 проб попадают в корзину, содержащую наиболее известный раздел, а средняя конечная стоимость составляет @xmath280. алгоритм gossip lloyd достигает наименьшего значения только в @xmath237 из @xmath279 испытаний и имеет среднюю конечную стоимость @xmath281. децентрализованный алгоритм Ллойда достигает @xmath282. нашему новому алгоритму gossip для достижения равновесия требуется в среднем @xmath283 попарных обмена данными, в то время как gossip lloyd требует @xmath284. основываясь на этих результатах, мы можем с уверенностью @xmath285 заключить, что существует, по крайней мере, @xmath286 вероятность того, что 9 роботов выполнят алгоритм дискретного покрытия gossip, начиная с показанного начального раздела. на рис. [ рис. : bad_start ] достигнет попарно оптимального раздела, стоимость которого находится в пределах @xmath287 от наилучшей известной стоимости. далее мы можем с уверенностью @xmath285 заключить, что алгоритм gossip lloyd установит более чем @ xmath287 выше наиболее известной стоимости, по крайней мере, @xmath288 времени, начиная с этого начального условия.     сравнение алгоритма дискретного освещения сплетен (черные полосы), алгоритма сплетен Ллойда (серые полосы) и децентрализованного алгоритма Ллойда (красная пунктирная линия). для алгоритмов сплетен было выполнено 116 симуляций с различными последовательностями попарных коммуникаций. децентрализованный алгоритм Ллойда является детерминированным при заданном начальном условии, поэтому отображается только одна конечная стоимость. начальная стоимость для каждого теста показана зеленой пунктирной линией. ] рисунок [ fig : multi_compare ] сравнивает гистограммы конечных затрат для @xmath289 различных начальных условий для одной и той же среды и параметров, как описано выше. каждое начальное условие было создано путем равномерного случайного выбора уникальных начальных местоположений для роботов и использования этих местоположений для создания начального разбиения Вороного. начальная стоимость каждого теста показана зеленой пунктирной линией. в 9 из 10 тестов алгоритм дискретного покрытия сплетнями достигает ячейки гистограммы с наиболее известным разделом, по крайней мере, в @xmath290 из @xmath279 испытаний. два метода Ллойда застревают в неоптимальных центроидных разделах Вороного на расстоянии более чем @xmath287 от наиболее известного раздела более чем в половине испытаний в 7 из 10 тестов. мы представили новый алгоритм распределенного разбиения и контроля покрытия, который требует только ненадежной связи на короткие расстояния между парами роботов и работает в невыпуклых средах. классический подход Ллойда к оптимизации покрытия включает повторение отдельных шагов центрирования и разбиения по Вороному. однако для алгоритмов gossip такое разделение не требуется с точки зрения вычислений, и мы показали, что повышение производительности может быть достигнуто и без него. наш новый алгоритм дискретного покрытия сплетен доказуемо сходится к подмножеству набора центроидных разбиений Вороного, которые мы назвали попарно- оптимальными разбиениями. с помощью численных сравнений мы продемонстрировали, что это новое подмножество решений позволяет избежать многих локальных минимумов, в которых могут застревать алгоритмы типа Ллойда. наше видение заключается в том, что этот алгоритм разделения и покрытия ляжет в основу распределенной системы обслуживания задач для команд мобильных роботов. роботы будут распределять свое время между обслуживанием задач на своей территории и перемещением, чтобы связаться со своими соседями и улучшить покрытие пространства. наши результаты конвергенции требуют лишь эпизодических улучшений функции затрат, обеспечивая гибкость в поведении и возможностях роботов, а также предлагая возможность работать с разнородными роботизированными сетями. в целом, эта статья демонстрирует потенциал передачи сплетен в алгоритмах распределенной координации. по-видимому, существует много других проблем, в которых эта реалистичная и минимальная коммуникационная модель могла бы быть плодотворно применена. учитывая набор @xmath291, многозначная карта @xmath292 - это карта, которая связывает с элементом @xmath293 подмножество @xmath294 многозначная карта непустая, если @xmath295 для всех @xmath296. учитывая непустое многозначное отображение @xmath219, эволюция динамической системы, связанной с @xmath219, представляет собой последовательность @xmath297, где @xmath298 для всех @xmath299 множество @xmath300 является _ сильно положительно инвариантным _ для @xmath219, если @xmath301 для всех @xmath302. [ lem : finite - lasalle ] пусть @xmath303 - конечное метрическое пространство. учитывая коллекцию карт @xmath304, определите многозначную карту @xmath292 с помощью @xmath305. учитывая стохастический процесс @xmath306, рассмотрим эволюцию @xmath307 из @xmath219, удовлетворяющую @xmath308 предположим, что: 1. существует множество @xmath309, которое строго положительно инвариантно для @xmath219; 2. существует функция @xmath310, такая, что @xmath311, для всех @xmath312 и @xmath313 ; и 3. существуют @xmath314 и @xmath315 такие, что для всех @xmath316 и @xmath317 существует @xmath318 такие, что @xmath319 \\geq p.      $ ] для @xmath320 пусть @xmath321 - множество фиксированных точек @xmath322 в @xmath323, т.е. @xmath324. если @xmath325, то эволюция @xmath307 почти наверняка сходится за конечное время к элементу множества @xmath326, т.е. почти наверняка существует @xmath327 такой что для некоторых @xmath328, @xmath329 для @xmath330 [ лемма : onmotionprotocol ] рассмотрим роботов @xmath9, реализующих алгоритм дискретного освещения сплетен, начиная с произвольного @xmath51. рассмотрим @xmath187 и пусть @xmath144 обозначает раздел в момент времени @xmath49. предположим, что в момент времени @xmath49 никакие два робота не взаимодействуют. тогда существуют @xmath331 и @xmath332, независимые от @xmath144 и позиций и состояний роботов во время @xmath49, так что для каждого @xmath333, @xmath334\\ge \\alpha.$ ] наша цель - снизить вероятность того, что @xmath48 и @xmath62 будут взаимодействовать в пределах интервала @xmath340. для этого мы создаем _ одну _ последовательность событий с положительной вероятностью, которая обеспечивает такую коммуникацию. рассмотрим следующую ситуацию: @xmath48 находится в состоянии _ moving _ и ему требуется время @xmath341, чтобы добраться до пункта назначения @xmath58, тогда как робот @xmath62 находится в состоянии _ waiting _ в вершине @xmath59 и должен ждать там время @xmath342. мы обозначаем через @xmath343 ( соответственно. @xmath344 ) время, необходимое @xmath48 ( соответственно. @xmath62 ) для перемещения из @xmath58 ( соответственно. @xmath59 ) до @xmath137 ( соответственно. @xmath345 ). пусть @xmath346 - событие, такое, что @xmath48 выполняет следующие действия в @xmath347 без связи с каким-либо роботом @xmath348: далее мы уменьшаем вероятность того, что произойдет событие @xmath355. вспомним определение @xmath356 из раздела.  [ sec : модель ]. поскольку у робота может быть не более @xmath357 соседей, вероятность того, что произойдет (i) из @xmath355, ниже, ограниченная @xmath358 для ( ii ), вероятность того, что @xmath48 выберет @xmath137, равна @xmath359, которая ниже, ограниченная @xmath360. затем, чтобы потратить хотя бы @xmath361 на @xmath137, @xmath48 должен выбрать @xmath137 для @xmath362 раз подряд. наконец, вероятность того, что в течение этого интервала @xmath48 не будет взаимодействовать ни с каким роботом, кроме @xmath62, ниже, ограниченная @xmath363 вероятность того, что произойдет (ii), таким образом, ниже, ограниченная @xmath364 комбинируя границы для (i ) и (ii ), следует, что @xmath365\\geq \\bigl(\\tfrac{1}{{\\left|q\\right|}}\\bigr)^{\\lceil \\frac{\\delta}{\\tau } \\rceil } e^{-{{\\lambda_{\\textup{comm}}}}(\\delta+\\tau ) n}.\\ ] ] та же нижняя граница справедлива для @xmath366 $ ], что означает, что @xmath367&={\\mathbb{p}}\\left[e_{i}\\right]\\, { \\mathbb{p}}\\left[e_{j}\\right ] \\geq \\bigl(\\tfrac{1}{{\\left|q\\right|}}\\bigr)^{2 \\lceil \\frac{\\delta}{\\tau } \\rceil } e^{-2 { { \\lambda_{\\textup{comm}}}}(\\delta+\\tau ) n}.\\end{выровнено}\\ ] ] если произойдет событие @xmath368, то роботы @xmath48 и @xmath62 будут находиться в соседних вершинах в течение amколичество времени в течение интервала @xmath347, равного @xmath369, поскольку @xmath343 и @xmath344 не больше, чем @xmath370, мы можем заключить, что @xmath48 и @xmath62 будут находиться в пределах @xmath116, по крайней мере, для @xmath236. обусловленная возникновением @xmath368, вероятность того, что @xmath48 и @xmath62 взаимодействуют в @xmath347, ниже, ограничена @xmath371. подходящим выбором для @xmath214 из утверждения леммы, таким образом, является @xmath372. можно показать, что это также представляет собой нижнюю границу для других возможных комбинаций начальных состояний : робот @xmath48 находится в _ ожидании _, а робот @xmath62 находится в _ движении _; роботы @xmath48 и @xmath62 оба находятся в _ движении _; и роботы @xmath48 и @xmath62 оба находятся в _ ожидании_.        чтобы создать противоречие, предположим, что @xmath51 является попарно - оптимальным разделом, но не центроидальным разделом Вороного. другими словами, существуют компоненты @xmath43 и @xmath57 в @xmath64 и элемент @xmath138 одного компонента, скажем, @xmath373, такой, что @xmath374 выбирает @xmath57 таким образом, что для всех @xmath375 @xmath376 пусть @xmath377 будет кратчайшим путем в @xmath17, соединяющим @xmath137 с @xmath345 и пусть @xmath378 будет первым элементом пути, начинающимся с @xmath379, которого нет в @xmath57. пусть @xmath380 будет таким, что @xmath381.          в первом случае мы снова имеем противоречие, используя ту же логику, что и выше, с @xmath178 вместо @xmath138. во втором случае мы должны дополнительно рассмотреть, существует ли @xmath389 такой, что каждая вершина в @xmath389 также находится в @xmath390. если такого пути нет, то @xmath391 и мы снова имеем противоречие, как указано выше. если такой путь существует, то мы можем вместо этого повторить этот анализ, используя using @xmath380 вместо @xmath62 и учитывая путь, образованный этим @xmath389 и вершинами в @xmath383 после @xmath178. поскольку следующая вершина, играющая роль @xmath178, должна быть ближе к @xmath138, мы можем использовать @xmath178. в конечном счете мы найдем вершину, которая создает противоречие. 

мы предлагаем распределенные алгоритмы для автоматического развертывания команды мобильных роботов для разбиения и обеспечения покрытия невыпуклой среды. для обработки произвольных невыпуклых сред мы представляем их в виде графиков. наш алгоритм разбиения и покрытия требует только кратковременной, ненадежной попарной связи `сплетен\". алгоритм состоит из двух компонентов: (1) протокол движения, гарантирующий, что соседние роботы общаются, по крайней мере, время от времени, и (2 ) правило попарного разделения для обновления владения территорией, когда два робота общаются. изучая соответствующую динамическую систему на пространстве разбиений вершин графа, мы доказываем, что владение территорией сходится к попарно - оптимальному разбиению за конечное время. этот новый набор равновесий представляет собой улучшенную производительность по сравнению с обычными алгоритмами типа Ллойда. Кроме того, мы подробно описываем, как наш алгоритм хорошо масштабируется для больших команд в больших средах и как вычисления могут выполняться в любое время при ограниченных ресурсах. наконец, мы сообщаем о крупномасштабных симуляциях в сложных средах и аппаратных экспериментах с использованием системы управления роботом player/stage.