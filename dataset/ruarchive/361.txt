с точки зрения роли в повышении эффективности и совокупной пропускной способности сети концепция когнитивного радио играет иную роль, чем традиционные методы распределения спектра @xcite. в когнитивных сетях нелицензированные вторичные пользователи оппортунистически получают доступ к полосе пропускания радиосвязи, принадлежащей лицензированным первичным пользователям, чтобы максимизировать их производительность, ограничивая при этом помехи для связи первичных пользователей.    ранее cognitive radio в основном фокусировалось на подходе с пробелами @xcite, при котором второстепенным пользователям разрешался доступ только к тем временным / частотным интервалам, которые не использовались лицензированными пользователями. подход с пробелами основан на обосновании отсутствия помех. но из-за шума и замирания в канале и механизма определения канала ошибки в измерениях неизбежны. следовательно, в практических сценариях существует некоторая вероятность возникновения коллизии между первичным и вторичным пользователями, которая может быть измерена и использована в качестве ограничения для задачи оптимизации. есть несколько работ, исследующих сосуществование первичных/вторичных сигналов в одном и том же временном/ частотном диапазоне, с акцентом на методы физического уровня для статических сценариев, например, @xcite. учитывая динамизм при наложении первичных и вторичных пользователей на один и тот же временной/ частотный интервал, была выведена стратегия вторичного пользователя, при которой первичный пользователь работает в сетях на основе arq со щелевым доступом @xcite. мы рассматриваем сети на базе стандарта ieee 802.11, в которых основные пользователи используют протокол dcf для доступа к каналу. в отличие от работы @xcite, в нашей современной работе @xcite мы разработали стратегию передачи для вторичного пользователя, которая разумно выбирает счетчик отсрочки или остается бездействующей после мультиплексной передачи. поскольку пользователю необходимо пройти diffs и период ожидания, прежде чем отправить пакет в эфир, вторичный пользователь не знает точного состояния основного пользователя. следовательно, ограничение производительности основного пользователя играет большую роль в процессе принятия решений вторичным пользователем. наша предыдущая работа выявила решение, сформулировав проблему в виде линейной программы, предполагающей, что вторичный пользователь знает распределение трафика, поступающего от основного пользователя.    поскольку этот подход предполагает, что вторичный передатчик обладает некоторыми знаниями о текущем состоянии и вероятностной модели пары первичный передатчик/приемник, это ограничивает его применимость. например, хотя вполне вероятно, что вторичный сервер может считывать подтверждения для первичной системы, маловероятно, что вторичный сервер будет знать о ожидающей загрузке пакетов на первичном передатчике или будет знать распределение поступлений пакетов на первичном передатчике. поэтому мы устраняем это ограничение, разрабатывая подход к онлайн-обучению, который использует один бит обратной связи, отправленный основным пользователем, и который приблизительно соответствует оптимальной политике вторичного управления. мы покажем, что когда вторичный пользователь имеет доступ к таким крошечным знаниям, онлайн-алгоритм может получить производительность, аналогичную автономному алгоритму, с некоторой информацией о состоянии. остальная часть статьи организована следующим образом, раздел [ sec : sysmodel ] иллюстрирует системную модель сети, которая включает в себя подробную задачу оптимизации и последующее решение. результаты, полученные в результате моделирования, были показаны в разделе [ sec : perfeval ] для проверки эффективности алгоритма. наконец, раздел [ sec : concl ] завершает статью. мы рассматриваем сценарий снижения помех в сетях на базе стандарта ieee 802.11. основное предположение о стратегии снижения помех заключается в том, что оба пользователя могут декодировать свои пакеты с некоторой вероятностью, когда они передают вместе или по отдельности. однако вторичный пользователь ограничен тем, что может вызвать не более чем фиксированное максимальное снижение производительности первичного s. этот подход является другой стороной первого пробела. если первичный пользователь не может допустить каких-либо потерь, оптимальной стратегией для вторичного пользователя является отказ от передачи вообще. принимая во внимание, что в work @xcite вторичный пользователь может обнаружить занятость слота и может передавать только в те слоты, которые он находит пустыми, и, следовательно, требует некоторой пропускной способности, даже если основной пользователь не может допустить потери пропускной способности. рассмотрим сеть на рисунке [рис. : sysmodel ] с первичным и вторичным источником, а именно @xmath0 и @xmath1. конечными узлами этих источников являются @xmath2 и @xmath3 соответственно. мы предполагаем квазистатический канал, и время разделено на интервалы. перед началом передачи пакета оба пользователя сначала проходят период diffs и уменьшают счетчик задержки, который равен величине каждого отдельного временного интервала. при уменьшении счетчика обратного отсчета, если станция обнаруживает занятый канал, она останавливает процесс уменьшения и возобновляет его до тех пор, пока не обнаружит незанятый канал в течение периода difs. когда счетчик достигает нуля, пакет выбрасывается в эфир. пакеты имеют фиксированный размер l - бит, и передача пакета плюс связанное с ним сообщение обратной связи соответствует продолжительности интервала. в идеале время передачи пакета является переменным, но в данной работе для простоты оно постоянное, т.е. несколько из некоторых слотов. мы обозначаем через @xmath4, @xmath5, @xmath6 и @xmath7 случайные величины, соответствующие коэффициентам канала соответственно между @xmath0 и @xmath2; @xmath0 и @xmath3 ; @xmath1 и @xmath3 ; @xmath1 и @xmath2 с @xmath8, @xmath9, @xmath10 и @xmath11 их соответствующее распределение вероятностей. средняя вероятность сбоя декодирования в первичном пункте назначения @xmath2, связанном с молчащим вторичным источником, обозначается @xmath12, в то время как та же вероятность при передаче от вторичного источника равна @xmath13. аналогично, средняя вероятность сбоя декодирования во вторичном пункте назначения @xmath3, когда первичный источник молчит и передает, обозначается @xmath14 и @xmath15 соответственно.    протоколы управления, реализуемые основным пользователем, в значительной степени зависят от передачи данных вторичным пользователем, как обсуждалось в предыдущем параграфе. таким образом, это снижает производительность основного пользователя, и это справедливо и для вторичного пользователя. однако цель проектирования системы состоит в том, чтобы оптимизировать производительность вторичного пользователя, не нанося при этом вреда основному пользователю в некоторой степени. поэтому, получив обратную связь от основного пользователя, вторичный пользователь корректирует свою политику передачи. поступление пакета к основному пользователю спроектировано как пуассоновский процесс поступления с параметром @xmath16. состояние сети может быть смоделировано как однородный марковский процесс. два параметра (стадия возврата, значение счетчика), обозначаемые как ( b, c), описывают состояние пользователя, где @xmath17 может принимать любое значение от 0 до @xmath18. стадия возврата b варьируется от 1 до максимальной стадии возврата @xmath19. здесь @xmath19 - это максимальный предел повторных попыток. при сбое передачи основной пользователь пытается повторно передать каждый пакет не более @xmath19 раз. на каждом этапе обратного отсчета, если станция достигает состояния @xmath20 (т.е. значение счетчика обратного отсчета становится равным 0), станция отправит пакет. если в этот момент с некоторой вероятностью произойдет сбой передачи, основной пользователь переходит на более высокую стадию возврата @xmath21 с вероятностью @xmath22. если происходит успешная передача пакета, основной пользователь переходит в состояние ожидания @xmath23 (если в очереди нет ожидающих пакетов) или на начальную стадию возврата, выбрав некоторый счетчик отсрочки с вероятностью @xmath24. модель цепи Маркова первичного пользователя проиллюстрирована на рисунке [рис. : primmarkov ]. вторичный пользователь пробует каждый пакет только один раз, после передачи он переходит в состояние ожидания с некоторой вероятностью или выбирает счетчик отсрочки @xmath25 с вероятностью @xmath26 для следующего пакета. передача нового пакета из очереди. обратите внимание, что пакет вторичного пользователя считается отложенным или в очереди всегда есть один пакет. однако, чтобы соответствовать ограничению потери производительности первичного пользователя, вторичный пользователь должен хранить молчание, и поэтому мы ввели поддельную переменную @xmath27, т.е. скорость поступления пакетов вторичного пользователя. модель цепи Маркова для вторичного пользователя показана на рисунке [рис. : secmarkov ]. на обоих рисунках @xmath28 и @xmath29 являются функциями @xmath16 и @xmath27. подробные переходы состояний и стационарное распределение проблемы были пропущены в этой работе из-за нехватки места. цель этой работы - найти оптимальную стратегию для вторичного пользователя, ограничивающую потерю производительности основного пользователя. давайте определим функции затрат @xmath30 как средние затраты, понесенные марковским процессом в состоянии @xmath31, если выбрано действие @xmath32. обратите внимание, что @xmath33 представляет, что вторичный источник хранит молчание, а @xmath34 представляет выбор счетчика возврата из окна вторичного счетчика возврата, т.е. @xmath35 $ ]. и функция средней общей стоимости приводит к @xmath36\\ ] ] где @xmath37 - последовательность действий вторичного источника и @xmath38 это экзогенная случайная величина, которая не может быть получена мгновенно из-за специфического поведения протокола. например, если вторичный пользователь выбирает счетчик обратного отсчета @xmath25, он должен пройти через первые интервалы diffs и @xmath25 раз, прежде чем начать передачу. при прохождении через резервные интервалы передача может быть остановлена основным пользователем, что снижает общую пропускную способность по сравнению со случаем, когда передача не была остановлена. это также верно и для основного пользователя. более того, переменная состояния @xmath39 не является явной для вторичного пользователя, поскольку вторичный пользователь не знает, находится ли основной пользователь в стадии ожидания или в слоте ожидания ожидания. однако вторичный пользователь может ощутить присутствие основного пользователя, если основной пользователь передает в слоте. учитывая все эти проблемы, ниже были выведены наши высокоуровневые функции затрат. @xmath40 @xmath41 и @xmath42 - это мгновенная вычисленная пропускная способность вторичного пользователя, предполагающая, что вероятность сбоя передаваемого пакета равна @xmath43 и @xmath44 соответственно. как обсуждаетсякак указывалось ранее, @xmath44 и @xmath43 представляют собой вероятность сбоя передаваемого пакета вторичного пользователя, когда первичный пользователь передает и не передает соответственно. помимо этих двух случаев, @xmath45 - это просто пропускная способность вторичного пользователя с учетом текущего временного интервала, поскольку мы знаем, что очередь вторичного пользователя перегружена. при расчете пропускной способности учитывается простаивание в других временных интервалах передачи и отсрочки. @xmath46 и снова, @xmath47 можно интерпретировать как долю временных интервалов, в течение которых первичный источник не выполняет последнюю разрешенную передачу и пакет не будет доставлен, а @xmath48 - это доля временных интервалов, в течение которых первичный источник начинает обслуживание нового пакета. в этой статье мы определяем вероятность сбоя как среднее отношение отброшенных пакетов после повторной передачи @xmath19 к общему количеству отправленных новых пакетов, можно видеть, что @xmath49 эквивалентно вероятности сбоя пакетов первичного источника. затем задача оптимизации задается @xmath50 в @xcite показано, что задача оптимизации в уравнении [ eq : opt - prob ] решается путем формулирования задачи в виде линейной программы. параметры в формулировке были получены из стационарного распределения цепи Маркова. наконец, полученная оптимальная стратегия была обозначена вектором @xmath51. элементы этого вектора содержат долю времени, в течение которого вторичный пользователь хранит молчание, или с какой вероятностью он должен выбрать счетчик отказов из данного окна конфликта. решение требует небольшого перебора методом грубой силы с использованием некоторой стандартной политики, которая была проверена аналитически. автономное решение задачи оптимизации требует полного знания состояния @xmath39, которое соответствует индексу передачи и состоянию очереди первичного источника, а также знания вероятностей перехода и функций затрат. однако полное знание @xmath39 требует явного обмена информацией. мы устраняем это ограничение в два этапа. во-первых, предполагая, что вторичное устройство обладает информацией только о том, что можно непосредственно наблюдать о первичном, и, во-вторых, используя методику онлайн-обучения, которая изучает необходимые параметры, не требуя знания вероятностей перехода.    распознавая канал, основной пользователь не может мгновенно определить состояние канала, поскольку основной пользователь следует протоколу dcf. следовательно, нет способа получить информацию о состоянии основного пользователя, когда он находится в состоянии ожидания, т.е. очередь основного пользователя пуста. дополнительный пользователь может узнать, выполняет ли основной пользователь передачу в определенном интервале, определив канал. в некоторых случаях вторичный пользователь может получить информацию о том, является ли переданный пакет первичным пользователем новым или старым. заголовок содержит порядковый номер пакета, который увеличивается, если передаваемый пакет является новым, и остается неизменным, если это повторная передача. однако, когда повторно переданный пакет достигает своего максимального предела, у вторичного пользователя нет возможности узнать в следующем интервале, пройдет ли он еще один этап возврата со свежим пакетом, поскольку состояние буфера полностью неизвестно вторичному пользователю. несмотря на то, что основной пользователь может собрать такой небольшой объем информации, в предлагаемом решении дополнительный пользователь не полагается на эту информацию. скорее, предлагаемое решение зависит от простого бита, который указывает, удовлетворяется ли ограничение производительности основного пользователя в текущем временном интервале или нет. эта информация отправляется основным пользователем в виде резервной копии либо в подтверждении, либо в фактическом заголовке пакета. располагая этой информацией, вторичный пользователь регулирует свою стратегию передачи. в следующем разделе с помощью численных результатов показано, что такого частичного знания достаточно для реализации алгоритма обучения, работающего близко к пределу, обеспечиваемому полным знанием состояния. обратите внимание, что здесь не учитывается состояние основного пользователя, это не помогает в процессе принятия решений вторичным пользователем. скорее, функции затрат являются наиболее важным движущим фактором предлагаемого онлайн-алгоритма. большинство подходов к оптимальному управлению требуют знания лежащей в основе вероятностной модели динамики системы, что требует принятия определенных допущений, и это влечет за собой отдельный этап оценки параметров модели. в частности, в нашей парадигме оптимизации @xcite оптимальная рандомизированная стационарная политика может быть найдена, если вероятности сбоя @xmath52, @xmath53, @xmath43, @xmath44 известны вторичному пользователю вместе с некоторыми знаниями о состоянии @xmath54. в этом разделе мы опишем, как мы можем использовать адаптивный алгоритм обучения под названием q - learning @xcite для поиска оптимальной политики без априорных знаний о нашей вероятностной модели. алгоритм q - learning - это долгосрочный метод обучения с подкреплением средним вознаграждением. это работает путем изучения функции значения действия @xmath55, которая дает ожидаемую полезность выполнения данного действия @xmath56 в заданном состоянии @xmath54 и последующего следования фиксированной политике. интуитивно q - функция отражает относительную стоимость выбора конкретного распределения для следующего временного шага в данном состоянии, предполагая, что для всех будущих временных шагов используется оптимальная политика. q - обучение основано на адаптивном итеративном изучении q-факторов. однако, как обсуждалось ранее, практически невозможно узнать информацию о текущем состоянии основного пользователя, и, таким образом, он игнорирует текущее состояние @xmath39 при изучении системы и поведенческих параметров основного пользователя. поскольку вторичный пользователь игнорирует текущее состояние @xmath39 при выполнении любого действия, мы можем назвать это вариантом марковского процесса принятия решений (mdp). исходный mdp означает, что агент выполняет действие на основе текущего состояния среды. независимо от того, следует ли вторичный пользователь mdp или варианту mdp, ему необходимо зафиксировать функцию затрат, которая обычно называется вознаграждением. конечная награда вторичного пользователя - это его собственная пропускная способность, т.е. @xmath57, которую он хочет максимизировать. однако, чтобы максимизировать пропускную способность, мы применили некоторый косвенный подход для получения максимального значения @xmath57. функция стоимости связана с действием вторичного пользователя. вероятность каждого действия вторичного пользователя содержится в векторе @xmath58 $ ]. длина этого вектора равна @xmath59 ( @xmath60 - размер окна отката вторичного пользователя). индекс @xmath61 обозначает долю времени, в течение которого вторичный пользователь хранит молчание, последующие индексы @xmath62 обозначают часть времени отката счетчик @xmath63 выбирается дополнительным пользователем. как обсуждалось ранее, результат действия вторичного пользователя не получается мгновенно до тех пор, пока вторичный пользователь не получит его передачу. из-за взаимодействия вторичного и первичного пользователей полученная пропускная способность от каждого действия меняется, и наша функция затрат представляет собой полученную среднюю пропускную способность (добавленную к долгосрочной средней пропускной способности), полученную в результате предпринятого действия. пусть @xmath64 - это средняя пропускная способность вторичного пользователя при выполнении действия @xmath56, а @xmath65 - это средняя пропускная способность, когда вторичный пользователь действительно завершает передачу своего пакета. тогда функция затрат во время @xmath66 определяется следующим образом: @xmath67 и наша задача оптимизации, таким образом, сводится к @xmath68\\ ] ], а алгоритм q - обучения для решения уравнения [ eq : opt ] проиллюстрирован следующим образом. * * шаг 1: * задайте временной шаг @xmath69. инициализируйте каждый элемент вектора вознаграждения @xmath70 как некоторое небольшое число, например 0. * * шаг 2: * проверьте, выполнено ли ограничение основного пользователя. если нет, выберите действие из @xmath33. в противном случае выберите действие @xmath56 с индексом @xmath71 $ ], которое имеет наибольшее значение @xmath72 с некоторой вероятностью, скажем, @xmath73, иначе пусть @xmath56 будет случайным исследовательским действием. другими словами, + @xmath74 * * шаг 3: * выполните действие @xmath75. дождитесь, пока дополнительный пользователь завершит передачу, если он выберет какой-либо счетчик отсрочки. или дополнительный пользователь может выбрать вариант молчания. в любом случае вычислите функцию затрат @xmath76 и обновите переменную вознаграждения за соответствующее действие. если текущее состояние равно @xmath54, а результирующее состояние равно @xmath77 после выполнения действия @xmath75, вознаграждение обновляется следующим образом. + @xmath78 * * шаг 4: * установите текущее состояние как @xmath77 и повторите шаг 2. когда конвергенция будет достигнута, установите @xmath79. это типичный алгоритм q - обучения. в нашем случае мы не знаем точного текущего состояния основного пользователя, а также не знаем, каким будет следующее состояние. следовательно, уравнение [ eq : q - learning ] сводится к @xmath80, чтобы получить оптимальное значение @xmath81, мы нашли следующую теорему. * теорема 1: * параметр размера шага @xmath82 обеспечивает сходимость алгоритма. * доказательство: * выбор @xmath82 приводит к методу усреднения по выборке, который гарантированно сходится к истинным значениям действия по закону больших чисел. хорошо известный результат в теории стохастической аппроксимации дает нам условия, необходимые для обеспечения сходимости с вероятностью 1: @xmath83 первое условие требуется для гарантии того, что шаги достаточно велики, чтобы в конечном итоге преодолеть любые начальные условия или случайные флуктуации. второе условие гарантирует, что в конечном итоге шаги станут достаточно малыми, чтобы обеспечить сходимость. обратите внимание, что оба условия сходимости выполняются для случая со средним значением по выборке, @xmath82. в этом разделе мы оценим производительность нашего онлайн-алгоритма. Кроме того, мы сравнили производительность этого алгоритма с алгоритмом, который содержит некоторую информацию об основном пользователе, представленную в нашей работе @xcite. на протяжении всего моделирования мы предполагаем, что размер буфера первичного источника равен @xmath84, а максимальное время повторной передачи равно @xmath85. размер окна возврата на каждом этапе равен 4, 6, 8 и 10 соответственно. размер окна отката для вторичного пользователя равен @xmath86. мы устанавливаем значение failопределите вероятности передачи первичного источника @xmath87, @xmath88, в зависимости от того, отключен вторичный источник или нет, соответственно. аналогично, вероятности сбоев вторичного источника устанавливаются равными @xmath89. Обратите внимание, что эти вероятности сбоев неизвестны во вторичном источнике, и он должен изучить оптимальную политику без каких-либо предположений об этих параметрах заранее. еще раз, целью алгоритма является максимизация пропускной способности вторичного источника.     и рисунок @xmath90 [рис. : thrput - конвергенция ] показывает конвергенцию пропускной способности вторичного и первичного пользователей от 0-й итерации до некоторого числа итераций. потеря пропускной способности определяется как разница между максимально достижимой пропускной способностью и мгновенной пропускной способностью в определенном интервале. исходя из приведенных параметров, максимально достижимая пропускная способность рассчитывается с учетом того, что на канале работает только один пользователь (первичный или вторичный). мы видим, что снижение пропускной способности происходит после нескольких итераций. и @xmath90 чтобы экстраполировать функции затрат нашего алгоритма, мы также показали процесс сходимости двух действий, выбранных вторичным пользователем, т.е. вероятность выбора счетчика отката 0 и 1 соответственно на рисунке [рис. : вознаграждение - сходимость]. мы инициализировали стоимость всех действий во времени слот нулевой. по мере продвижения алгоритма со временем он обновляет свое среднее вознаграждение в соответствии с формулой, представленной в алгоритме. алгоритм более склонен выбирать счетчик отката с меньшим значением, которое будет показано на последующих рисунках. однако, с точки зрения общего правила, алгоритм не выбирает одно и то же действие повторно. это связано с тем, что из-за взаимодействия между первичным и вторичным пользователями повторное действие может привести к снижению производительности основного пользователя или к снижению его собственного среднего значения вознаграждения по сравнению с другими действиями. следовательно, алгоритм переходит к другому действию, и среднее значение вознаграждения за разные действия с течением времени выглядит одинаково.    ] рисунок [ fig : secthrput - сравнение ] показывает пропускную способность первичного и вторичного источника с увеличенной скоростью поступления пакетов @xmath16 при фиксированной допустимой потере пропускной способности первичного источника. как и ожидалось, пропускная способность вторичного источника уменьшается по мере постепенного увеличения @xmath16. больший @xmath16 означает, что первичный источник чаще обращается к каналу. следовательно, количество интервалов, в которых вторичный источник может осуществлять передачу при соблюдении ограничения на потерю пропускной способности первичного источника, уменьшается. кроме того, на этом рисунке мы спроецировали результат, полученный с помощью нашего оптимального алгоритма @xcite. оптимальный алгоритм, хотя из-за поведения протокола не полностью осведомлен о состоянии системы, обладает некоторой лучшей информацией, чем предлагаемый нами онлайн-алгоритм. следовательно, он обеспечивает лучшую производительность с точки зрения достижимой пропускной способности при другом значении @xmath16. принимая во внимание, что наш онлайн-алгоритм, хотя и не выглядит так, как будто он обладает аналогичной производительностью, но получает ее лучше, чем другой слепой универсальный алгоритм. общий алгоритм означает, что здесь вторичный пользователь выбирает свой счетчик отката равномерно. при этой стратегии мы видим, что производительность для вторичного пользователя наихудшая. еще худшая новость заключается в том, что этот алгоритм полностью игнорирует ограничения производительности основного пользователя.    ] рисунок [ рис. : secstrategy - сравнение ] сравнивает полученную стратегию вторичного пользователя как для наших оптимальных, так и для онлайн-алгоритмов. мы представили долю незанятых слотов и вероятность выбора счетчика возврата 0. ради ограничения страницы мы пропустили здесь другие результаты. в этом результате, по-видимому, мы не видим никакого соответствия между двумя алгоритмами. однако мы можем объяснить разницу. фактически, онлайн-алгоритм в основном зависит от основного индикатора нарушения производительности пользователя и своего собственного значения вознаграждения за различные действия. он пытается выбрать действие с максимальным значением, которым обычно является счетчик отката с меньшим значением. в противном случае, при сигнале о нарушении ограничения, он хранит молчание. таким образом, мы видим, что онлайн-алгоритм придает больший вес откату с меньшим значением, и снова счетчик отката с меньшим значением чаще нарушает ограничение и, таким образом, сохраняет больше молчания, чем автономный алгоритм. принимая во внимание, что оптимальный алгоритм знает частоту прихода первичного пользователя, он запускает алгоритм, близкий к перебору, чтобы найти оптимальную стратегию вторичного пользователя. мы предложили подход к онлайн-обучению для снижения помех в сетях, основанных на стандарте ieee 802.11, для когнитивного пользователя. наш подход основан только на небольшой обратной связи о нарушении производительности первичного передатчика и использует q - learning для достижения почти оптимальных политик управления вторичным передатчиком. численное моделирование показывает, что этот подход обеспечивает производительность, близкую к производительности системы, когда известна полная информация о состоянии системы. хотя стратегия обоих алгоритмов не следует в точности схожей тенденции. 

традиционная концепция когнитивного радио заключается в совместном использовании первичного и вторичного пользователей в мультиплексированном режиме. мы рассматриваем схему оппортунистического доступа к каналу в сетях на базе стандарта ieee 802.11 с учетом сценария снижения помех. согласно правилу протокола и из-за ограничения на передачу сообщений, вторичный пользователь не знает о точном состоянии основного пользователя. в этой статье мы предложили онлайн-алгоритм для вторичного пользователя, который помогает определить счетчик задержки или решение о бездействии для использования временного / частотного интервала, незанятого основным пользователем. предлагаемый алгоритм основан на традиционной технике обучения с подкреплением, а именно q - learning. было проведено моделирование, чтобы доказать эффективность этого алгоритма, а также результаты были сопоставлены с нашим современным решением этой проблемы, в котором вторичный пользователь осведомлен о некоторых состояниях основного пользователя.    когнитивное радио, ism-диапазон, обучение с подкреплением, оптимизация, q - learning