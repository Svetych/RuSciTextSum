информация, закодированная в кубитах, может быть использована для надежной квантовой связи или эффективных квантовых вычислений @xcite. эта информация закодирована в квантовом состоянии @xmath4, которое в случае кубита может быть параметризовано как |(,)= |0 + e^i |1 ; [ 1 ] где @xmath5 и @xmath6 являются базисными векторами 2-мерного пространства кубита и @xmath7 ; @xmath8. кубиты очень хрупки, то есть состояние кубита может быть легко изменено под влиянием окружающей среды или случайной ошибки. одним (очень неэффективным) способом защиты квантовой информации, закодированной в кубите, является ее измерение. с помощью оптимального измерения можно оценить состояние кубита со средней точностью, равной 2/3 (см. ниже). таким образом, квантовая информация преобразуется в классическую информацию, которая может храниться, копироваться и обрабатываться в соответствии с законами классической физики со сколь угодно высокой точностью. однако для того, чтобы использовать весь потенциал квантовой обработки информации, мы должны сохранять информацию в состояниях квантовых систем, но тогда мы вынуждены сталкиваться с проблемой декогеренции. недавно было высказано предположение, что квантовая информация и квантовая обработка информации могут быть стабилизированы с помощью симметризации @xcite. в частности, кубит в неизвестном состоянии запутан с набором кубитов @xmath1 (вспомогательных) в определенном эталонном состоянии (скажем, @xmath5 ), поэтому симметричное состояние @xmath9 из @xmath10 кубитов, |(|,0 ,0+|0,, ,0+ + |0,0, ), генерируется [ 2 ]. если мы введем обозначение для полностью симметричных состояний @xmath11 кубитов @xmath10, причем @xmath12 из них находится в состоянии @xmath6, а @xmath13 из них - в состоянии @xmath5, то состояние ( [ 2 ] ) может быть выражено в простой форме |(,|)= |n;0 + e^i| |n;1[3 ], где параметры @xmath14 и @xmath15 задаются соотношениями = ; [ 4 ] и @xmath16, в то время как @xmath17. мы видим, что симметричное состояние кубита @xmath10 @xmath18 изоморфно состоянию одного кубита. но в этом случае информация распределяется между запутанными кубитами @xmath10 - исходная квантовая информация `разбавляется\". каждый из кубитов состояния @xmath10-кубит ( [ 3 ] ) находится в состоянии @xmath19. мы определяем среднюю точность между единичным состоянием @xmath20 и исходным кубитом @xmath21 как = d(;)|_j(,| ) |(;)[5 ] где @xmath22 - инвариантная мера в пространстве состояний исходного кубита (т.е. мы предполагаем отсутствие _ априорных _ знаний о чистом состоянии @xmath21 ). для этой точности мы находим выражение _ 0 =. [ 5a ] мы видим, что для @xmath23 точность @xmath24 равна единице (как и должно быть, потому что в данном случае @xmath25 ), в то время как в пределе @xmath26 мы находим @xmath27. фактически, в этом пределе операторы плотности отдельных кубитов приблизительно равны @xmath28. другими словами, по отдельности кубиты симметричного состояния @xmath18 в большом пределе @xmath10 не несут никакой информации об исходном однокубитном состоянии @xmath29. итак, как мы можем извлечь информацию из симметричного состояния @xmath10-кубита ( [ 3 ] )? идеальной возможностью было бы иметь идеальный _ universal _ распутыватель, который выполнял бы унитарное преобразование типа распутывающего преобразования @xcite.    хотя идеальное преобразование невозможно, есть ряд вещей, которые мы можем сделать, чтобы сконцентрировать информацию из состояния @xmath10-кубита @xmath18 обратно в один кубит. в принципе, у нас есть следующие возможности: * i ) * мы можем либо оптимально измерить состояние кубита @xmath10 и на основе полученной информации подготовить состояние с одним кубитом. * ii ) * мы можем спроектировать квантовый распутыватель, который выполнял бы преобразование, максимально приближенное к идеальному распутыванию ( [ 7 ] ). в этом квантовом сценарии у нас есть несколько вариантов - процесс распутывания может зависеть от входного состояния. это означает, что состояния ( [ 3 ] ) для некоторых значений параметров @xmath14 и @xmath30 будут распутаны лучше, чем для других значений этих параметров. в качестве альтернативы мы можем сконструировать квантовое устройство, которое распутывает все состояния с одинаковой точностью. * iii ) * наконец, мы предлагаем вероятностный распутыватель, такой, что когда на выходе выполняется конкретное проективное измерение над вспомогательным устройством, генерируется желаемое состояние с одним кубитом. вероятность результата измерения в этом случае зависит от состояния. в дальнейшем мы исследуем все эти возможности.    прежде чем продолжить, отметим, что Терно и мор @xcite - @xcite рассмотрели другой тип распутывателя. они рассмотрели две разные операции. первый взял бы состояние двудольной квантовой системы и преобразовал его в состояние, которое является просто произведением матриц уменьшенной плотности двух подсистем. второй, который является обобщением первого, снова начинался бы с состояния двухчастичной квантовой системы и отображал бы ее в разделимое состояние, которое имеет те же матрицы уменьшенной плотности, что и исходное состояние. они показали, что, хотя оба эти процесса невозможны в целом, они могут быть реализованы для определенных наборов входных состояний. приближенный распутыватель первого типа был рассмотрен бандьопадхьяем и др. @xcite. рассматриваемые нами распутывающие устройства извлекают, с некоторой степенью приближения, неизвестное состояние из запутанного состояния, сформированного из этого состояния и известного состояния. здесь мы сначала опишем сценарий измерения, использующий набор конкретных проекционных операторов. затем мы представляем оптимальный подход к квантовому распутыванию, основанный на измерениях, и выводим верхнюю границу точности распутывающего устройства, основанного на измерениях. мы используем тот факт, что система кубитов @xmath10, подготовленная в состоянии @xmath18, изоморфна одному кубиту. поэтому сначала мы рассмотрим стратегию, основанную на проективном измерении с двумя проекторами @xcite @xmath31 (@xmath32) с |_0(,)&= & @xmath33 и @xmath34, где углы @xmath35 и @xmath36 выбираются случайным образом, если нет _ предварительной _ информации об измеренном @xmath10-доступно состояние кубита. мы можем использовать результат измерения для создания состояния с одним кубитом. в частности, если результат измерения положительный для @xmath37, то одиночный кубит подготавливается в состоянии @xmath38, затем одиночный кубит подготавливается в ортогональном состоянии @xmath39. для конкретной ориентации измерительного устройства (т.е. углов @xmath40) этот основанный на измерениях сценарий дает нам один кубит, подготовленный в состоянии, описываемом оператором плотности ^(meas ) (, |;,)= _ j=0 ^ 1 ||_j|^2 |_j_j| [ 9 ] после усреднения по всем возможным ориентациям измерительного устройства мы получаем в среднем один кубит, подготовленный в состоянии ^(est ) (, |)= |(,|)(,|)| +. [ 10 ] чтобы найти среднюю точность этого основанного на измерениях распутывания процедура, с помощью которой мы должны оценить среднюю точность @xmath41, то есть перекрытие между состоянием ( [ 10 ] ) и исходным входным состоянием @xmath42, усредненное по всем возможным ориентациям входного кубита: _ 1 = d (,)|^(est ) (, |)| (, ). [ 11 ] принимая во внимание соотношение ( [ 4 ] ), мы выполняем интегрирование в уравнении ([11 ] ) и находим _ 1 = ( 1+f_n ) [ 12 ], где функция @xmath43 считывает f_n=. [ 6 ] для @xmath23 : @xmath44, что является оптимальной точностью оценки состояния отдельного кубита. из рис. [ рис. 1 ] мы видим, что точность ( [ 12 ] ) является убывающей функцией @xmath10, а в пределе @xmath45 мы находим @xmath46, который равен точности _ случайного _ предположения, связанного с двоичной системой, такой как два рассматриваемых проектора. другими словами, когда исходный кубит растворяется в бесконечном состоянии кубита вида ( [ 3 ] ), из измерения нельзя получить никакой релевантной информации. оператор расчетной плотности ( [ 10 ] ) в этом случае просто равен @xmath47, что понятно, потому что, как мы показали ранее в этом пределе, состояние @xmath10-кубита приблизительно соответствует состоянию @xmath48, поэтому информация об оригинале `почти\" полностью теряется. теперь мы хотим найти верхнюю границу @xmath49 для средней точности, которая может быть достигнута с помощью широкого класса процедур распутывания, основанных на измерениях. мы предполагаем, что априори известно, что наш @xmath10-кубит подготовлен в симметричном состоянии ( [ 2 ] ) с неизвестными параметрами @xmath50 и @xmath51, связанными с состоянием с одним кубитом ( [ 1 ] ). мера интегрирования в пространстве состояний отдельного кубита равна @xmath52, и соответствующее распределение плотности вероятности в этом пространстве состояний является постоянным.    наша стратегия заключается в измерении входного состояния @xmath9 вдоль вектора @xmath53 [ см. уравнение. ( [ 8 ] ) ], где углы @xmath54 и @xmath55 выбраны в соответствии с распределением @xmath56, которое на данный момент будет оставлено неопределенным. если ответ положительный, мы создаем выходную матрицу плотности @xmath57, а если она отрицательная, мы создаем @xmath58, где @xmath59 с @xmath32 и @xmath60, заданными уравнением. ( [ 8a ] ). мы также оставим условные вероятности @xmath61 неопределенными, поскольку это позволяет нам рассматривать широкий спектр стратегий. для фиксированного @xmath53 вероятность того, что результат будет @xmath57, равна @xmath62, а вероятность того, что он будет @xmath58, равна @xmath63. усредняя по всем векторам, @xmath64 выдает нам ^(out)(,| ) & = & d^[|_0| & + & |_1 ||^2_1(^,^ ) ] q(^, ^ ). чтобы найти среднюю точность выходных данных, полученных с помощью этой процедуры, мы вычисляем точность для конкретного входного состояния и усредняем по входному ансамблю @xmath65, где @xmath14 является функцией @xmath50 [ см. уравнение([4 ] ) ]. это может быть выражено как @xmath66, где @xmath67 - это нормализованное совместное распределение вероятностей, а @xmath68, где @xmath69 и максимальное значение берутся по переменным @xmath70. затем мы получаем, что @xmath71, \\ ] ] где верхняя граница теперь принимается за @xmath72 и @xmath73. чтобы вычислить эту верхнюю границу, мы должны найти explicit выражения для @xmath74 и @xmath75. после выполнения необходимых вычислений мы находим для @xmath49 выражение ^max=. эта точность для @xmath23 равна 2/3, в то время как в пределе @xmath26 равна 1/2. для любого другого @xmath10 больше, чем точность @xmath41 измерения, заданного уравнением ([12 ] ), как обсуждалось в нашем предыдущем примере. тем не менее, как мы покажем позже, это всегда меньше точности универсального квантового устройства. далее мы покажем, что квантовый распутыватель, который сохраняет квантовые когерентности, может преобразовать информацию обратно в один кубит более эффективно, чем метод, основанный на измерениях. как мы уже говорили во введении, квантовая механика не позволяет построить идеальный распутыватель, который выполнял бы преобразование ( [7 ] ) для произвольного (неизвестного) состояния @xmath42, растворенного в симметричном состоянии кубита @xmath10 ( [ 3 ] ). тем не менее, мы можем попытаться спроектировать оптимальные распутыватели которые лучше всего работают при заданных ограничениях. итак, давайте предположим, что наш квантовый распутыватель, @xmath76, представляет собой квантовую систему с @xmath77-мерным гильбертовым пространством, охватываемым базисными векторами @xmath78 ( @xmath79 ). распутыватель всегда изначально подготавливается в состоянии @xmath80, а затем он взаимодействует с системой @xmath10-кубитов в состоянии ( [ 3 ] ). на выходе мы хотим отделить вспомогательные кубиты @xmath1 от исходного кубита, поэтому мы ожидаем получить |(,|)|d_0|n-1;0_k=1^k _ j=0 ^ 1 c_j(,| ) |j|d_k. [ 13 ] как видно из уравнения ([13 ] ) во время процесса распутывания запутанность между вспомогательными кубитами @xmath1 и исходным кубитом переносится (заменяется местами) в запутанность между исходным кубитом и самим распутывателем. проследив за распутывателем, мы затем ожидаем получить наилучший из возможных распутанных кубитов в состоянии @xmath81. теперь мы накладываем несколько ограничений, которые определяли бы, что мы подразумеваем под оптимальным ковариантным (универсальным) распутывателем: точность между выводом распутывателя и исходным состоянием @xmath42 должна быть инвариантной относительно поворотов исходного кубита, поэтому точность должна быть независимой от входного состояния. эта универсальность распутывателя гарантировала бы, что информация из симметричного состояния ( [ 3 ] ) извлекается для всех состояний одинаково хорошо. мы ищем _ оптимальный _ распутыватель, который бы распутывал информацию с наивысшей точностью.    накладывая эти два условия, мы нашли унитарное преобразование, которое реализует _ оптимальный ковариантный _ распутыватель, т.е. которое отделяет состояние кубита @xmath29 от состояния кубита @xmath10 @xmath9 оптимальным и независимым от состояния @xmath29 способом (см. приложение). этот распутыватель описывается преобразованием : |n;0|d_0 & & |n-1;0 ; + базисные векторы распутывателя. амплитуды @xmath82 и @xmath83 задаются соотношением _ n=()^1/2 ; _ n=. [ 15 ] мы можем напрямую проверить, что точность @xmath84 не зависит от состояния ввода и равна @xmath85. более того, можно показать, что преобразование ( [ 15 ] ) является оптимальным, т.е. среди всех унитарных преобразований, удовлетворяющих заданным условиям, преобразование ( [ 15 ] ) обладает наибольшей точностью. мы видим, что для @xmath23 точность @xmath86, что очевидно, потому что исходный кубит не был перепутан с вспомогательными кубитами. мы строим график @xmath87 на рис. мы видим, что это _ всегда _ больше, чем точность распутывания с помощью измерения. в пределе @xmath26 даже квантовый распутыватель дает нам совершенно случайный результат. таким образом, в этом пределе даже оптимальный квантовый запутыватель, на который мы накладываем условие универсальности, не способен извлекать информацию из состояния ( [3 ]). это один из главных результатов нашей работы - оптимальный ковариантный квантовый распутыватель работает лучше, чем если бы информация была извлечена (распутана, дистиллирована ) из симметричного состояния ( [ 3 ] ) с помощью оптимального измерения. это связано с тем, что @xmath88. можно также задать противоположный вопрос, как мы можем сгенерировать из кубита в неизвестном состоянии @xmath29 симметричное состояние вида ( [ 3 ] ). можно показать, что в рамках квантовой механики совершенных универсальных запутывающих устройств, которые реализовывали бы обратное соотношение ([ 7 ]), не существует. если кто-то хочет создать состояние ( [ 3 ] ) из кубита в неизвестном состоянии и вспомогательных кубитов @xmath1 в известном состоянии @xmath5, снова возможны два сценария: основанный на измерениях и квантовый сценарий. неудивительно, что квантовый сценарий работает лучше. мы нашли оптимальный универсальный (ковариантный относительно поворотов входного кубита) квантовый запутыватель, заданный преобразованиями: |0|n-1;0|e_0 & & ; + базисные состояния квантового запутывателя, @xmath89 - его начальное состояние, а параметры @xmath90 и @xmath83 являются задано уравнением([15 ] ). можно проверить, что точность между выходными данными этого запутывателя, описываемого оператором плотности @xmath91, и идеально запутанным состоянием ( [ 3 ] ) не зависит от входного состояния (т.е. не зависит от параметров @xmath92 ) и равно @xmath93. это наилучший из возможных универсальных (ковариантных) запутывателей. универсальный распутыватель обеспечивает более высокую точность, чем лучшая процедура, основанная на измерениях, но не очевидно, что это лучшее, что можно сделать. в случае квантового клонирования универсальные клонеры - это те, которые максимизируют среднюю точность @xcite. однако, как мы увидим, в случае с распутывателями это уже не так; существуют устройства, зависящие от состояния, которые лучше. рассмотрим общее преобразование распутывателя @xmath94, являются состояниями самого распутывателя и не обязательно должны быть ортогональными. однако они должны удовлетворять ограничениям, налагаемым унитарностью вышеупомянутого преобразования. предполагается, что входным состоянием устройства является @xmath95, а идеальным выходным состоянием, с которым следует сравнивать фактический выходной сигнал, является @xmath96. выходное состояние вычисляется, начиная с входного состояния, используя приведенное выше преобразование, а затем прослеживая по распутывателю, чтобы получить выходную матрицу плотности, @xmath97. затем можно найти среднюю точность для этого процесса, который мы назовем @xmath98, из @xmath99 обратите внимание, что мы предполагаем определенный набор входных состояний; предполагается, что вероятность состояния с одним кубитом @xmath100 постоянна на сфере Блоха. наш результат для средней точности для устройства, зависящего от состояния, зависит от нашего выбора набора входных данных, в то время как для устройства, не зависящего от состояния, средняя точность не зависит от этого набора. расчет средней точности приведен в приложении и не будет подробно описан. мы находим, что @xmath101 и @xmath102. это подразумевает, что конечное состояние является просто произведением состояния частиц @xmath10 и состояния запутывания, что означает, что состояния запутывания могут быть исключены из задачи. следовательно, преобразование, которое максимизирует среднюю точность, является всего лишь своего рода преобразованием с заменой состояний. сама средняя точность задается @xmath103, где коэффициент @xmath43 задается уравнением([6 ] ). эта средняя точность больше, чем точность оптимального _ universal _ распутывателя (см. рис. 1).  [ рис. 1 ] ). в данном случае тот факт, что условие универсальности вынуждает нас использовать дополнительное квантовое устройство, распутыватель, с помощью которого кубит на выходе частично запутывается, приводит к чистой потере информации. в результате точность универсального (ковариантного) запутывателя меньше. аналогично, мы обнаруживаем, что квантовая запутанность, зависящая от состояния, также может быть выполнена с помощью своего рода преобразования с заменой состояний, т.е. |(,)|n;0/0 @xmath104. тем не менее, при усреднении по всем значениям @xmath105 мы обнаруживаем, что средняя точность этого зависящего от состояния запутывателя равна @xmath43, что в среднем больше, чем точность независимого от состояния запутывателя. давайте рассмотрим простую квантовую сеть, которая принимает в качестве входных данных состояние @xmath10-кубита ( [ 3 ] ). сеть состоит из последовательности элементов @xmath1 c - not @xmath106, где @xmath107 - это c - not, причем @xmath108 является управляющим битом, а @xmath12 - целевым битом. эта последовательность элементов c - not воздействует на два вектора @xmath109 и @xmath110 как [ 20 ] p_n|n;0 & & |n-1;0/0 + p_n |n;1 & & ( |n-1;1+|n-1;0 ) |1 из из чего следует, что входной вектор ( [ 3 ] ) преобразуется как |(,| ) & & ( |v_+| (, ) + & & + | v_-|0 ) [ 21 ], где @xmath111 - константа нормализации. в уравнении([21 ] ) мы ввели два ортогональных вектора кубитов @xmath1 @xmath112. измерение на первых кубитах @xmath1 выполняется для того, чтобы определить, находятся ли они в состоянии @xmath113 или @xmath114. если получен результат @xmath115, то @xmath10-й кубит находится в желаемом состоянии @xmath42. вероятность этого результата задается p_|v_+=. [ 23 ] эта вероятность зависит от состояния ввода и уменьшается с @xmath10.    существует разница между этим вероятностным процессом и рассмотренными ранее, такими как вероятностное клонирование @xcite. они работают только для конечного набора входных состояний. однако рассмотренный выше процесс работает для непрерывного и, следовательно, бесконечного набора входных состояний. фактически, это работает для всех входных состояний рассматриваемого нами типа. таким образом, мы можем заключить, что диапазон применимости вероятностных устройств зависит от рассматриваемого процесса. мы рассмотрели ряд различных методов извлечения неизвестного состояния из запутанного состояния, сформированного из этого состояния и известного состояния. измерение состояния, как и ожидалось, является наименее эффективным методом. в случае квантовых устройств универсальное устройство не было лучшим, по крайней мере, если в качестве критерия использовать среднюю точность. было замечено, что вероятностные квантовые устройства очень хорошо подходят для этой операции, поскольку их можно использовать для всего набор входных состояний. эта работа была поддержана Национальным научным фондом в рамках гранта phy-9970507, проектом ist equip по контракту ist-1999 - 11053 и crest, исследовательской группой по взаимодействующей карьерной электронике. давайте рассмотрим оптимальный квантовый распутыватель, который действует максимально близко к идеальному преобразованию ([ 7 ] ). распутыватель отображает пространство, охватываемое векторами @xmath116 и @xmath117, в пространство, охватываемое @xmath118 и @xmath119. это предполагает, что мы рассмотрим преобразование следующего вида @xmath120, где @xmath80 - начальное состояние распутывателя, которое должно быть одинаковым для всех входных данных и @xmath121 ( @xmath122 ) - это некоторые ненормализованные векторы состояний распутывателя. наша задача - определить эти векторы. унитарность немедленно подразумевает, что @xmath123 теперь мы будем использовать наши преобразования распутывателя (a.1 ) для вычисления точности фактического вывода по отношению к идеальному результату ( [ 7 ] ) входные данные распутывателя задаются уравнением. ( [ 3 ] ). если мы введем обозначения @xmath124 и @xmath125, мы можем записать результат преобразования ( a.1 ) @xmath126, теперь мы используем это выражение, чтобы найти выходную матрицу плотности и отследить сам распутыватель. мы определяем матрицу выходной плотности @xmath10-кубитов как @xmath127 точность вывода задается @xmath128, где @xmath129 задается уравнением. ( [ 7 ] ). если мы обозначим @xmath130 и @xmath131, мы можем выразить эту точность как @xmath132 \\nonumber \\\\ & + & \\alpha^{\\ast}\\beta \\langled_{3}|d_{4}\\rangle ) \\nonumber \\\\ & + & ( \\alpha^{\\ast})^{2}\\beta^{2}\\sqrt{n}\\langled_{2}| d_{3}\\rangle + \\alpha^{2}(\\beta^{\\ast})^{2}\\sqrt{n } \\langle d_{3}|d_{2}\\rangle \\}. \\label{a.5 } \\eqnum{a.5}\\end{выровнено}\\ ] ] требуя, чтобы точность не зависела от фаз @xmath133 и @xmath134, мы обнаруживаем, что @xmath135, предполагая, что эти условия выполняются, точность становится @xmath136 \\ }. \\nonumber\\end{выровнено}\\ ] ] для того, чтобы это не зависело от @xmath133 и @xmath134, термин в скобках должен быть пропорционален @xmath137 сравнивая уравнения. ( a.7 ) и ( a.8 ) мы находим, что @xmath138 объединяя эти требования с требованиями, налагаемыми унитарностью, мы приходим к выводу, что @xmath139 и @xmath140. это означает, что для того, чтобы максимизировать @xmath141, мы должны максимизировать @xmath142. наш первый шаг в достижении этого - отметить, что путем объединения результатов уравнений. (a.9 ) и ( a.10 ) мы получаем, что @xmath143, где @xmath144 и @xmath145. решая для @xmath142, мы находим, что @xmath146, который, предполагая @xmath147, является наибольшим, когда @xmath148. это означает, что @xmath149 и что @xmath150, накладывая теперь условия на внутренние продукты, мы обнаруживаем, что @xmath151 мы можем суммировать наши результаты следующим образом. пусть @xmath152 является набором из трех ортонормированных векторов и определяет два параметра @xmath82 и @xmath83, заданных уравнением. ( [ 15 ] ) тогда мы имеем, что @xmath153 и универсальное _ оптимальное _ распутывающее преобразование явно задаются уравнением. ( [ 14 ] ).      чтобы найти оптимальный распутыватель, зависящий от входного состояния, мы находим явную форму преобразования (a.1), такую, чтобы _ усредненная _ точность @xmath154 (с @xmath141, заданной уравнением ( a.5 ) ) была максимальной. здесь, как обычно, мерой интеграции является @xmath155. следовательно, после выполнения интеграла по фазе @xmath51 мы можем записать среднюю точность как @xmath156\\ } \\nonumber\\end{выровнено}\\ ] ] с [ a.18 ] _ 1&=&_0^ ^4 + _ 2 & = & _ 0^ ^4 + _ 3&=&_0^ ^2 ^2 после интегрирования по параметру @xmath50 мы находим [ a.19 ] _ 1&= & + _ 2&= & + _ 3&= & из унитарности распутывающего преобразования следует, что @xmath157 и @xmath158. когда мы вводим обозначение @xmath159, где @xmath160 и @xmath161 ; @xmath162, мы можем переписать среднюю точность (a.17 ) как & = & [ _ 1 n ( _ 1-_3 ) + _ 4(_2-_3 ) + & + & 2_3 u + _ 3(1+n ) ]. [ a.21 ] принимая во внимание, что @xmath163 и @xmath164, мы легко находим, что максимальная средняя точность (a.21) достигается для @xmath165 и @xmath166. в этом случае мы переписываем ( a.21 ) как = [ _ 1 n + _ 2 + 2 _ 3 ]. [ a.22 ], когда подставляем в уравнение ( a.22 ) явное выражение для параметров @xmath167, заданных уравнением.  ( a.19 ) мы находим, что средняя точность равна функции @xmath43, заданной уравнением. ( [ 6 ] ). это в точности равно средней точности распутывания входного состояния, выполняемого с помощью преобразования обмена состояниями, описанного уравнением. ( [ 18a ] ). на самом деле, из наших условий @xmath166 напрямую следует, что @xmath168 в то время как @xmath169. кроме того, из @xmath165 следует, что @xmath102, так что оптимальное зависящее от состояния распутывающее преобразование действительно равно уравнению. ( [ 18a ] ), что мы и хотели доказать.

невозможно выделить кубит в _ неизвестном _ состоянии @xmath0 из набора вспомогательных кубитов @xmath1, подготовленных в определенном эталонном состоянии @xmath2. то есть невозможно _ идеально _ выполнить преобразование @xmath3. тогда вопрос в том, насколько хорошо мы можем это сделать? мы рассмотрим ряд различных методов извлечения неизвестного состояния из запутанного состояния, сформированного из этого кубита и набора вспомогательных кубитов в известном состоянии. измерение всей системы, как и ожидалось, является наименее эффективным методом. мы представляем различные квантовые `устройства\", которые выделяют неизвестный кубит из множества вспомогательных кубитов. в частности, мы представляем _оптимальный универсальный _ распутыватель, который распутывает неизвестный кубит с точностью, которая не зависит от состояния кубита, и вероятностный распутыватель, который выполняет идеальное преобразование распутывания, но с вероятностью меньше единицы.    * номер pacs: 03.67.-a, 03.65.bz * 2