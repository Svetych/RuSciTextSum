информационно - теоретические исследования емкости и кодирования для памяти с ограничением записи берут свое начало в @xcite, @xcite, @xcite и @xcite. в @xcite авторы рассматривают модель памяти с однократной записью (wom). в частности, каждая ячейка памяти может находиться в состоянии либо 0, либо 1. состояние ячейки может изменяться от 0 до 1, но не от 1 обратно к 0 позже. эти биты однократной записи называются _wits_. показано, что эффективность хранения информации в wom может быть повышена, если разрешить многократную перезапись и тщательно разработать схему хранения/перезаписи. многоуровневая флэш-память - это технология хранения, при которой уровень заряда любой ячейки можно легко увеличить, но трудно уменьшить. новейшая технология многоуровневых ячеек позволяет сохранять в ячейке множество уровней заряда. ячейки организованы в блоки, содержащие примерно по 2 ячейки. единственный способ снизить уровень заряда ячейки - стереть весь блок (т.е. установить заряд во всех ячейках равным нулю) и перепрограммировать каждую ячейку. это требует времени, потребляет энергию и сокращает срок службы памяти. следовательно, важно разработать эффективные схемы перезаписи, которые максимизируют количество перезаписей между двумя стираниями @xcite, @xcite, @xcite, @xcite. схемы перезаписи увеличивают некоторые уровни заряда ячейки в зависимости от текущего состояния ячейки и сообщения, которое необходимо сохранить. в этой статье мы называем схему перезаписи кодом модуляции.    в предыдущей работе в основном рассматривались две различные целевые функции для кодов модуляции: (i) максимизация количества перезаписей для наихудшего случая @xcite и (ii ) максимизация для среднего случая @xcite. как finucane et al. Как упоминал @xcite, причиной рассмотрения средней производительности является эффект усреднения, вызванный большим количеством стираний в течение срока службы устройства флэш-памяти. наш анализ показывает, что цель наихудшего случая и цель среднего случая являются двумя крайними случаями нашей цели оптимизации. мы также обсудим, при каких условиях каждая мера оптимальности имеет смысл.    в предыдущей работе (например, @xcite) было показано, что многие коды модуляции являются асимптотически оптимальными, поскольку число уровней ячеек @xmath0 стремится к бесконечности. но условие, что @xmath1 не может быть выполнено в практических системах. поэтому мы также анализируем асимптотически оптимальные коды модуляции, когда @xmath0 только умеренно велик, используя результаты теории балансировки нагрузки @xcite. это предполагает усовершенствованный алгоритм, который значительно повышает производительность практической системы. теоретический анализ и результаты моделирования показывают, что этот алгоритм работает лучше, чем другие асимптотически оптимальные алгоритмы, когда @xmath0 умеренно велик. структура статьи следующая. модель системы и показатели оценки производительности обсуждаются в разделе [sec: мера оптимальности]. асимптотически оптимальный код модуляции, который универсален для произвольных распределений ввода-вывода, предлагается в разделе [sub : другой алгоритм перезаписи]. эффективность хранения этого асимптотически оптимального кода код модуляции анализируется в разделе [ sec : an - enhanced - algorithm ]. расширенный код модуляции также представлен в разделе [ sec : an - enhanced - algorithm ]. эффективность хранения расширенного алгоритма также анализируется в разделе [ sec : an - enhanced - algorithm ]. результаты моделирования и сравнения представлены в разделе [ sec : результаты моделирования]. статья завершается в разделе [ sec : заключение]. устройства флэш-памяти обычно полагаются на коды обнаружения/исправления ошибок для обеспечения низкой частоты ошибок. до сих пор практические системы, как правило, используют коды бозе - чаудхури - Хокенгема (bch) и Рида - Соломона (rs). коды с исправлением ошибок (ecc) используются в качестве внешних кодов, в то время как коды модуляции являются внутренними кодами. в этой статье мы сосредоточимся на кодах модуляции и пока проигнорируем шум и конструкцию ecc. давайте предположим, что блок содержит ячейки уровня @xmath3 @xmath0 и что ячейки @xmath4 (называемые ячейками @xmath4) используются вместе для хранения переменных @xmath5 @xmath6 (называемых переменными @xmath5). блок содержит @xmath7 @xmath4-ячейки, и предполагается, что переменные @xmath7 @xmath5 являются случайными величинами. мы предполагаем, что все переменные @xmath5 обновляются случайным образом одновременно, и новые значения сохраняются в соответствующих ячейках @xmath4. это разумное предположение в системе с внешним ecc. мы используем индекс @xmath8 для обозначения индекса времени, и каждая перезапись увеличивает @xmath8 на 1. когда мы обсуждаем код модуляции, мы фокусируемся на одной ячейке @xmath4. (кодировщик кода модуляции увеличивает некоторые уровни ячеек на основе текущих уровней ячеек и нового значения переменной @xmath5. ) помните, что уровни ячеек могут быть увеличены только во время перезаписи. таким образом, когда какой-либо уровень ячейки должен быть увеличен сверх максимального значения @xmath9, весь блок стирается и все уровни ячеек сбрасываются до нуля. мы допускаем, что максимально допустимое количество стираний блоков равно @xmath10, и предполагаем, что после стирания блоков @xmath10 устройство становится ненадежным. предположим, что переменная @xmath5, записанная во время @xmath8, является случайной величиной @xmath11, выбранной из набора @xmath12 с распределением @xmath13. для удобства мы также представляем переменную @xmath5 во время @xmath8 в векторной форме как @xmath14, где @xmath15 обозначает набор целых чисел по модулю @xmath6. вектор состояния ячейки в момент времени @xmath8 обозначается как @xmath16, а @xmath17 обозначает уровень заряда @xmath18-й ячейки в момент времени @xmath19 когда мы говорим @xmath20, мы имеем в виду @xmath21 для @xmath22, поскольку уровень заряда ячейки может быть только увеличен, непрерывное использование память подразумевает, что в какой-то момент потребуется удаление всего блока. хотя операции записи, чтения и стирания могут вносить шум в память, мы пренебрегаем этим и предполагаем, что операции записи, чтения и стирания не содержат шума. рассмотрите возможность записи информации во флэш-память, когда кодировщик знает предыдущее состояние ячейки @xmath23, текущую переменную @xmath5 @xmath24 и функцию кодирования @xmath25, которая сопоставляет @xmath24 и @xmath26 с новым вектором состояния ячейки @xmath27. декодер знает только текущее состояние ячейки @xmath27 и функцию декодирования @xmath28, которая отображает состояние ячейки @xmath27 обратно в переменный вектор @xmath29. конечно, функции кодирования и декодирования могут меняться со временем для повышения производительности, но мы рассматриваем только не зависящие от времени функции кодирования / декодирования для простоты. идея совместной разработки эффективных кодов модуляции для хранения множества переменных в нескольких ячейках была предложена Цзяном @xcite. в предыдущей работе по разработке кодов модуляции для флэш-памяти (например, @xcite, @xcite, @xcite, @xcite, @xcite) время жизни памяти (либо в наихудшем случае, либо в среднем) максимизируется при заданном фиксированном объеме информации на перезапись. повышение плотности хранения и продление срока службы устройства - две противоречащие друг другу цели. можно либо исправить одну и оптимизировать другую, либо оптимизировать эти две задачи совместно. в большинстве предыдущих работ (например, @xcite) используется первый подход, фиксирующий объем информации для каждой перезаписи и максимизирующий количество перезаписей между двумя удалениями. в этой статье мы рассматриваем последний подход, и наша цель состоит в том, чтобы максимизировать общий объем информации, хранящейся в устройстве, до тех пор, пока устройство не выйдет из строя. это эквивалентно максимизации среднего (по распределению переменных @xmath5 @xmath13 ) объема информации, хранящейся на уровне ячейки, @xmath30, где @xmath31 - объем информации, хранящейся при @xmath18-й перезаписи, @xmath32 - количество перезаписей между двумя стираниями и ожидаемое значение находится над распределением @xmath5-переменной. мы также называем @xmath33 как \"эффективность хранения\".      в предыдущей работе над кодами модуляции для флэш-памяти количество перезаписей ячейки @xmath4 было максимизировано двумя различными способами. авторы в @xcite рассматривают количество переписываний в наихудшем случае, а авторы в @xcite рассматривают среднее количество переписываний. как упоминалось в @xcite, причина рассмотрения среднего случая связана с большим количеством стираний в течение срока службы устройства флэш-памяти. интересно, что эти два соображения можно рассматривать как два крайних случая цели оптимизации в ( [ eq : opt ] ). пусть переменные @xmath5 представляют собой последовательность случайных величин с течением времени и все ячейки @xmath4. цель оптимизации - максимизировать объем информации, хранящейся до тех пор, пока устройство не выйдет из строя. общий объем информации, хранящейся в ячейке устройства, изменяется на то же значение, должно ли это считаться сохраненной информацией? должно ли это считаться перезаписью? эта формула предполагает, что она считается перезаписью, так что значения @xmath34 (а не @xmath35 ) могут сохраняться во время каждой перезаписи. ] может быть ограничено сверху @xmath36, где @xmath37 - это количество перезаписей между @xmath38-м и @xmath18-м стираниями. обратите внимание, что верхняя граница в ( [ eq : total_info_ub ] ) достижима при равномерном распределении входных данных, т.е. когда входная переменная @xmath5 равномерно распределена по @xmath39, каждая перезапись сохраняет @xmath40 бит информации. из-за свойства i.i.d. входных переменных с течением времени, @xmath37 являются i.i.d. случайными величинами с течением времени. поскольку @xmath37 - это i.i.d. со временем мы можем удалить индекс @xmath18. поскольку @xmath10, которое является максимально допустимым числом стираний, примерно равно @xmath41, по закону больших чисел (lln) у нас есть @xmath42k\\log_{2}(l).\\ ] ] пусть набор всех допустимых пар кодер/декодер равен @xmath43, где @xmath44 подразумевает, что уровни заряда поэлементно не уменьшаются. это позволяет нам рассматривать проблему @xmath45 как следующую эквивалентную проблему @xmath46k\\log_{2}(l).\\label{eq : opt2 - 1}\\ ] ] обозначаем максимальный уровень заряда @xmath18-го @xmath4-элемента в момент времени @xmath8 как @xmath47. обратите внимание, что индекс времени @xmath8 сбрасывается до нуля, когда происходит стирание блока.в противном случае значение d увеличивается на единицу при каждой перезаписи. обозначим максимальный уровень заряда в блоке в момент времени @xmath8 как @xmath48, который может быть вычислен как @xmath49, определим @xmath50 как время, когда @xmath18-я ячейка @xmath4 достигает своего максимально допустимого значения, т.е. @xmath51. мы предполагаем, возможно, наивно, что удаление блока требуется, когда любая ячейка внутри блока достигает своего максимально допустимого значения. время, когда требуется удаление блока, определяется как @xmath52 легко видеть, что @xmath53=ne\\left[t\\right],$ ], где ожидания превышают распределение переменных @xmath5. таким образом, максимизация @xmath54 $ ] эквивалентна максимизации @xmath55. таким образом, задача оптимизации ( [ eq : opt2 - 1 ] ) может быть записана как следующая задача оптимизации @xmath56.\\label{eq : opt3}\\ ] ] в предположении, что входные данные являются i.i.d. по всем @xmath4-ячейкам и временным индексам, можно найти что значения @xmath50 являются i.i.d. случайными величинами. пусть их общая функция плотности вероятности ( pdf) равна @xmath57 легко видеть, что @xmath58 - это минимум @xmath7, т.е. случайных величин с pdf @xmath57, следовательно, у нас есть @xmath59, где @xmath60 - функция кумулятивного распределения (cdf) @xmath61, таким образом, задача оптимизации ( [ eq : opt3 ] ) становится @xmath62=\\max_{f, g\\in\\mathcal{q}}\\int nf_{t}(x)\\left(1-f_{t}(x)\\right)^{n-1}x\\mbox{d}x.\\label{eq : opt}\\ ] ] обратите внимание, что при @xmath63 задача оптимизации в ( [ eq : opt ] ) упрощается до @xmath64.\\label{eq : opt2}\\ ] ] по сути, это тот случай, который рассматривают авторы в @xcite. когда весь блок используется как одна ячейка @xmath4 и допустимое количество стираний велико, оптимизация среднего (по всем входным последовательностям) количества перезаписей ячейки @xmath4 эквивалентна максимизации общего объема хранимой информации @xmath65 анализ также показывает, что причина, по которой мы рассматриваем средняя производительность обусловлена не только эффектом усреднения, вызванным большим количеством стираний. еще одно важное предположение заключается в том, что в каждом блоке есть только одна @xmath4-ячейка. другая крайность - это когда @xmath66 в этом случае pdf @xmath67 стремится к точечной массе при минимуме @xmath8, а интеграл @xmath68 приближается к минимуму @xmath8. это дает наихудшее время остановки процесса программирования ячейки @xmath4. этот случай рассматривается @xcite. наш анализ показывает, что мы должны учитывать наихудший случай, когда @xmath69, даже несмотря на то, что устройство испытывает большое количество стираний. таким образом, мера оптимальности определяется не только @xmath10, но и @xmath70. когда @xmath7 и @xmath10 велики, имеет смысл учитывать производительность в наихудшем случае. когда @xmath71, лучше учитывать среднюю производительность. когда @xmath7 умеренно велик, мы должны максимизировать количество перезаписей, используя ( [ eq : opt ] ), который уравновешивает худший вариант и средний вариант. когда @xmath7 умеренно велик, вероятно, следует сосредоточиться на оптимизации функции в ( [ eq : opt ] ), но неясно, как это сделать напрямую. итак, это остается открытой проблемой для будущих исследований. вместо этого мы рассмотрим подход к балансировке нагрузки для улучшения практических систем, в которых @xmath0 является умеренно большим. если мы предположим, что каждый раз изменяется только одна переменная, средний объем информации на уровне ячейки может быть ограничен @xmath72, потому что есть @xmath73 возможных новых значений. поскольку количество перезаписей может быть ограничено @xmath74, у нас есть @xmath75, если мы разрешим произвольное изменение переменных @xmath5, то полностью возможны новые значения @xmath76. можно показать, что @xmath77 для фиксированных @xmath6 и @xmath0, привязка в ( [ eq : storage_efficiency_bound ] ) предполагает, что использование большого @xmath5 может повысить эффективность хранения. это также является причиной того, что совместное кодирование в нескольких ячейках может повысить эффективность хранения @xcite. поскольку оптимальные схемы перезаписи позволяют увеличивать только один уровень ячейки на единицу во время каждой перезаписи, возможность декодирования подразумевает, что @xmath78 для первого случая и @xmath79 для второго случая. следовательно, границы в ( [ eq : storage_efficiency_bound2 ] ) и ( [ eq : storage_efficiency_bound ] ) также требуют большого @xmath4 для повышения эффективности хранения. верхняя граница в ( [ eq : storage_efficiency_bound ] ) растет линейно с @xmath5, в то время как верхняя граница в ( [ eq : storage_efficiency_bound2 ] ) растет логарифмически с @xmath5. поэтому в оставшейся части этой статьи мы предполагаем произвольное изменение переменной @xmath5 при каждой перезаписи и @xmath71, т.е. весь блок используется как ячейка @xmath4 для повышения эффективности хранения. этот подход неявно обменивает мгновенную емкость на будущую емкость хранилища, поскольку для хранения одного и того же количества бит используется больше ячеек, но ячейки также могут использоваться повторно гораздо большее количество раз. обратите внимание, что предположение @xmath71 может быть трудным для реальной реализации, но его анализ дает верхнюю границу эффективности хранения. из приведенного выше анализа с @xmath71 мы также знаем, что максимизация @xmath33 эквивалентна максимизации среднего числа перезаписей. в @xcite предлагаются коды модуляции, которые являются асимптотически оптимальными (поскольку @xmath0 стремится к бесконечности) в среднем смысле при @xmath80. в этом разделе мы представляем код модуляции, который является асимптотически оптимальным для произвольных распределений входных данных и произвольных @xmath5 и @xmath6. этот алгоритм перезаписи можно рассматривать как расширение алгоритма в @xcite. цель состоит в том, чтобы равномерно увеличить уровни ячеек в среднем для произвольного распределения входных данных. конечно, необходимо поддерживать возможность декодирования. решение заключается в использовании общей информации, известной как кодеру (для кодирования входного значения), так и декодеру (для обеспечения возможности декодирования), для рандомизации индекса ячейки с течением времени для каждого конкретного входного значения. давайте предположим, что переменная @xmath5 является постоянной случайной величиной во времени с произвольным распределением @xmath13, а переменная @xmath5 во время @xmath8 обозначается как @xmath81, выходные данные декодера обозначаются как @xmath82, мы выбираем @xmath83 и позволяем вектору состояния ячейки в момент времени @xmath8 будет @xmath84, где @xmath17 - это уровень заряда @xmath18-й ячейки в момент времени @xmath19 в @xmath85, переменные инициализируются как @xmath86, @xmath87 и @xmath88.    алгоритм декодирования @xmath89 описан следующим образом. * шаг 1: считайте вектор состояния ячейки @xmath27 и вычисляйте норму @xmath90 @xmath91. * шаг 2: вычислите @xmath92 и @xmath93 алгоритм кодирования @xmath94 описан следующим образом. * шаг 1: считайте состояние ячейки @xmath26 и вычисляйте @xmath95 и @xmath96, как указано выше. если @xmath97, то ничего не делайте. * шаг 2: вычислите @xmath98 и @xmath99 * шаг 3: увеличьте уровень заряда @xmath100-й ячейки на 1. для удобства в остальной части статьи мы называем приведенный выше алгоритм перезаписи `саморандомизированным кодом модуляции\". самослучайный код модуляции обеспечивает, по крайней мере, перезапись @xmath101 с высокой вероятностью, как @xmath102 для произвольного @xmath103 @xmath104 и распределения входных данных i.i.d. @xmath13. следовательно, он асимптотически оптимален для случайных входных данных в виде @xmath1. [набросок доказательства ] доказательство аналогично доказательству в @ xcite. поскольку уровень ровно одной ячейки увеличивается на 1 при каждой перезаписи, @xmath105 - это целочисленная последовательность, которая увеличивается на 1 при каждой перезаписи. индекс ячейки, который будет записан @xmath100, рандомизируется путем добавления значения @xmath106. это приводит к тому, что каждая последовательная последовательность перезаписей @xmath76 оказывает одинаковое влияние на все уровни ячеек. поскольку @xmath1, возможно неограниченное количество перезаписей, и мы можем предположить, что @xmath107. рассмотрим первые шаги @xmath108, значение @xmath109 настолько равно, насколько это возможно, по сравнению с @xmath110 для удобства мы говорим, что для каждого значения есть @xmath111 @xmath112 s, поскольку разница округления на 1 поглощается в члене @xmath113. предполагая, что входное распределение равно @xmath114. для случая, когда @xmath115, вероятность того, что @xmath116 равна @xmath117 для @xmath118. следовательно, @xmath119 имеет равномерное распределение по @xmath12. поскольку входные данные независимы во времени, применяя тот же аргумент с привязкой к Черноффу, что и @xcite, следует, что количество раз @xmath116 не превышает @xmath120 с высокой вероятностью (больше, чем @xmath121 ) для всех @xmath122. суммирование по @xmath122, мы заканчиваем доказательство. обратите внимание, что рандомизирующий термин @xmath105 является детерминированным термином, который заставляет @xmath100 выглядеть _ случайным _ с течением времени в том смысле, что для каждого значения существует одинаково много терминов. более того, @xmath105 известен как кодеру, так и декодеру, так что кодер может генерировать `однородные\" индексы ячеек с течением времени, а декодер знает накопленное значение @xmath105, он может вычесть его и правильно восстановить данные. хотя этот алгоритм асимптотически оптимален как @xmath1, максимальное количество перезаписей @xmath123 не может быть достигнуто для умеренного @xmath0. это мотивирует к анализу и разработке улучшенной версии этого алгоритма для практических систем в следующем разделе. код самораскрывающейся модуляции использует ячейки @xmath83 для хранения переменной @xmath5. это намного больше, чем @xmath124, используемое предыдущими асимптотически оптимальными алгоритмами, потому что мы позволяем переменной @xmath5 изменяться произвольно. хотя это кажется пустой тратой ячеек, средний объем информации, хранящейся на уровне ячейки, на самом деле максимизирован (см. ( [ eq : storage_efficiency_bound2 ] ) и ( [ eq : storage_efficiency_bound ] ) ). фактически, определение асимптотической оптимальности требует @xmath79, если мы допускаем произвольные изменения в @xmath5-переменная. мы отмечаем, что оптимальность саморандомизированных кодов модуляции аналогична слабым устойчивым кодам, представленным в @xcite. мы используем ячейки @xmath83 для хранения одного из возможных сообщений @xmath125. это немного хуже, чем простой метод использования @xmath126. возможно ли провести саморандомизацию, используя только ячейки @xmath126? предварительный анализ этого вопроса, основанный на теории групп, показывает, что это не так. таким образом, дополнительная ячейка обеспечиваетs возможность рандомизировать сопоставления между значениями сообщений и индексами ячеек с течением времени. в то время как асимптотически оптимальные коды модуляции (например, коды в @xcite, @xcite, @xcite, @xcite и саморандомизированные коды модуляции, описанные в разделе [ sec : другой алгоритм перезаписи ] ) требуют @xmath1, практические системы используют значения @xmath0 между @xmath127 и @xmath128. по сравнению с количество ячеек @xmath4, размер @xmath0 недостаточно велики для обеспечения асимптотической оптимальности. другими словами, асимптотически оптимальные коды могут иметь значительно неоптимальную производительность, когда системные параметры недостаточно велики. более того, разные асимптотически оптимальные коды могут работать по-разному, когда значение @xmath0 недостаточно велико. следовательно, асимптотическая оптимальность в данном случае может вводить в заблуждение. в этом разделе мы сначала анализируем эффективность хранения саморандомизированных кодов модуляции, когда @xmath0 недостаточно велик, а затем предлагаем усовершенствованный алгоритм, который значительно повышает эффективность хранения. прежде чем мы проанализируем эффективность хранения асимптотически оптимальных кодов модуляции для умеренно больших @xmath0, мы сначала покажем связь между процессом перезаписи и проблемой балансировки нагрузки (она же проблема шариков в ячейках или проблема шариков и ячеек), которая хорошо изучена в mathematics and computer science @xcite. по сути, задача балансировки нагрузки рассматривает, как распределить объекты по набору местоположений настолько равномерно, насколько это возможно. в частности, модель \"шары и корзины\" рассматривает следующую проблему. если шары @xmath129 брошены в ячейки @xmath4, причем каждый шар помещается в ячейку, выбранную независимо и равномерно случайным образом, определите _ load _ как количество шаров в ячейке, какова максимальная нагрузка на все ячейки? основываясь на результатах, приведенных в теореме 1 в @ xcite, мы используем более простой и менее точный подход к задаче о шариках в корзинах и приходим к следующей теореме.    [ thm : random_loading] предположим, что шары @xmath129 последовательно помещаются в ячейки @xmath4. каждый раз ячейка выбирается независимо и равномерно случайным образом. максимальная загрузка по всем ячейкам равна @xmath130 и : ( @xmath18 ) если @xmath131, то в максимально загруженной ячейке есть шары @xmath132, @xmath133 и @xmath134, с высокой вероятностью ( @xmath135 ) как @xmath136 ( @xmath137 ) если @xmath138, то в максимально загруженной ячейке есть шары @xmath139, @xmath140, с высокой вероятностью ( @xmath135 ) как @xmath136 ( @xmath141 ), если @xmath142 в максимально загруженной ячейке есть @xmath143, @xmath144, @xmath145 и @xmath146, с высокой вероятностью ( @xmath135 ) как @xmath136 обозначают событие, в котором есть по крайней мере @xmath5 шаров. конкретная ячейка как @xmath147. используя объединение, связанное со всеми подмножествами размера @xmath103, легко показать, что вероятность того, что произойдет @xmath147, сверху ограничена @xmath148 используя формулу Стирлинга, мы имеем @xmath149. тогда @xmath150 может быть дополнительно ограничено @xmath151, если @xmath152, подставив @xmath153 в rhs ( [ eq : maxload_ub ] ), мы получим @xmath154, обозначающий событие, когда во всех ячейках есть не более @xmath5 шаров, как @xmath155. применяя привязку к объединению, показано, что @xmath156, поскольку @xmath157 мы завершаем доказательство для случая @xmath158, если @xmath138 заменить @xmath159 на rhs ( [ eq : maxload_ub ] ), у нас есть @xmath160 применяя привязку к объединению, мы завершаем доказательство для случая @xmath158. случай @xmath161 если @xmath142 подставить @xmath162 в rhs из ( [ eq : maxload_ub ] ), мы получим @xmath163, где @xmath164 применяя границу объединения, показано, что @xmath165, поскольку @xmath166 мы заканчиваем доказательство для случая @xmath167 обратите внимание, что теорема [ thm : random_loading ] показывает только верхнюю границу максимальной нагрузки @xmath130 с простым доказательством. более точные результаты можно найти в теореме 1 @xcite, где приведен точный порядок @xmath130 для разных случаев. стоит отметить, что результаты в теореме 1 @xcite отличаются от теоремы [ thm : random_loading ], потому что теорема 1 @xcite выполняется с вероятностью @xmath168, в то время как теорема [ thm : random_loading ] выполняется с вероятностью ( @xmath135). асимптотическая оптимальность в процессе перезаписи подразумевает, что каждая перезапись увеличивает уровень ячейки только на 1, и все уровни ячейки полностью используются, когда происходит стирание. это фактически подразумевает @xmath169. поскольку @xmath4 обычно является большим числом, а @xmath0 на практике недостаточно велико, теорема показывает, что, когда @xmath0 недостаточно велико, асимптотическая оптимальность недостижима. например, в практических системах количество уровней ячеек @xmath0 не зависит от количества ячеек в блоке. следовательно, вместо @xmath74 в качестве @xmath171 можно использовать только приблизительные уровни заряда @xmath170, если @xmath0 является небольшой константой, которая не зависит от @xmath4. на практике эту потерю можно было бы уменьшить, используя операции записи, которые увеличивают уровень заряда в нескольких ячейках одновременно (вместо стирания блока). [ thm : gamma1] самослучайный код модуляции имеет эффективность хранения @xmath172, когда @xmath173 и @xmath174, когда @xmath175, поскольку @xmath4 стремится к бесконечности с высокой вероятностью (т.е. @xmath168 ).    рассмотрим проблему выбрасывания шаров @xmath129 в ячейки @xmath4, и пусть r.v. @xmath10 - это количество шаров, брошенных в ячейки @xmath4, до тех пор, пока в какой-либо ячейке не окажется больше, чем в @xmath9 шаров. хотя мы хотели бы точно вычислить @xmath176 $ ], мы все равно довольствуемся приближением, основанным на следующем результате. если @xmath177, то существует константа @xmath178, такая, что максимальное количество шаров @xmath130 в любой ячейке удовлетворяет @xmath179 с вероятностью @xmath168 как @xmath171 @xcite. константа @xmath178 задается наибольшим @xmath180-корнем из @xmath181, и решение этого уравнения для @xmath182 дает неявное выражение @xmath183. поскольку нижняя граница лучше соответствует ожидаемому максимальному значению, мы определяем @xmath184 и применяем его к нашей задаче, используя уравнение @xmath185 или @xmath186. следовательно, эффективность хранения равна @xmath187, если @xmath188, максимальная нагрузка составляет приблизительно @xmath189 с вероятностью @xmath168 для большого @xmath4 @xcite. следовательно, по определению эффективность хранения равна @xmath191 результаты в теореме [ thm : gamma1 ] показывают, что когда @xmath0 имеет порядок @xmath192, эффективность хранения составляет порядок @xmath193. принимая предел как @xmath194 с @xmath195, мы получаем @xmath196, когда @xmath0 является константой, независимой от @xmath4, эффективность хранения порядка @xmath197 принимая предел как @xmath171 с @xmath173, мы получаем @xmath198. в этом режиме саморандомизированные коды модуляции на самом деле работают очень плохо, даже несмотря на то, что они асимптотически оптимальны как @xmath1. рассматривая проблему с корзинами и шарами, можем ли мы распределить шары более равномерно, когда @xmath199 имеет порядок @xmath200 к счастью, когда @xmath201, максимальная нагрузка может быть уменьшена примерно в @xmath202 раза, используя _ силу двух случайных выборов _ @xcite. в деталях стратегия заключается в том, что каждый раз мы выбираем две ячейки независимо и равномерно случайным образом и бросаем мяч в менее загруженную ячейку. таким образом, в максимально загруженной ячейке с высокой вероятностью находится примерно @xmath203 шарика. теорема 1 в @xcite дает ответ в общей форме, когда мы рассматриваем случайный выбор @xmath204. теорема показывает, что существует большой выигрыш, когда число случайных вариантов увеличивается с 1 до 2. кроме того, коэффициент усиления остается того же порядка, и можно улучшить только константу. основываясь на идее двух случайных вариантов, мы определяем следующий код модуляции с балансировкой нагрузки.    опять же, мы задаем вектору состояния ячейки в момент времени @xmath8 значение @xmath84, где @xmath17 - это уровень заряда @xmath18-й ячейки в момент времени @xmath19 на этот раз мы используем ячейки @xmath205 для хранения переменной @xmath5 @xmath206 (т.е. мы записываем биты @xmath207 в хранить @xmath208 бит информации ). потеря информации обеспечивает @xmath6 способов записи одного и того же значения. эта гибкость позволяет нам избегать последовательностей записей, которые слишком сильно увеличивают уровень одной ячейки. нас в первую очередь интересуют двоичные переменные с двумя случайными вариантами выбора или @xmath209. чтобы возможности выбора @xmath6 были эффективными, мы должны попытаться рандомизировать (с течением времени) возможные варианты @xmath6 из набора всех возможностей @xmath210. для этого используется значение @xmath91. пусть @xmath211 - поле Галуа с элементами @xmath212, а @xmath213 - биекция, удовлетворяющая @xmath214 (т.е. элемент поля Галуа 0 связан с целым числом 0 ). алгоритм декодирования вычисляет @xmath215 из @xmath27 и работает следующим образом: * шаг 1: считываем вектор состояния ячейки @xmath27 и вычисляем норму @xmath90 @xmath91. * шаг 2: вычислите @xmath216 и @xmath217 * шаг 3: вычислите @xmath218 и @xmath219 * шаг 4: вычислите @xmath220. алгоритм кодирования сохраняет @xmath11 и работает следующим образом. * шаг 1: считайте состояние ячейки @xmath26 и декодируйте в @xmath221 и @xmath96. если @xmath222, то ничего не делайте. * шаг 2: вычислите @xmath223, @xmath218 и @xmath219 * шаг 3: вычислите @xmath224 и @xmath225 для @xmath226. * шаг 4: вычислите @xmath227. увеличьте уровень заряда ячейки @xmath228 на 1. обратите внимание, что вектор состояния в @xmath85 инициализирован значением @xmath229 и, следовательно, @xmath87. первое произвольное значение, которое может быть сохранено, - это @xmath230. следующая гипотеза предполагает, что производительность загрузки шариков приведенного выше алгоритма идентична алгоритму случайной загрузки со случайным выбором @xmath209. [ thm : gamma2] если @xmath209 и @xmath175, то код модуляции балансировки нагрузки имеет эффективность хранения @xmath231 с вероятностью 1-@xmath232 как @xmath171. если @xmath233, то эффективность хранения @xmath234 с вероятностью 1-@xmath232.    [набросок доказательства ] рассмотрим аффинную перестановку @xmath235 для @xmath236 и @xmath237. поскольку @xmath238 различается, эта перестановка отображает два элемента @xmath11 и @xmath239 равномерно по всем парам индексов ячеек. после шагов @xmath240 мы видим что все пары @xmath238 встречаются одинаково часто. следовательно, при выборе менее заряженной ячейки код модуляции практически идентичен алгоритму случайной загрузки с двумя случайными выборами. к сожалению, нас интересует случай, когда @xmath241, поэтому анализ несколько более деликатный. если @xmath177, то самый высокий уровень заряда равен @xmath242 с вероятностью @xmath168 @xcite. поскольку в этом случае @xmath175, эффективность хранения равна @xmath243. если @xmath188, то @xmath173, а максимальная нагрузка равна @xmath244. по определению, у нас есть @xmath245, следовательно, у нас есть @xmath246, если @xmath209 и @xmath0 находятся в порядке @xmath247 гипотеза [ thm : gamma2 ] показывает, что граница ( [ eq : storage_efficiency_bound ] ) достижима с помощью кодов модуляции балансировки нагрузки, поскольку @xmath4 стремится к бесконечности. в этом режиме коды модуляции с балансировкой нагрузки обеспечивают лучшую константу, чем саморандомизированные коды модуляции, за счет использования в два раза большего числа ячеек. [ примечание: если @xmath209 и @xmath0 являются константами, независимыми от @xmath4, эффективность хранения равна @xmath248 для кода модуляции с саморандомизацией и @xmath249 для кода модуляции с балансировкой нагрузки. но код саморандомизированной модуляции использует ячейки @xmath250, а код модуляции с балансировкой нагрузки использует ячейки @xmath251. чтобы провести справедливое сравнение эффективности хранения между ними, мы используем @xmath251 для обоих кодов. тогда у нас есть @xmath252 и @xmath249. итак, как @xmath171, мы видим, что @xmath253. следовательно, код модуляции с балансировкой нагрузки превосходит саморандомизированный код, когда @xmath4 достаточно велик. в этом разделе мы представляем результаты моделирования для кодов модуляции, описанных в разделах [sub : другой алгоритм перезаписи ] и [sub: расширенный алгоритм]. на рисунках первый код модуляции называется `саморандомизированным кодом модуляции\", в то время как второй называется ` код модуляции для балансировки нагрузки \". пусть `коэффициент потерь\" @xmath254 - это доля уровней ячеек, которые не используются, когда требуется удаление блока : @xmath255}{n(q-1)}.$ ] мы показываем коэффициент потерь для случайной загрузки с 1 и 2 случайными выборами в качестве сравнения. обратите внимание, что @xmath254 не учитывает объем информации на уровне ячейки. результаты на рис. [ flo : рис. 2 ] покажите, что самослучайный код модуляции имеет тот же @xmath254 со случайной загрузкой с 1 случайным выбором, а код модуляции с балансировкой нагрузки имеет тот же @xmath254 со случайной загрузкой с 2 случайными выборами. это показывает оптимальность этих двух кодов модуляции с точки зрения загрузки шарика.   , @xmath209 и 1000 стираний.[flo : рис. 2 ] ] с помощью @xmath80, @xmath256, @xmath257 и 1000 стираний.[flo : fig4 ] ] .[fig : fig5 ] ] .[fig : fig6 ] ] мы также предоставляем результаты моделирования для случайной загрузки с 1 случайным выбором и коды, разработанные в @xcite, которые мы обозначаем как алгоритм flm-(@xmath258), на рис. [ flo : рис. 4 ]. из результатов, показанных на рис. [ flo : рис. 4 ], мы видим, что алгоритм flm-(@xmath258 ) имеет тот же коэффициент потерь, что и случайная загрузка с 1 случайным выбором. на самом деле это можно увидеть из доказательства асимптотической оптимальности в @ xcite, поскольку алгоритм преобразует произвольное входное распределение в равномерное распределение с шагом на уровне ячейки. обратите внимание, что оптимальность алгоритма flm доказана только при сохранении 1 бита информации. итак, в данном случае мы просто сравниваем алгоритм flm с алгоритмом случайной загрузки. [ рис. 5 ] и рис. 6. [ рис. 6 ] показывают эффективность хранения @xmath33 для этих двух кодов модуляции. [ рис. 5 ] и рис. 6. [ рис. : рис. 6 ] показывают, что код модуляции с балансировкой нагрузки работает лучше, чем код модуляции с автоматической рандомизацией, когда @xmath4 большой. это также показано теоретическим анализом в замечании [ rem : if is ]. в этой статье мы рассматриваем проблему проектирования кода модуляции для практических систем хранения данных во флэш-памяти. эффективность хранения, или среднее (по распределению входных переменных) количество информации на уровне ячейки, максимизируется. в рамках этой структуры мы показываем, что максимизация количества перезаписей для критерия наихудшего случая @xcite и критерия среднего случая @xcite являются двумя крайними случаями нашей цели оптимизации. предложен самослучайный код модуляции, который является асимптотически оптимальным для произвольного распределения входных данных и произвольных @xmath5 и @xmath6 в качестве числа уровней ячеек @xmath1. далее мы рассмотрим производительность практических систем, в которых значение @xmath0 недостаточно велико для доминирования асимптотических результатов. затем мы проанализируем эффективность хранения кода самораскрученной модуляции, когда значение @xmath0 только умеренно велико. затем предлагаются коды модуляции балансировки нагрузки, основанные на мощности двух случайных вариантов @xcite @xcite. анализ и численное моделирование показывают, что схема балансировки нагрузки превосходит ранее предложенные алгоритмы.

в этой статье мы рассматриваем коды модуляции для практических многоуровневых систем хранения флэш-памяти с уровнями ячеек @xmath0. вместо увеличения срока службы устройства @xcite мы максимизируем средний объем информации, хранящейся на уровне ячейки, который определяется как эффективность хранения. используя эту структуру, мы показываем, что критерий наихудшего случая @xcite и критерий среднего случая @xcite являются двумя крайними случаями нашей целевой функции. предлагается саморандомизированный код модуляции, который является асимптотически оптимальным, как @xmath1, для произвольного входного алфавита и распределения входных данных.    в практических системах флэш-памяти количество уровней ячеек @xmath0 только умеренно велико. таким образом, асимптотическая производительность, указанная в @xmath1, может не рассказать всей истории. используя инструменты из теории балансировки нагрузки, мы анализируем эффективность хранения кода саморандомизированной модуляции. результат показывает, что используется только часть ячеек, когда количество уровней ячеек @xmath0 лишь умеренно велико. мы также предлагаем код модуляции с балансировкой нагрузки, основанный на явлении, известном как `сила двух случайных выборов\" @xcite, для повышения эффективности хранения в практических системах. теоретический анализ и результаты моделирования показывают, что наши коды модуляции с балансировкой нагрузки могут обеспечить значительный выигрыш для практических систем хранения данных на флэш-памяти. несмотря на псевдослучайность, наш подход обеспечивает ту же производительность балансировки нагрузки для входных данных i.i.d., что и чисто случайный подход, основанный на силе двух случайных вариантов.