модель самоустраняющегося блуждания (saw) является важной моделью в статистической физике @xcite. она моделирует эффект исключенного объема, наблюдаемый в реальных полимерах, и точно отражает универсальные характеристики, такие как критические показатели и отношения амплитуд. это также важная модель при изучении критических явлений, поскольку она является пределом @xmath4 векторной модели @xmath5, которая включает модель Изинга (@xmath6 ) в качестве другого примера. действительно, можно прямолинейно моделировать пилы в бесконечном предельном объеме, что делает эту модель особенно подходящей для расчета критических параметров. точные результаты известны для самоустраняющихся блужданий в двух измерениях @xcite и для @xmath7 (поведение среднего поля было доказано для @xmath8 @xcite), но не для наиболее физически интересного случая @xmath9. алгоритм pivot - это мощный и часто используемый подход к изучению самостоятельных прогулок, изобретенный lal @ xcite, а позже разъясненный и популяризированный madras и sokal @xcite. алгоритм pivot использует поворотные перемещения в качестве переходов в марковской цепочке, которая протекает следующим образом. из начальной пилы длины @xmath0, такой как прямой стержень, последовательно генерируются новые обходы с шагом @xmath0 путем случайного выбора участка обхода и попытки применить операцию симметрии решетки, или поворота, к одной из частей обхода; если результирующий обход равен самоустранение от хода принимается, в противном случае ход отклоняется и сохраняется исходный ход. таким образом, в ансамбле пил фиксированной длины формируется цепь Маркова; эта цепь удовлетворяет детальному балансу и является эргодической, гарантируя, что пилы отбираются равномерно случайным образом. одно из типичных применений алгоритма pivot заключается в вычислении наблюдаемых величин, которые характеризуют размер пил: квадрат расстояния от конца до конца @xmath10, квадрат радиуса вращения @xmath11 и среднеквадратичное расстояние мономера от его конечных точек @xmath12. в порядке возрастания мы ожидаем, что средние значения этих наблюдаемых величин по всем пилам шагов @xmath0, при этом каждой пиле присваивается одинаковый вес, будут равны @xmath13 ( @xmath14 ), при этом @xmath15 является универсальным критическим показателем. для пил с шагом @xmath0 реализация алгоритма поворота, разработанного Мадрасом и Сокалом, оценила среднее время на попытку поворота в @xmath16 на @xmath17 и @xmath18 на @xmath19; производительность была значительно улучшена Кеннеди @xcite до @xmath20 и @xmath21 соответственно.    в этой статье мы даем подробное описание новой структуры данных, которую мы называем saw - tree. эта структура данных позволяет нам реализовать алгоритм поворота высокоэффективным образом: мы приводим эвристический аргумент о том, что среднее время на попытку поворота составляет @xmath1 на @xmath17 и @xmath19, и численные эксперименты, которые показывают, что для обходов с шагом до @xmath22 алгоритмическая сложность хорошо аппроксимируется @xmath3. это усовершенствование позволяет быстро моделировать прогулки со многими миллионами шагов.    в сопутствующей статье @xcite мы описываем алгоритм в общих чертах и демонстрируем мощь метода, применяя его к задаче вычисления критического показателя @xmath15 для трехмерных обходов, избегающих себя.    до сих пор дерево пилы было реализовано для @xmath17, @xmath19 и @xmath23, но оно может быть напрямую адаптировано к другим решеткам и континууму, а также полимерным моделям с взаимодействиями на малых расстояниях. другими возможными расширениями могут быть разветвленные полимеры, замкнутые полимеры или моделирование полимеров в растворе. мы намерены реализовать saw - tree и связанные с ним методы в виде библиотеки программного обеспечения с открытым исходным кодом для использования исследователями в области моделирования полимеров. мадрас и Сокал @xcite продемонстрировали с помощью убедительных эвристических аргументов и численных экспериментов, что алгоритм pivot приводит к созданию цепи Маркова с коротким интегрированным временем автокорреляции для глобальных наблюдаемых величин. алгоритм pivot намного эффективнее цепей Маркова, которые используют локальные перемещения; подробное обсуждение смотрите на @xcite.    реализация алгоритма pivot Мадрасом и Сокалем использовала хэш-таблицу для записи местоположения каждого участка обхода. они показали, что для @xmath0-ступенчатых пил вероятность принятия поворота равна @xmath24, при этом @xmath25 зависит от измерения, но близка к нулю (@xmath26). поскольку принятые повороты обычно приводят к большим изменениям в глобальных наблюдаемых, таких как @xmath10, это приводит к выводу, что алгоритм pivot имеет встроенное время автокорреляции @xmath27 с возможными логарифмическими поправками. Кроме того, они убедительно доказали, что процессорное время на успешный pivot для их реализации равно @xmath28. на протяжении всей этой статьи мы работаем со средним временем на попытку pivot, @xmath29, которое для реализации в Мадрасе и Сокале равно @xmath30. мадрас и Сокал утверждали, что @xmath28 на успешный разворот является наилучшим возможным, потому что требуется время @xmath28, чтобы просто записать @xmath0-ступенчатую пилу. кеннеди @xcite, однако, признал, что нет необходимости записывать saw для каждого успешного поворота, и разработал структуру данных и алгоритм, которые умело использовали геометрические ограничения, чтобы преодолеть барьер @xmath28. в этой статье мы разрабатываем методы, которые еще больше улучшают использование геометрических ограничений для получения высокоэффективной реализации алгоритма поворота. мы эффективно реализовали алгоритм поворота с помощью структуры данных, которую мы называем saw - tree, которая позволяет быстро моделировать пилы методом монте-карло с миллионами шагов. эта новая реализация также может быть адаптирована к другим моделям полимеров с короткодействующими взаимодействиями на решетке и в континууме и, следовательно, обещает быть широко полезной. суть нашей реализации алгоритма заключается в выполнении тестов пересечения между `ограничивающими рамками\" различных подпроходов при попытке поворота. в @xcite мы сгенерировали большие выборки обходов с шагом до @xmath31, но с целью определения сложности нашего алгоритма мы также сгенерировали меньшие выборки обходов с шагом до @xmath32. для @xmath33 среднее количество тестов пересечения, необходимых для каждой попытки поворота, удивительно низкое: 39 для @xmath17, 158 для @xmath19 и 449 для @xmath23.    в сек. [ sec : сложность ] мы приводим эвристические аргументы в пользу асимптотического поведения среднего времени на попытку поворота для @xmath0-ступенчатых пил, @xmath29, и проверяем эти предсказания компьютерными экспериментами для @xmath34. мы суммируем наши результаты в таблице [ вкладка : производительность ] ; обратите внимание, что @xmath35 указывает, что @xmath36 асимптотически ограничен сверху @xmath37, @xmath38 указывает, что @xmath37 доминирует над @xmath36, @xmath39 указывает, что @xmath36 доминирует над @xmath37, а @xmath40 указывает, что @xmath37 ограничивает @xmath36 как выше, так и ниже. для сравнения мы также приводим алгоритмическую сложность реализаций madras и sokal @xcite, а также kennedy @xcite. в разделе. [ sec : complexityhighdim ], мы приводим аргумент в пользу сложности нашего алгоритма на @xmath23; этот же аргумент приводит к оценке производительности реализации madras и sokal на @xmath23. мы не знаем сложности реализации Кеннеди для @xmath23 и @xmath41 с @xmath42, но мы подозреваем, что это @xmath43 с @xmath44, с возможными логарифмическими поправками. решетка ccccc & Мадрас и Сокаль & Кеннеди & + & & & предсказанные и наблюдаемые    ' \" \" + @xmath17 & @xmath16 & @xmath20 & @xmath1 & @xmath2 ' \" \" + @xmath19 & @xmath18 & @xmath21 & @xmath1 & @xmath3 + @xmath23 & @xmath45 & ? & @xmath2 & @xmath46 + @xmath41, @xmath42 & @xmath28 & ? & @xmath47 & ?    ' \" \" + наша реализация также быстра на практике: для моделирования длительных прогулок @xmath48 на @xmath19 наша реализация почти в 400 раз быстрее по сравнению с kennedy s и почти в четыре тысячи раз быстрее по сравнению с Мадрасом и Сокалем. мы измерили @xmath29 для каждой реализации в широком диапазоне @xmath0 на @xmath17, @xmath19 и @xmath23 и сообщаем об этих результатах в секундах. [ секунда : сравнение ].      в разделе. [ sec : реализация ] мы даем подробное описание структуры данных дерева пилы и связанных с ней методов, которые требуются для реализации алгоритма pivot.    в разделе. [ sec : сложность ] мы приводим эвристические аргументы о том, что @xmath29 для самостоятельных обходов на @xmath17 и @xmath19 равен @xmath1, и численные доказательства, которые показывают, что для обходов до @xmath22 шагов @xmath29 равен @xmath2 для @xmath17 и @xmath3 для @xmath19. мы также обсуждаем поведение нашей реализации для более высоких измерений.    в разделе. [ sec : инициализация ] мы обсуждаем инициализацию цепи Маркова, включая подробную информацию о том, сколько точек данных отбрасывается. мы также объясняем, почему крайне желательно иметь такую процедуру, как * pseudo_dimerize * для инициализации (псевдокод в сек. [ sec : implementationhigh ] ) при изучении очень длинных переходов и покажите, что ожидаемое время выполнения * pseudo_dimerize * равно @xmath49.    в сек. [ sec : автокорреляция ] мы обсуждаем функцию автокорреляции для алгоритма pivot и показываем, что пакетный метод оценки доверительных интервалов является точным при условии, что размер пакета достаточно велик. это подтверждает точность доверительных интервалов для наших данных, опубликованных в @xcite.    наконец, в разделе. [ раздел : сравнение ] мы сравниваем производительность нашей реализации с предыдущими реализациями алгоритма pivot @xcite. мы показываем, что реализация saw - tree не только значительно быстрее для длительных прогулок, но и быстрее, чем другие реализации, для прогулок всего с 63 шагами. обходы с самообороной (saws) представлены в виде бинарных деревьев (см., например, @xcite ) с помощью рекурсивного определения; здесь мы описываем структуру данных дерева saw и связанные с ней методы с использованием псевдокода. эти методы могут быть расширены, чтобы включать переводы, разделение переходов, объединение переходов и тестирование на пересечение с поверхности. действительно, для моделей, похожих на пилу (те, которые взаимодействуют на небольшом расстоянии), должно быть возможно реализовать широкий спектр глобальных перемещений и тестов для пил с шагом @xmath0 во времени @xmath3 или лучше. также возможно распараллелить код, например, выполнив тестирование пересечения для множества предлагаемых поворотов одновременно. распараллеливание базовых операций также возможно, но было бы значительно сложнее реализовать. в этом разделе мы даем точные псевдокодовые определения структуры данных и алгоритмов. для справки, r - деревья @xcite и иерархии ограничивающих объемов (см., например, @xcite ) - это структуры данных, возникающие в области вычислительной геометрии, которые связаны с saw - деревом.      для самостоятельных прогулок условие самостоятельного избегания применяется к участкам, а не к связям, и это означает, что пилорама естественным образом определяется в терминах участков. это представление также имеет то преимущество, что базовые объекты, сайты, имеют физическое значение, поскольку они соответствуют мономерам в полимере. единственные последствия этого выбора являются условными: дерево распилов из @xmath5 сайтов имеет @xmath50 шагов. мы используем это обозначение для остальной части этого раздела. при обсуждении сложности различных алгоритмов мы по-прежнему будем использовать @xmath0, а не @xmath5, чтобы соответствовать сопутствующей статье и другим разделам настоящей работы. сайт @xmath5, увиденный на @xmath41, представляет собой сопоставление @xmath51 с @xmath52 для каждого @xmath53 ( @xmath54 обозначает евклидову норму @xmath55 ) и с @xmath56 для всех @xmath57. пилы могут быть либо рутированными, либо некорневыми; наше соглашение заключается в том, что пилы рутируются на сайте, который находится в @xmath58 (единичный вектор в первом координатном направлении), т.е. @xmath59. это соглашение упрощает некоторую алгебру, связанную с объединением подпроходов, и представлено визуально, например, на рис. [ рис. : пример ], указывая пунктирную связь от начала координат до первого участка обхода. ( 0,0 ) круг ( 3pt ) ; ( 1,0 ) круг ( 3pt ) ; ( 1,1 ) круг ( 3pt ) ; ( 2,1 ) круг ( 3pt ) ; ( 3,1 ) круг ( 3pt ) ; ( 3,0 ) круг ( 3pt ) ; ( 0,0 ) ( 1,0 ) ; ( 1,0 ) ( 1,1 ) ( 2,1 ) ( 3,1 ) ( 3,0 ) ; мы обозначаем группу симметрий @xmath41 как @xmath60, что соответствует двугранной группе для @xmath61 и октаэдрической группе для @xmath9. эта группа воздействует на координаты, переставляя любое из направлений координат @xmath62 (варианты @xmath63) и независимо выбирая ориентацию каждой из этих координат (варианты @xmath64); таким образом, @xmath60 имеет элементы @xmath65. таким образом, группа симметрий решетки для @xmath19 содержит 48 элементов, и мы используем их все, кроме identity, в качестве потенциальных операций поворота; возможны и другие варианты. мы можем представить элементы группы симметрии в виде ортогональных матриц @xmath66, а элементы группы симметрии воздействуют на координаты, записанные в виде векторов-столбцов. мы также определяем (неуникальное) представление сводной последовательности самоуничтожающегося случайного блуждания на @xmath41 как отображение целых чисел на @xmath60, @xmath67. элементы последовательности @xmath68 представляют изменения в операторе симметрии с сайта @xmath69 на сайт @xmath53, в то время как @xmath70 представляют операции абсолютной симметрии, т.е. относительно первого сайта обхода. мы можем связать это с предыдущим определением самоустраняющегося обхода в терминах сайтов с помощью рекуррентных соотношений @xmath71 с @xmath72 и начальных условий @xmath73, @xmath74 и @xmath59.    как отметили Мадрас и Сокал (сноска 10, стр. 132 в @xcite), для представления последовательности поворота можно выполнить поворот перемещения во времени @xmath1, выбрав сайт @xmath53 равномерно случайным образом и умножив @xmath68 на (случайный) элемент группы симметрии. однако представление сводной последовательности работает не лучше, чем реализация хэш-таблицы madras и sokal, если мы хотим определить, приводит ли это изменение к самопересечению, или если мы хотим вычислить глобальные наблюдаемые, такие как @xmath10 для обновленного обхода. забыв на мгновение об условии самоустранения и используя тот факт, что @xmath60 содержит элементы @xmath75, мы видим, что для случайных блужданий сайтов @xmath5 существуют возможные последовательности поворота @xmath76, в то время как есть только случайные блуждания @xmath77. это говорит о том, что каждое случайное блуждание представлено поворотными последовательностями @xmath78. это можно получить непосредственно, отметив, что, учитывая последовательность поворота @xmath79, мы можем вставить поворот @xmath80, который сохраняет вектор @xmath58, между двумя элементами @xmath81 и @xmath82 следующим образом @xmath83 без изменения обхода. количество элементов группы симметрии, которые сохраняют @xmath58, равно @xmath84, и есть местоположения @xmath50, куда могут быть вставлены эти элементы группы симметрии, что приводит к эквивалентным сводным представлениям @xmath78 для случайного обхода сайтов @xmath5. для @xmath61, учитывая @xmath85 рекуррентные соотношения в уравнениях. [ eq : qrecurrence ] и [ eq : omegarecurrence ] исправляют только один из двух ненулевых элементов в @xmath68, оставляя выбор знака для другого ненулевого элемента свободным. для нашего примера перехода @xmath86 у нас есть @xmath87, мы даем три из 16 эквивалентных вариантов для представления pivot @xmath86, первый включает только правильные вращения, второй с неправильными вращениями для @xmath68 с @xmath88, а третий с чередованием правильных и неправильных вращений : @xmath89 не - уникальность представления pivot для saws обусловлена тем фактом, что мономеры (занятые участки) инвариантны относительно группы симметрии @xmath60, т.е. невозможно различить различные ориентации одного участка. неединственность не имеет практического значения, но, возможно, намекает на то, что, возможно, возможно получить более краткое и элегантное представление прогулок, чем отображение в @xmath60, определенное здесь. операция слияния - это фундаментальная операция в saws, которая позволяет использовать структуру данных двоичного дерева, которую мы называем saw - деревом. это связано с операцией объединения, определенной, например, в разделе 1.2 @xcite; для объединения сохраняется количество связей, тогда как для операции слияния сохраняется количество узлов. объединение двух пил с сайтами @xmath5 и @xmath90 соответственно приводит к созданию пилы с сайтами @xmath91. удобно также включить операцию поворота, @xmath80, при объединении переходов, и результатом объединения двух переходов @xmath92 и @xmath93 будет @xmath94 операция слияния визуально представлена на рис. [ рис. : слияние ]. чтобы объединить два подпрохода, прикрепите открытый круг левого подпрохода к началу координат, а затем прикрепите открытый круг правого подпрохода к концу левого подпрохода. наконец, примените симметрию @xmath80 к правой вспомогательной дорожке, используя второй штифт в качестве оси поворота. ( 0,0 ) круг ( 3 ПТ ) ; ( 1,0 ) круга ( 3 ПТ ) ; ( 1,1 ) круг ( 3 ПТ ) ; ( 0,0 ) ( 1,0 ) ; ( 1,0 ) ( 1,1 ) ; ( 1.5,0 ) узел[м ] @xmath95 ; ( 2,0 ) круга ( 3 ПТ ) ; ( 3,0 ) круг ( 3 ПТ ) ; ( 3,-1 ) круг ( 3 ПТ ) ; ( 2,0 ) ( 3,0 ) ; ( 3,0 ) ( 3,-1 ) ; ( 3.5,0.0 ) узел @xmath96 ; ( 4,0 ) круг ( 3 ПТ ) ; ( 5,0 ) круг ( 3 ПТ ) ; ( 5,1 ) круг ( 3 ПТ ) ; ( 6,1 ) круг ( 3 ПТ ) ; ( 6,0 ) круг ( 3 ПТ ) ; ( 4,0 ) ( 5,0 ) ; ( 5,0 ) ( 6,1 ) ( 6,0 ) ; ( 0,0 ) круг ( 3 ПТ ) ; ( 1,0 ) круга ( 3 ПТ ) ; ( 1,1 ) круг ( 3 ПТ ) ; ( 0,1 ) круг ( 3 ПТ ) ; ( 0,0 ) ( 1,0 ) ; ( 1,0 ) ( 1,1 ) ( 0,1 ) ; ( 1.5,0.5 ) узел[м ] @xmath97 ; ( 1.5,0.58 ) узел @xmath98 ; ( 2,0 ) круга ( 3 ПТ ) ; ( 3,0 ) круг ( 3 ПТ ) ; ( 3,1 ) круг ( 3 ПТ ) ; ( 3,2 ) круг ( 3 ПТ ) ; ( 2,0 ) ( 3,0 ) ; ( 3,0 ) ( 3,2 ) ; ( 3.5,0.5 ) узел @xmath96 ; ( 5,0 ) круг ( 3 ПТ ) ; ( 6,0 ) круг ( 3 ПТ ) ; ( 6,1 ) круг ( 3 ПТ ) ; ( 5,1 ) круг ( 3 ПТ ) ; ( 4,1 ) круг ( 3 ПТ ) ; ( 4,0 ) круг ( 3 ПТ ) ; ( 4,-1 ) круг ( 3 ПТ ) ; ( 5,0 ) ( 6,0 ) ; ( 6,0 ) ( 4,-1 ) ; здесь мы определяем различных количествах, которые необходимы для реализации наших структуры данных и расчета наблюдаемых величин, таких как среднеквадратичное конца в конец расстояние, @xmath10. сначала мы определяем различные величины, которые будут использоваться для вычисления наблюдаемых величин, измеряющих размер прогулки: @xmath99 ограничивающая рамка прогулки - это выпуклая форма, которая полностью содержит прогулку. очевидным выбором формы для @xmath41 является прямоугольная призма с гранями, сформированными из координатных плоскостей @xmath100, @xmath101, с константами, выбранными таким образом, чтобы грани призмы касались дорожки, т.е. ограничивающая рамка имеет минимальную протяженность. возможны и другие варианты, например, можно использовать другие плоскости, такие как @xmath102, @xmath103, и они имеют преимущество в более точном соответствии форме дорожки, но за счет больших вычислительных затрат и потребления памяти. при более близком расположении ограничивающих рамок требуется выполнять меньше тестов на пересечение, чтобы определить, пересекаются ли две дорожки. однако на практике реализация прямоугольной призмы в координатной плоскости была самой быстрой на нашем компьютерном оборудовании (с небольшим отрывом) и имеет то преимущество, что ее просто реализовать. выбор ограничительной рамки для континуальных моделей не столь очевиден; возможны сферы и ориентированные прямоугольные призмы. мы отмечаем, что выбор формы ограничивающего прямоугольника определяет максимальное количество узлов, @xmath104, которые может иметь пила, так что гарантируется, что ее ограничивающий прямоугольник содержит узлы пилы и никакие другие. предположим, нам даны две пилы, для которых ограничивающие рамки перекрываются: если каждая из дорожек имеет @xmath104 или меньше участков, мы можем быть уверены, что две дорожки пересекаются, в то время как если хотя бы одна из дорожек имеет больше, чем @xmath104 участков, может случиться так, что дорожки не пересекаются. значение @xmath104 определяет порог для проверки пересечения для функции * intersect * в секундах. [ sec : implementationuser ]. для @xmath41 с @xmath105 ограничивающая рамка с гранями, сформированными из координатных плоскостей, приводит к максимальному количеству узлов равно двум, поскольку существуют контрпримеры с тремя сайтами (например, ограничивающий прямоугольник @xmath106 также содержит @xmath107 ). для ограничивающего прямоугольника, грани которого являются координатными плоскостями, и @xmath102 максимальное количество сайтов равно трем (поскольку ограничивающий прямоугольник @xmath108 также содержит @xmath109 ). можно продвинуться еще на один шаг вперед, чтобы максимальное количество сайтов составляло четыре, но пять невозможны, поскольку мы можем видеть, что @xmath86 на рис. [ рис. : пример ] имеет пять узлов и непосещаемый узел на своей выпуклой оболочке, который, следовательно, также должен находиться внутри любой ограничивающей рамки. мы записываем ограничивающие прямоугольники как произведение замкнутых интервалов в форме @xmath110 $ ], где произведение берется за @xmath111. рассмотрим переход @xmath112 с ограничивающим прямоугольником @xmath113, который разделен на левый и правый подпроходы, @xmath114 и @xmath115, с ограничивающими рамками @xmath116 $ ] и @xmath117 $ ] соответственно. затем мы можем определить операцию объединения для ограничивающих прямоугольников, @xmath118\\cup[c_i, d_i]\\right ) \\nonumber \\\\ & = \\times [ \\inf\\{a_i, c_i\\},\\sup\\{b_i, d_i\\}].\\end{выровнено}\\ ] ] операция пересечения определена как @xmath119\\cap[c_i, d_i]\\right ) \\nonumber \\\\ & = \\times [ \\sup\\{a_i, c_i\\},\\inf\\{b_i, d_i\\}].\\end{выровнено}\\ ] ] нет гарантируем, что @xmath120, и мы принимаем соглашение о том, что интервал @xmath121 $ ] считается пустым, если @xmath122. если какой-либо интервал пуст, то соответствующая ограничивающая рамка также пуста, поскольку она не содержит внутренних узлов. величина, связанная с ограничивающим прямоугольником, которую мы сочтем полезной, - это сумма размеров ограничивающего прямоугольника, * perim*. если @xmath123 $ ], то мы определяем @xmath124 для @xmath86 (на рис. [ рис. : пример ] ) у нас есть следующие значения для различных параметров: @xmath125\\times[0,1 ] ; \\\\ \\mathbf{x}_{\\mathrm{e}}(\\omega_a ) & = ( 3,0 ) ; \\\\ \\ mathbf{x}(\\omega_a ) & = ( 1,0 ) + ( 1,1 ) + ( 2,1 ) + ( 3,1 ) + ( 3,0 ) \\ ненумерованный \\\\ & = ( 10,3);\\\\ x_2(\\omega_a ) & = ( 1,0)\\cdot(1,0 ) + ( 1,1)\\cdot(1,1 ) + ( 2,1)\\cdot(2,1 ) \\nonumber \\\\ & \\mathrel{\\phantom{= } } + ( 3,1)\\cdot(3,1 ) + ( 3,0)\\cdot(3,0 ) \\nonumber \\\\ & = 1 + 2 + 5 + 10 + 9 \\ ненумерованный \\\\ & = 27.\\end{выровнено}\\ ] ] наблюдаемые @xmath126 с @xmath127 могут быть напрямую вычислены из @xmath128, @xmath129 и @xmath130. мы приводим выражения для @xmath131 с помощью @xmath132 и отмечаем, что более высокие евклидово- инвариантные моменты могут быть получены с помощью @xmath133 ( @xmath134 ) (эти моменты вычисляются для @xmath17 в @xcite и для @xmath19 в @xcite). кроме того, мы вводим еще один наблюдаемый параметр, @xmath135, который измеряет среднеквадратичное отклонение прохождения от конечной точки @xmath136. @xmath137 \\nonumber \\\\ & = \\frac{1}{2 } + \\frac{1}{2}\\mathbf{x}_{\\mathrm{e } } \\cdot \\mathbf{x}_{\\mathrm{e } } - \\frac{1}{n } \\hat{\\mathbf{x}}_1 \\cdot \\mathbf{x } - \\frac{1}{n } \\mathbf{x}_{\\mathrm{e } } \\cdot \\mathbf{x } + \\frac{1}{n } x_2 \\\\ \\mathcal{r}_{\\mathrm{m}}^2 & = \\frac{1}{n}\\sum_{i=0}^{n-1 } |\\omega(i)-\\omega(n-1)|^2 \\nonumber \\\\ & = \\mathbf{x}_{\\mathrm{e } } \\cdot \\mathbf{x}_{\\mathrm{e } } - \\frac{2}{n } \\mathbf{x}_{\\mathrm{e } } \\cdot \\mathbf{x } + \\frac{1}{n } x_2 \\label{eq : calrm}\\end{выровнено}\\ ] ] в @xcite мы выбрали вычисление @xmath135, а не @xmath12, поскольку оно имеет немного более простое выражение, и полагались на идентификатор @xmath138. по сравнению с @xmath12, @xmath135 имеет большую дисперсию, но меньшее интегрированное время автокорреляции (для алгоритма pivot). перед выполнением вычислительного эксперимента в @xcite мы полагали, что при одинаковом количестве попыток pivot доверительные интервалы для @xmath139 и @xmath140 будут сопоставимы. с тех пор мы подтвердили, что прямая работа с @xmath12 приводит к стандартной ошибке, которая порядка 17% меньше для @xmath9, величина, которой нельзя пренебречь; в будущих экспериментах мы будем вычислять @xmath12 напрямую.      ниже следуют некоторые комментарии, помогающие в интерпретации псевдокодового описания структуры данных saw - tree и связанных с ней алгоритмов. * все вызовы выполняются по значению в соответствии с соглашением языка программирования c. структуры данных передаются методам через указатели. * указатели: walk @xmath141 - это структура данных, к переменным-членам которой можно получить доступ с помощью указателей, например, вектор для сквозного расстояния для walk @xmath141 равен @xmath142. левый подпроход @xmath141 обозначается @xmath143, а правый подпроход @xmath144. это обозначение дополнительно расширяется путем указания @xmath145 для левого подпрохода @xmath143, @xmath146 для правого подпрохода @xmath143 и т.д. * наводящее на размышления обозначение переменных-членов, используемых для улучшения читаемости; все величины, такие как ` @xmath128\" (конец сквозной вектор ) должен соответствовать определенному обходу @xmath141. например, @xmath147, @xmath148 (т.е. верхний индекс @xmath149 указывает, что @xmath150 является сквозным вектором для левого подпрохода ), @xmath151, @xmath152. * переменные с индексом @xmath153 используются только для временного хранения. * комментарии заключены между символами / * и * / в соответствии с соглашением c. * логическое отрицание обозначается символом ` ! \", например ! true = false. ключевым моментом, который позволил значительно улучшить реализацию алгоритма pivot, является осознание того, что последовательности узлов и опорных точек могут быть заменены бинарными деревьями. листья @xmath5 дерева являются отдельными сайтами обхода и, таким образом, не кодируют никакой информации, в то время как каждый из @xmath50 (внутренних) узлов дерева содержит совокупную информацию обо всех сайтах, которые находятся под ними в дереве. мы называем эту структуру данных saw - деревом, которое может быть определено рекурсивно: saw - дерево сайтов @xmath5 либо имеет @xmath154 и является листом, либо имеет левое дочернее saw - дерево с сайтами @xmath155 и правое дочернее saw - дерево с оставшимися сайтами @xmath156. наша реализация узла дерева пилы представлена в таблице [ вкладка : определение ]. дерево- пила состоит из одного или нескольких узлов дерева - пилы в бинарной древовидной структуре; указатели @xmath143 и @xmath144 допускают обход от корня дерева к листьям, в то время как @xmath157 допускает обход от листьев дерева к корню. пилообразные деревья создаются путем слияния других пилообразных деревьев с операцией симметрии, действующей на правую дорожку. в частности, любой _ внутренний узел _ @xmath141 может быть выражен в терминах его левого дочернего узла @xmath143, операции симметрии @xmath158 и его правого дочернего узла @xmath144 с помощью операции слияния: @xmath159 lll + тип & имя & описание ' \" \" + _ целое число _ & @xmath5 & число из сайтов \" \" + _ saw - tree ptr _ & @xmath157 & родительский + _ saw - tree ptr _ & @xmath143 & левый подпроход + _ saw - tree ptr _ & @xmath144 & правый подпроход + _ матрица _ & q & группа симметрии элемент + _ вектор _ & @xmath128 & @xmath136 + _ вектор _ & @xmath129 & @xmath160 + _ целое число _ & @xmath130 & @xmath161 + _ ограничивающая рамка _ & @xmath162 & выпуклая область ' \" \" + листья дерева пилы соответствуют участкам в пиле, и, таким образом, помечаются от 0 до @xmath50. бинарное дерево с листьями @xmath5 имеет внутренние узлы @xmath50, и мы помечаем эти узлы от 1 до @xmath50, так что симметрия @xmath68 находится слева от @xmath163. симметрия @xmath164 не является частью дерева распиловки, поскольку она применяется ко всему обходу и, следовательно, не может быть использована в операции слияния. для некоторых приложений может потребоваться отслеживать @xmath164, например, при изучении полимеров в ограниченной области, но в @xcite в этом не было необходимости.    предположим, что заданы сквозные векторы @xmath128 и элементы группы симметрии @xmath68 для дерева пилы и его левого и правого дочерних элементов. если мы знаем местоположение узла привязки родительского узла, @xmath165, наряду с общим элементом группы _ absolute _ symmetry @xmath166, применяемым к обходу, мы можем затем найти ту же информацию для левого и правого дочерних узлов следующим образом: @xmath167 таким образом, @xmath85 может быть определен для любой сайт @xmath53 путем итеративного выполнения этого вычисления, следуя (уникальному) пути от корня дерева пилы к соответствующему листу. примечание: @xmath165 должен быть обновлен до @xmath166. мы приводим явные примеры пиломатериалов в приложении [ sec : examplesawtrees ]. на рис. [ рис. : sawtree_sequence ], мы даем древовидное представление пилы с сайтами @xmath5, которое в точности эквивалентно представлению сводной последовательности. мы также даем два эквивалентных представления @xmath86 (показано на рис. 1). [ рис. : пример ] ) на фиг. [ рис. : sawtree_exampleaa ] и [ рис. : sawtree_exampleab ]. концептуально мы отличаем прогулки по одному участку (отдельные сайты), которые находятся в листьях дерева, от прогулок по нескольким участкам. в частности, элемент группы симметрии отдельного участка не имеет никакого эффекта, и в случае, когда все мономеры идентичны, тогда все отдельные участки идентичны.    если структура пилообразного дерева остается фиксированной, невозможно повернуть часть обхода путем обновления одного элемента группы симметрии, в отличие от представления последовательности поворотов. это связано с тем, что когда мы изменяем элемент группы симметрии в данном узле, это изменяет положение только тех узлов, которые находятся в правом дочернем элементе узла. чтобы повернуть часть обхода с участками, помеченными @xmath168 и выше, мы выбираем внутренний узел @xmath169 дерева пилы слева. затем нам нужно изменить элемент группы симметрии этого узла, а также все узлы, которые находятся выше и справа от него в дереве пилы. если мы выберем случайный узел, то он, скорее всего, будет находиться рядом с листьями дерева, и если предположить, что дерево пилы сбалансировано, это означает, что в среднем элементы группы симметрии @xmath3 необходимо будет изменить.    однако мы отмечаем, что корневой узел в верхней части дерева не имеет родительских элементов, и поэтому для поворота правой части дерева необходимо изменить только один элемент группы симметрии. в данном случае - прогулка. используя операции поворота дерева, которые изменяют структуру дерева при сохранении порядка узлов, можно переместить узел @xmath169 в корень дерева пилы. как только это будет сделано, можно будет реализовать поворот части обхода путем обновления одного элемента группы симметрии. в среднем требуется @xmath3 из этих операций поворота дерева. бинарные деревья являются стандартной структурой данных в информатике. требуя, чтобы деревья были сбалансированы, т.е. чтобы высота дерева с узлами @xmath0 была ограничена постоянным значением @xmath170, можно получить оптимальные границы для таких операций, как вставка и удаление узлов из дерева. мы отсылаем заинтересованного читателя к sedgewick @xcite для получения информации о различных реализациях сбалансированных деревьев, таких как красно - черные сбалансированные деревья. у нас есть преимущество в том, что наше дерево распилов, по сути, статично, что означает, что мы можем сделать его идеально сбалансированным без дополнительных затрат на поддержание сбалансированного дерева. в этот подраздел включены примитивные операции, которые обычно не вызываются из основной программы. повороты дерева влево и вправо являются модифицированными версиями стандартных операций с деревом; для бинарных деревьев необходимо сохранить только порядок, в то время как для пилообразных деревьев необходимо сохранить последовательность узлов, что означает, что необходимо изменить элементы группы симметрии и другие переменные. * процедура : * [ cols=\"\u003c,^, \u003c \", ] дочерний узел[leaf ] @xmath171 дочерний узел[leaf ] @xmath172    ; 

алгоритм pivot для самостоятельного избегания прогулок был реализован способом, который значительно быстрее, чем предыдущие реализации, что позволяет эффективно моделировать чрезвычайно длительные прогулки. мы явно описываем используемые структуры данных и алгоритмы и приводим эвристический аргумент о том, что среднее время на попытку поворота для обходов с самообороной в @xmath0 шагов равно @xmath1 для квадратных и простых кубических решеток. численные эксперименты, проведенные для самостоятельных обходов с числом шагов до 268 миллионов, согласуются с поведением @xmath2 для квадратной решетки и поведением @xmath3 для простой кубической решетки. наш метод может быть адаптирован к другим моделям полимеров с короткодействующими взаимодействиями, на решетке или в континууме, и, следовательно, обещает быть широко полезным. 0 + + * ключевые слова * самоустраняющееся блуждание ; полимер ; монте-карло ; алгоритм поворота 0 0