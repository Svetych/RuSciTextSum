при квантовой обработке информации информация хранится и обрабатывается с помощью квантовой системы. квантовая система всегда находится в контакте с окружающей ее средой, что приводит к декогеренции в квантовой системе. декогеренция должна быть подавлена, чтобы квантовая информация, хранящаяся в кубитах, оставалась неповрежденной. существует несколько предложений по борьбе с декогеренцией. квантовая коррекция ошибок, сокращенно qec, является одним из наиболее многообещающих кандидатов для подавления шума окружающей среды, который приводит к декогеренции @xcite. добавляя дополнительные вспомогательные кубиты, по аналогии с классической коррекцией ошибок, можно закодировать кубит данных в кодовое слово @xmath4-кубит таким образом, что ошибка, которая действовала в квантовом канале ошибок, идентифицируется путем измерения другого набора вспомогательных кубитов, добавленных для считывания синдрома ошибки. затем правильное кодовое слово восстанавливается из кодового слова, содержащего возможную ошибку, путем применения операции восстановления, явная форма которой определяется показаниями синдрома ошибки. в отличие от обычной схемы, описанной в предыдущем параграфе, существует схема, в которой не требуются ни показания синдрома, ни вспомогательные кубиты для считывания синдрома @xcite. в частности, в @xcite была предложена общая эффективная схема. кубит данных кодируется вспомогательными кубитами кодирования по той же схеме кодирования, что и обычная, после чего к кодовому слову применяется зашумленный канал. впоследствии к кодовому слову применяется обратная схема кодирования, которая, возможно, страдает от ошибки. результирующее состояние является тензорным произведением состояния кубита данных с возможной ошибкой и состояния вспомогательного кубита. можно исправить ошибочное состояние кубита данных, применив корректирующие элементы с вспомогательными кубитами в качестве управляющих кубитов и кубитом данных в качестве целевого кубита. в этой статье представлены два примера кодов исправления ошибок, относящихся ко второй категории. предполагается, что зашумленный квантовый канал полностью коррелирован @xcite, что означает, что все кубиты, составляющие кодовое слово, подвержены одним и тем же операторам ошибок. в большинстве физических реализаций квантового компьютера размер системы обычно составляет порядка нескольких микрометров или меньше, в то время как шум окружающей среды, такой как электромагнитная волна, имеет длину волны порядка нескольких миллиметров или сантиметров. тогда естественно предположить, что все кубиты в регистре страдают от одного и того же оператора ошибки. чтобы продемонстрировать преимущество второй категории, ниже мы ограничимся шумовыми операторами @xmath7, где @xmath3 - это количество составляющих кубитов в кодовом слове. мы показываем, что существует кодировка @xmath4-кубита, которая поддерживает состояние данных @xmath5-кубита, если @xmath4 нечетное, и состояние даты @xmath6-кубита, если @xmath4 четное. хотя канал является несколько искусственным в качестве канала для ошибок, мы можем применить нашу схему исправления ошибок в следующей ситуации. предположим, Алиса хочет отправить кубиты Бобу. их базы кубитов отличаются унитарными операциями @xmath8 или @xmath9. даже если они не знают, какой базис использует другая сторона, они могут корректно отправлять кубиты, добавляя один дополнительный кубит (когда @xmath4 нечетный) или два дополнительных кубита (когда @xmath4 четный).    мы формулируем теоремы и доказываем их в следующем разделе. последний раздел посвящен краткому изложению и обсуждениям. далее @xmath10 обозначает @xmath11-ю компоненту матриц Паули, и мы берем базисные векторы @xmath12 так, чтобы @xmath13 был диагонализирован. мы вводим операторы @xmath14 и @xmath15, действующие в пространстве @xmath4-кубита @xmath16, где @xmath3, как упоминалось ранее. пусть @xmath17 - комплексные матрицы @xmath18, и пусть @xmath19. обозначим через @xmath20 (совместный) ранг-@xmath21 числовой диапазон @xmath22, который является набором @xmath23 таким, что @xmath24 для некоторого @xmath18 ранг-@xmath21 ортогональная проекция @xmath25 @xcite. квантовый канал вида @xmath26 имеет @xmath21-мерный квантовый код коррекции ошибок (qecc) тогда и только тогда, когда @xmath27. чтобы доказать это утверждение, нам нужно вспомнить условие корректируемости Книлла - Лафламма, которое утверждает, что при заданном квантовом канале @xmath28 с операторами ошибок @xmath29, @xmath30 является qecc из @xmath31 тогда и только тогда, когда @xmath32, где @xmath33 - оператор проекции с пространством диапазона @xmath30 @заходите. должно быть ясно, что @xmath34 тогда и только тогда, когда существует qecc с измерением @xmath21. теперь из @xmath35 и соотношений @xmath36, когда @xmath4 четно, и @xmath37, когда @xmath4 нечетно, следует, что канал ( [ eq : corrch ] ) имеет @xmath21-мерный qecc тогда и только тогда, когда @xmath38 отметив, что @xmath39 независимо от ранга @xmath25, мы находим @xmath40 тогда и только тогда, когда @xmath41. [ thm1 ] предположим, что @xmath3 нечетно. тогда @xmath42. наше доказательство конструктивно. для @xmath43 обозначим @xmath44. пусть @xmath45, затем @xmath46, где @xmath47 - это количество @xmath48-комбинаций из элементов @xmath4. поскольку @xmath49 у нас есть @xmath50, пусть @xmath25 будет ортогональной проекцией на @xmath30. тогда приведенное выше наблюдение показывает, что @xmath51 и @xmath52. следовательно, @xmath53, который показывает, что @xmath54 и, следовательно, @xmath30 показаны как @xmath55-мерный qecc. _ теперь давайте обратимся к четному случаю @xmath4. сначала мы сформулируем лемму, которая необходима для доказательства теоремы. [ лем1 ] пусть @xmath56 - нормальная матрица. тогда числовой диапазон ранга @xmath21 для @xmath57 является пересечением выпуклых оболочек любых @xmath58 собственных значений для @xmath57. доказательство леммы находится в @xcite. [ thm2 ] предположим, что @xmath3 четно. тогда @xmath59, но @xmath60.    _ доказательство пусть @xmath61. по теореме [ thm1 ], @xmath62. рассмотрим @xmath63 заметим, что проекция @xmath25 на @xmath64 удовлетворяет @xmath65 и @xmath52 и, следовательно, @xmath66, что доказывает @xmath59. _ поскольку @xmath67 является коммутирующим семейством, @xmath8 и @xmath9 могут быть диагонализированы одновременно. мы можем предположить, что @xmath68, поскольку @xmath69, у нас есть @xmath70, давайте покажем, что @xmath71. сначала отметим тождество @xmath72 для эрмитова @xmath73. давайте заменим @xmath74 на @xmath75 и @xmath76 на @xmath77, чтобы получить @xmath78. поскольку @xmath75 и @xmath77 коммутируют, @xmath79 является нормальным, и применима лемма [ лем1 ]. из уравнений. ( [ eq1 ] ) и ( [ eq2 ] ), мы находим, что @xmath79 имеет собственные значения @xmath80, и каждое собственное значение вырождено в @xmath81 раз. взяв @xmath82 и @xmath83 в лемме [ лем1 ], мы находим ранг-@xmath55 числовой диапазон @xmath79 является пересечением выпуклых оболочек любых @xmath84 собственных значений. поскольку каждое собственное значение имеет кратность @xmath81, каждая выпуклая оболочка содержит по меньшей мере три собственных значения. проверяя четыре собственных значения, нанесенных на комплексную плоскость, мы легко находим, что пересечение всех выпуклых оболочек является единственной точкой @xmath85, что доказывает @xmath71. аналогично, мы доказываем @xmath86. из этих равенств мы получаем @xmath87 предположим, что @xmath42. пусть @xmath25 - проекция ранга @ xmath55, такая, что @xmath88. пусть @xmath89\\ ] ] где каждый @xmath90 имеет размер @xmath91. из @xmath92 и @xmath93 у нас есть четыре независимых уравнения @xmath94 пусть @xmath95 - разложение по сингулярным значениям @ xmath96, где @xmath97 - неотрицательная диагональная матрица и @ xmath98. затем приведенные выше уравнения решаются как @xmath99, собирая эти результаты, мы обнаруживаем, что оператор проекции декомпозируется как @xmath100 \\[\\begin{array}{cc}d&d\\\\ d&d\\end{array}\\]\\[\\begin{array}{cc}u^\\dagger&0\\\\ 0&v^\\dagger\\end{array}\\]\\,.\\ ] ] поскольку ранжируются @xmath101 и @xmath102, из @xmath103 следует, что @xmath104. пусть @xmath105, тогда и @xmath57, и @xmath106 не являются сингулярными. с другой стороны, предположение @xmath107 подразумевает @xmath108 и, следовательно, @xmath109, что является противоречием. следовательно, @xmath60.    далее мы приводим явную конструкцию qecc для @xmath31 в уравнении. ( [ eq : corrch ] ) с нечетным @xmath4. методика основана на теореме [ thm1 ] и результатах в @xcite. пусть @xmath110 - матрица @xmath111 со столбцами в наборе @xmath112 определяет матрицу @xmath113 @xmath114 $ ]. в нашем qec состояние @xmath5-кубита @xmath115 кодируется одним вспомогательным кубитом @xmath116 как @xmath117. затем к закодированному состоянию применяется зашумленный квантовый канал @xmath31, а затем применяется операция восстановления @xmath118, так что декодированное состояние автоматически появляется на выходе без каких-либо измерений синдрома. наш qec кратко суммируется как @xmath119, где @xmath120. выбор кодировки равносилен присвоению каждому из векторов столбцов @xmath81 в @xmath110 базисного вектора всего гильбертова пространства без повторений. следовательно, существуют большие степени свободы в выборе кодирования. в следующих примерах мы выбрали кодирование, квантовая схема которого может быть реализована с наименьшим количеством элементов cnot. поскольку наша схема декодирования является обратной схеме кодирования, она также реализована с наименьшим количеством элементов cnot.    когда @xmath121, унитарная операция @xmath122 может быть выбрана как @xmath123, когда @xmath124, @xmath122 может быть выбрана как @xmath125 на рисунке [ nodd ] показаны квантовые схемы матрицы @xmath122 для @xmath126 и @xmath127. [ nodd ] - состояние кубита @xmath115 с одним вспомогательным кубитом, изначально находящимся в состоянии @xmath128. ( a ) для @xmath126, в то время как ( b ) для @xmath127. квантовый канал во вставке представляет собой квантовую операцию с полностью коррелированным шумом, приведенным в уравнении. выходное вспомогательное состояние равно @xmath129 для операторов ошибок @xmath130 и @xmath131 ( @xmath132 и @xmath133 ) для @xmath126 и @xmath129 для @xmath134 и @xmath135 ( @xmath136 и @xmath137 ) для @xmath127.,ширина=529 ] это следует из уравнения. ( [ qecc ] ), что схема восстановления является обратной схеме кодирования. на первый взгляд кажется, что реализации, приведенные на рис. 1, противоречат уравнению. ( [ qecc ] ), поскольку управляемый элемент not в конце схемы восстановления отсутствует в схеме кодирования. обратите внимание, однако, что верхний кубит изначально установлен в @xmath138, а управляемый элемент not безопасно опущен без каких-либо последствий.ng-кодирование. мы создаем кодировку без декогеренции, когда @xmath4 является четным, следующим образом. кодовое слово в этом случае невосприимчиво к операторам шума, что является аналогом бесшумного подпространства / подсистемы, представленного в @xcite. пусть @xmath139, тогда, очевидно, вектор @xmath140 отдельно инвариантен под действием @xmath141 и @xmath9. существуют ортогональные векторы @xmath142 такой формы, например, у нас есть четыре вектора, @xmath143 для @xmath144. таким образом, мы находим кодировку без декогеренции для кубитов @xmath145, проецируя на это инвариантное подпространство, охватываемое этим базисом. следует отметить, что оператор проекции @xmath25 на подпространство @xmath146, охватываемое четырьмя векторами в уравнении. ( [ nss ] ) удовлетворяет рангу @xmath147 и @xmath148, что показывает @xmath149. легко обобщить этот результат на случаи с произвольным @xmath150. на рисунках [ neven ] ( a ) и ( b ) изображены квантовые схемы для ( a ) @xmath144 и ( b ) @xmath151 соответственно. [ neven ] -состояние кубита @xmath115 с двумя вспомогательными кубитами, изначально находящимися в состоянии @xmath152. ( a ) для @xmath144, в то время как ( b ) для @xmath151. квантовый канал во вставке представляет собой квантовую операцию с полностью коррелированным шумом, приведенным в уравнении. выходное вспомогательное состояние всегда равно @xmath153, независимо от того, какие операторы ошибок действовали в канале.,ширина=529 ] мы показали, что существует квантовая коррекция ошибок, которая подавляет полностью коррелированные ошибки вида @xmath154, в котором для кодирования (i) кубита данных @xmath155 требуются кубиты @xmath4 состояния, когда @xmath4 нечетно, и (ii ) состояния кубита данных @xmath156, когда @xmath4 четно. мы доказали эти утверждения, используя технику теории операторов. в нашей схеме не требуются ни измерения синдрома, ни вспомогательные кубиты для измерения синдрома, что делает физическую реализацию нашей схемы весьма практичной. подробно проанализированы примеры с @xmath126 и @xmath127, и были получены явные квантовые схемы, реализующие наш qec с наименьшим числом элементов cnot. поскольку операторы error закрыты при умножении матрицы, ошибки могут быть исправлены, даже если они воздействуют на кодовое слово много раз. о чем-то подобном qec сообщалось в @xcite. они проанализировали частично коррелированный шум, где операторы ошибок воздействуют на фиксированное количество кубитов кодового слова одновременно. они показали, что ограничение квантовой упаковки было нарушено за счет использования преимуществ вырождения кодов. однако физическое обоснование такого шума представляется довольно сложным. они также показали, что коррелированный шум, воздействующий на произвольное число @xmath4 кубитов, может кодировать @xmath157 кубитов данных. напротив, мы проанализировали полностью коррелированный шум, который показывает наибольшее вырождение, и показали, что кубиты данных @xmath158 могут быть закодированы кодовым словом @xmath4-кубит, когда @xmath4 нечетное. очевидно, что наш qec, подавляющий полностью коррелированные ошибки, является оптимальным, поскольку ясно, что нельзя кодировать кубиты @xmath4 в качестве кубитов данных для нечетного @xmath4, и мы показали, что нельзя кодировать кубиты @xmath155 для четного @xmath4. 

мы исследуем эффективную квантовую коррекцию ошибок полностью коррелированного шума. предположим, что шум характеризуется квантовым каналом, операторы ошибок которого принимают полностью коррелированные формы, заданные @xmath0, @xmath1 и @xmath2, где @xmath3 - количество кубитов, кодирующих кодовое слово. доказано, что (i) кодовое слово @xmath4 qubits кодирует кубиты данных @xmath5, когда @xmath4 нечетное, и (ii ) кодовое слово @xmath4 qubits реализует безошибочное кодирование, которое кодирует кубиты данных @xmath6, когда @xmath4 четное. построены квантовые схемы, реализующие эти схемы. квантовая коррекция ошибок, числовой диапазон более высокого ранга, оператор восстановления, смешанный унитарный канал