проблема одновременной локализации и картографирования (slam) имеет богатую историю за последние два десятилетия, которая слишком широка, чтобы охватывать ее здесь, см., например, @xcite. slam на основе расширенного фильтра Калмана (ekf) (ekf - slam) сыграл важную историческую роль и используется до сих пор, в частности, благодаря своей способности замыкать циклы благодаря поддержанию корреляций между удаленными ориентирами.    тот факт, что ekf - slam непоследователен (то есть он возвращает слишком оптимистичную ковариационную матрицу, см., например, @xcite, что приводит к неточным оценкам), был замечен ранее @xcite и с тех пор был объяснен в различных статьях @xcite. в настоящей статье мы рассматриваем проблемы несогласованности, которые проистекают из того факта, что, поскольку доступны только относительные измерения, происхождение и ориентация неподвижной на земле системы координат никогда не могут быть правильно оценены, но ekf - slam склонен думать, что \"он может оценить их, поскольку его выходная ковариационная матрица отражает информацию выигрыш в этих направлениях пространства состояний. это отсутствие наблюдаемости и слабая способность ekf справляться с этим, в частности, рассматриваются как основная причина несогласованности в @xcite (см. также ссылки в нем). в настоящей статье мы выступаем за использование инварианта (i)-ekf для предотвращения уменьшения ковариации в направлениях пространства состояний, где информация недоступна. инвариантный расширенный фильтр Калмана (iekf) - это новая методология, представленная в @ xcite, которая заключается в незначительном изменении уравнений ekf, чтобы они соответствовали геометрической структуре задачи. зарезервированный для систем, определенных на группах ли, он в основном использовался в приложениях для локализации и наведения, где он выглядит как небольшая модификация мультипликативного ekf (mekf), широко известного и используемого в мире аэронавтики. было доказано, что он обладает теоретическими свойствами локальной конвергенции, которых нет у ekf в @ xcite, является улучшением по сравнению с ekf на практике (см., например, @xcite и совсем недавно @xcite, где ekf превосходит ekf), и был успешно реализован в промышленных приложениях для навигации (см. патент @xcite ).    в настоящей статье мы немного обобщаем структуру iekf, чтобы сделать ее способной обрабатывать очень общие наблюдения (такие как дальность и пеленг или наблюдения только по пеленгу), и мы показываем, как производный iekf - slam, простой вариант ekf - slam, позволяет устранить несоответствие ekf - slam вытекающий из ненаблюдаемости ориентации и происхождения глобальной структуры. проблема несоответствия ekf - slam была предметом многих работ, смотрите @xcite, чтобы процитировать несколько, где были собраны эмпирические данные (с помощью моделирования методом Монте-Карло) и теоретические объяснения в различных конкретных ситуациях. в частности, выводы @xcite заключались в том, что неопределенность ориентации является ключевой особенностью несогласованности. статья @xcite, в соответствии с @xcite, также подчеркивает важность процесса линеаризации, поскольку линеаризация относительно истинной траектории решает проблемы несогласованности, но ее невозможно реализовать на практике, поскольку истинное состояние неизвестно. он выводит соотношение, которое должно сохраняться между различными якобианами, появляющимися в уравнениях ekf, когда они оцениваются при оценке текущего состояния, чтобы обеспечить согласованность. чуть позже в работах Г.п. Хуанга, А.и. Мурикиса и С. и. румелиотиса @xcite был представлен обоснованный теоретический анализ несоответствия ekf - slam, вызванного неспособностью ekf корректно отражать три ненаблюдаемые степени свободы (как общее вращение и преобразование глобальной системы отсчета оставляет все измерения неизменными ). действительно, фильтр имеет тенденцию ошибочно получать информацию по направлениям, охватываемым этими ненаблюдаемыми преобразованиями. чтобы устранить эту проблему, вышеупомянутые авторы предложили различные решения, наиболее продвинутым из которых является ограничение наблюдаемости (oc)-ekf. идея состоит в том, чтобы выбрать точку линеаризации таким образом, чтобы ненаблюдаемое подпространство, \"видимое\" моделью системы ekf, имело соответствующую размерность, минимизируя при этом ожидаемые ошибки точек линеаризации.    наш подход, основанный на iekf, представляет интересную альтернативу oc - ekf, основанную на совершенно другом маршруте. действительно, логическим обоснованием является применение методологии ekf, но с использованием альтернативных ошибок оценки стандартной линейной разницы между оценкой и истинным состоянием. любая нелинейная ошибка, отражающая несоответствие между истинным состоянием и оценкой, обязательно определяет локальную структуру вокруг любой точки, и идея, лежащая в основе iekf, сводится к записи якобианов Калмана и ковариаций в этой структуре. здесь мы замечаем и доказываем, что альтернативная нелинейная ошибка определяет локальный фрейм, в котором ненаблюдаемое подпространство _ везде _ охватывается одними и теми же векторами. будет показано использование этого локального фрейма в текущей оценке для выражения ковариационной матрицы Калмана, чтобы гарантировать, что ненаблюдаемое подпространство, \"видимое\" моделью системы ekf, автоматически имеет соответствующую размерность. таким образом, мы получаем вариант ekf, который автоматически обладает свойствами согласованности. более того, мы связываем ненаблюдаемость с обратной ковариационной матрицей (называемой информационной матрицей), а не с самой ковариационной матрицей, и мы получаем гарантии уменьшения информации в ненаблюдаемых направлениях. в отличие от oc - ekf и, как и в стандартном ekf, мы используем здесь последнюю и, следовательно, наилучшую оценку состояния в качестве точки линеаризации для вычисления якобианов фильтра.    в двух словах, в то время как ключевым фактом для анализа @xcite является то, что выбор точки линеаризации влияет на свойства наблюдаемости системы ошибок линеаризованного состояния ekf, ключевым фактом для нашего анализа является то, что выбор переменной ошибки имеет аналогичные последствия. теоретические результаты и моделирование подчеркивают актуальность предлагаемого подхода. роботоцентрические формулировки, такие как @xcite и более поздние @xcite, являются многообещающими попытками решения проблемы ненаблюдаемости, но, к сожалению, им не хватает удобства, поскольку положение всех ориентиров должно быть пересмотрено на этапе распространения, так что предполагаемое положение ориентиров, в свою очередь, становится чувствительным к шуму датчика движения. они доказуемо не решают проблемы наблюдаемости, рассмотренные в настоящей статье, и можно отметить, что oc - ekf продемонстрировал лучшую экспериментальную производительность, чем робоцентрический картографический фильтр в @ xcite. в частности, в совсем недавних статьях @xcite предлагается записать уравнения slam в кадре робота в предположении о постоянной скорости. используя метод ввода выходных данных, эти уравнения становятся линейными, позволяя доказать глобальную асимптотическую сходимость любого линейного наблюдателя для соответствующей детерминированной линейной модели. это фундаментально детерминированный подход и свойство, и поскольку матрицы, появляющиеся в полученной линейной модели, являются функциями наблюдений, поведение фильтра нелегко предвидеть в зашумленном контексте: шум наблюдения, таким образом, искажает сам этап распространения фильтра. в некоторых недавних статьях также предлагается улучшить согласованность путем объединения локальных карт, см. @xcite и ссылки на него. несмотря на привлекательность, этот подход скорее ориентирован на крупномасштабные карты и требует наличия локальных подкарт. но при использовании алгоритма объединения подкарт несогласованность даже в одной из подкарт приводит к несогласованной глобальной карте \" @xcite. таким образом, этот подход может оказаться дополнительным, если для построения согласованных подкарт используется iekf slam, предложенный в настоящей статье. обратите внимание, что slam iekf также можно легко комбинировать с другими измерениями, такими как gps, в то время как подход submap адаптирован для чистого slam.    с точки зрения методологии, стоит отметить, что наш подход не учитывает ошибки оценки, записанные во фрейме робота, как @xcite. хотя ошибки оценки, которые мы используем, также основаны на симметриях, немного сложнее.    наконец, методы нелинейной оптимизации недавно стали популярными для slam, см., например, @xcite в качестве одной из первых статей. связи между нашим подходом и этими новыми методами обсуждаются в заключении статьи. статья организована следующим образом. в разделе [sec:1 ] рассматриваются стандартные уравнения ekf и алгоритм ekf - slam. в разделе [ sec:2 ] мы напоминаем о проблеме, заключающейся в том, что ни происхождение, ни ориентация глобального фрейма не поддаются наблюдению, но ekf - slam систематически склонен думать, что \"он наблюдает их\", что приводит к несогласованности. в разделе [ sec:22 ] мы представляем алгоритм iekf - slam. в разделе [ sec:3 ] мы показываем, как линеаризованная модель iekf всегда корректно фиксирует рассматриваемые ненаблюдаемые направления. в разделе [ раздел::инструменты ] мы выводим свойство ковариационной матрицы, выводимой фильтром, которое может быть интерпретировано в терминах информации Фишера. в разделе [ раздел:4 ] моделирование подтверждает теоретические результаты и иллюстрирует преимущества предлагаемого алгоритма. наконец, теория iekf @xcite кратко изложена в приложении, и показано, что iekf slam действительно является применением этой теории. уравнения iekf slam в 3d затем также выводятся с применением общей теории. рассмотрим общую динамическую систему в дискретном времени с состоянием @xmath0, связанным с последовательностью наблюдений @xmath1. уравнения следующие: @xmath2 @xmath3, где @xmath4 - функция, кодирующая эволюцию системы, @xmath5 - шум процесса, @xmath6 - входные данные, @xmath7 - функция наблюдения и @xmath8 - шум измерения. ekf распространяет оценку @xmath9, полученную после наблюдения @xmath10, через детерминированную часть : @xmath11 обновление @xmath12 с использованием нового наблюдения @xmath13 основано на аппроксимации нелинейной системы первого порядка, вокруг оценки @xmath14, в отношении ошибок оценки @xmath15 определяетd как : @xmath16, используя якобианы @xmath17, @xmath18 и @xmath19, комбинацию уравнений, и приводит к следующему разложению системы ошибок первого порядка @xmath20, где члены второго порядка, то есть члены порядка @xmath21, были удалены в соответствии со стандартным способом, который используется в системе ошибок. ekf обрабатывает неаддитивные шумы в модели (см., например, @xcite, стр. 386). используя линейные уравнения Калмана с @xmath22, вычисляется коэффициент усиления @xmath23, а с учетом @xmath24 вычисляется оценка @xmath25 ошибки @xmath26, учитывающей наблюдение @xmath13, наряду с его ковариационная матрица @xmath27. состояние обновляется соответствующим образом: @xmath28 подробные уравнения вызываются в алгоритме [ algo::ekf ]. предположение, лежащее в основе ekf, заключается в том, что посредством аппроксимаций первого порядка _ эволюции ошибки состояния _ линейные уравнения Калмана позволяют вычислять гауссовскую аппроксимацию ошибки @xmath29 после каждого измерения, дает приблизительное значение искомой плотности @xmath30. однако применяемые линеаризации приводят к неизбежным приближениям, которые могут привести фильтр к несогласованности, а иногда даже к расхождению. определите @xmath31 и @xmath32 через и. определите @xmath33 как @xmath34 и @xmath35 как @xmath36. * распространение * @xmath37 @xmath38 * обновление * @xmath39 @xmath40, @xmath41 @xmath42p_{n|n-1 } $ ] для простоты давайте сосредоточимся на стандартной модели управляемого велосипеда (или одноколесного велосипеда) @xcite. состояние определяется как : @xmath43, где @xmath44 обозначает направление, @xmath45 - положение робота/ транспортного средства в 2d, @xmath46 - положение неизвестного ориентира, @xmath47 (ориентиры или, как их синонимы, объекты, составляющие карту). уравнения модели таковы: @xmath48, где @xmath49 обозначает основанную на одометрии оценку изменения курса транспортного средства, @xmath50 - основанную на одометрии индикацию относительного смещения, @xmath51 и @xmath52 связанные с ними шумы, а @xmath53 - матрица, кодирующая поворот на угол @xmath54 : @xmath55 обратите внимание, что прямая дискретизация Эйлера хорошо известных уравнений одноколесного цикла с непрерывным временем приводит к тому, что @xmath50 имеет нулевую вторую запись. более сложные методы интеграции или модели, включая боковое смещение, все же могут привести к ненулевым значениям обеих записей @xmath56, поэтому мы выбираем более общую модель с @xmath50. ковариационная матрица шумов будет обозначаться @xmath57 с помощью @xmath58. общее знаковое наблюдение в кадре робота гласит: @xmath59+v_n ^ 1 \\\\\\vdots \\\\\\тильда h \\left [ r(\\theta_n)^t \\left ( p^k - x_n \\right ) \\right]+v_n^k \\end{pmatrix}\\ ] ] где @xmath60 (или @xmath61 для монокулярного визуального шлема ) - это наблюдение объектов на временном шаге @xmath62, а @xmath8 - шум наблюдения, а @xmath63 - любая функция. в момент времени @xmath62 фактически наблюдается только подмножество объектов. однако, чтобы упростить отображение уравнений фильтров, в дальнейшем мы систематически предполагаем, что наблюдаются все объекты. мы позволяем выходной ковариационной матрице шума быть @xmath64 обратите внимание, что модель наблюдения охватывает обычные наблюдения диапазона и пеленга, используемые в задаче slam, позволяя @xmath65. если мы выберем вместо этого одномерное наблюдение @xmath66, мы восстановим двумерное измерение с помощью монокулярного шлема. обратите также внимание, что мы не предоставляем какой-либо конкретной формы для шума в выходных данных: это связано с тем, что свойства, которые мы собираемся доказать, связаны с наблюдаемостью и, следовательно, зависят только от детерминированной части системы, поэтому они фактически полностью нечувствительны к тому, как шум попадает в систему. мы просто применяем здесь методологию ekf к задаче slam, описанной в разделе [ раздел::slam_problem ]. разложения первого порядка, применяемые к уравнениям, дают: @xmath67 с @xmath68, @xmath69 и @xmath70 обозначает якобиан @xmath63, вычисленный в @xmath71 \\в { { \\mathbb r}}^2 $ ]. полученный алгоритм ekf - slam повторяется в алгоритме [ algo::ekf_slam_linear ]. определите @xmath31 и @xmath32, как в. определите @xmath33, @xmath35 как в и. * распространение * для всех @xmath72 @xmath38 * обновление * @xmath73 \\\\\\vdots \\\\\\тильда h \\left [ r(\\hat \\theta_{n|n-1})^t \\left ( \\hat p^k_{n|n-1}- \\hat x_{n|n-1 } \\right ) \\right ] \\end{pmatrix}$ ] @xmath40, @xmath41 @xmath42p_{n|n-1 } $ ] в этом разделе мы возвращаемся к общей структуре,. стандартная проблема наблюдаемости @xcite по своей сути является детерминированным понятием, поэтому шум систематически отключается.    [ def::non_obs ] мы говорим, что преобразование @xmath74 системы - ненаблюдаемо, если для любых начальных условий @xmath75 и @xmath76 индуцированные решения динамики с отключенным шумом, т.е. @xmath77 дают один и тот же результат на каждом временном шаге @xmath78, то есть : @xmath79 это конкретно означает, что (при отключенных всех шумах), если преобразование применяется к исходному состоянию, то ни одно из наблюдений @xmath13 не будет затронуто. как следствие, нет способа узнать, было ли применено это преобразование. в соответствии с @xcite мы сосредоточимся здесь на свойствах наблюдаемости линеаризованной системы. с этой целью мы определяем понятие ненаблюдаемого (или ненаблюдаемого ненаблюдаемого) сдвига, которое является бесконечно малым аналогом определения [ def::non_obs ] и тесно связано с бесконечно малой наблюдаемостью @xcite : [ def::non_obs_first_order ] пусть @xmath80 обозначает решение с отключенным шумом. вектор @xmath81 называется ненаблюдаемым сдвигом - вокруг @xmath82, если : @xmath83, где @xmath32 - линеаризация @xmath7 в @xmath84 и где @xmath85 - решение в @xmath62 линеаризованной системы @xmath86, инициализированной в @xmath87, с @xmath88, обозначающей матрицу якоби. из @xmath89, вычисленного по адресу @xmath90.    другими словами (см., например, @xcite ), для всех @xmath91, @xmath85 находится в ядре матрицы наблюдаемости между шагами @xmath92 и @xmath62, связанными с линеаризованной моделью системы с состоянием ошибки, т.е. @xmath93=0 $]. интерпретация следующая: рассмотрим другой начальный состояние изменилось с @xmath82 на @xmath94. утверждение, что @xmath87 ненаблюдаемо, означает, что между обеими траекториями не может быть обнаружено никакой разницы в последовательности наблюдений вплоть до первого порядка. формально это условие гласит: @xmath95, т.е. @xmath96. метод оценки, передающий свою собственную неопределенность оценки, поскольку ekf, хотя и основанный на линеаризациях, должен быть способен обнаруживать такие направления и отражать, что точные оценки по таким направлениям недоступны.      в настоящей статье мы рассматриваем ненаблюдаемость, соответствующую невозможности наблюдать положение и ориентацию глобального фрейма @xcite. соответствующие сдвиги уже были получены в литературе. [ prop::first_order_rotations_prelim]@xcite пусть @xmath97 будет оценкой состояния. рассматривается только один признак, обобщение предложения на несколько признаков тривиально. возмущение первого порядка оценки, соответствующее бесконечно малому повороту на угол @xmath98 глобальной системы отсчета, состоит из сдвига @xmath99 на @xmath100. таким же образом, возмущение первого порядка оценки, соответствующее бесконечно малому перемещению глобального фрейма вектора @xmath101, состоит из сдвига @xmath102. при повороте глобального фрейма заголовок становится : @xmath103 положение робота становится : @xmath104 положение объекта становится : @xmath105 суммируя эти результаты, мы получаем изменение полного вектора состояния первого порядка (только в отношении поворота, эффект бесконечно малого перемещения тривиален для получения) : @xmath106 [ prop::first_order_rotations]@xcite сдвиги предложения [ prop::first_order_rotations ], которые соответствуют бесконечно малым поворотам, являются ненаблюдаемыми сдвигами - в смысле определения [ def::non_obs_first_order ]. интуитивное объяснение ясно @xcite: `если позиции робота и ориентира равны смещенные одинаково вдоль этих векторов, с помощью измерений будет невозможно отличить смещенное положение от исходного. \" в этом разделе напоминается об использовании обозначений из настоящей статьи, результата @xcite. это показывает, что бесконечно малые вращения, определенные в предложении [ prop::first_order_rotations ], в общем случае не являются ненаблюдаемыми сдвигами системы, линеаризованной относительно траектории, оцененной ekf. действительно, применение определения [ def::non_obs_first_order ] к в случае единственной функции (обобщение является простым) с помощью @xmath107 и @xmath108 приводит к тому, что условие для бесконечно малого поворота начального состояния является ненаблюдаемым для линеаризованной системы. это условие записывает @xmath109 и сводится к тому, что для любого @xmath110 (см. @xcite ) : @xmath111=0\\ ] ] где @xmath112 - это якобиан @xmath63, вычисленный в @xmath113. например, если @xmath63 обратимо, условие сводится к @xmath114=0.\\label{never_verified}\\end{выровнено}\\ ] ] мы видим, что задействованные величины являются обновлениями состояния. поскольку они зависят от шума, вероятность соблюдения этого условия равна нулю, и на практике оно всегда нарушается. но смысл настоящей статьи состоит в том, чтобы показать, что проблема связана с (произвольным в нелинейном контексте) выбором представления ошибки оценки в виде линейной разности @xmath115, а не с проблемой несогласованности, присущей ekf - подобным методам, применяемым к slam. путем разработки ekf - slam на основе другой переменной ошибки оценки, которая в некотором смысле равносильна изменению координат, проблема ложной наблюдаемости может быть исправлена. качественная причина, по которой этого достаточно, связана с основной причиной ложной наблюдаемости: данный фиксированный сдвиг может быть или не быть наблюдаемым в зависимости от точки линеаризации @xmath116, как доказано предложением [ prop::first_order_rotations ]. оказывается, что последнее свойство по своей сути не связано с slam проблема: на самом деле это просто следствие определения ошибок. определяя эти ошибки иным образом может существенно изменить условие. это цель оставшейся части этой статьи. основываясь на теории инвариантного (i) ekf для матричных групп ли, как описано и изучено в @ xcite, мы представляем в этом разделе новый iekf для slam. в приложении [primer]-[gen : iekf ] общая теория iekf вспоминается и слегка расширяется, чтобы учесть очень общую форму выходных данных, и показано, что алгоритм, полученный здесь, является прямым применением теории. чтобы избавить читателя от изучения теории, основанной на группах Ли, мы попытаемся простыми словами объяснить методологию iekf на конкретном примере slam на протяжении всего настоящего раздела. рассмотрим уравнения модели с состоянием @xmath84, приведенные в. точно так же, как ekf, iekf распространяет оценочное состояние, полученное после наблюдения @xmath10, через детерминированную часть, т.е. @xmath117, @xmath118, @xmath119 для всех @xmath72. чтобы обновить предсказанное состояние @xmath120, используя наблюдение @xmath13, мы используем разложение системы ошибок Тейлора первого порядка. но, _ вместо того, чтобы рассматривать обычную ошибку состояния @xmath121 _, мы скорее используем (линеаризованную) ошибку оценки, определенную следующим образом @xmath122 и @xmath123 определены аналогично. для близкого @xmath124 это действительно представляет переменную ошибки в обычном смысле, как @xmath125 тогда и только тогда, когда @xmath126. как и в стандартной методологии ekf, давайте посмотрим, как эта _ альтернативная _ ошибка оценки распространяется через аппроксимацию системы ошибок первого порядка. используя уравнения распространения фильтра и, мы находим @xmath127, где условиями порядка @xmath128, @xmath129 и @xmath130 пренебрегли, поскольку в стандарте ekf обрабатывает неаддитивные шумы @xcite. для вывода мы использовали равенства @xmath131, @xmath132 : @xmath133 обратите внимание, что выходные данные одометра @xmath134 чудесным образом исчезли. фактически, это характеристика - и ключевая особенность - подхода iekf. давайте теперь вычислим аппроксимацию первого порядка ошибки наблюдения, используя альтернативную ошибку состояния. определите @xmath32 как матрицу, зависящую только от @xmath120, таким образом, чтобы для всех @xmath135, определенных с помощью, инновационный термин @xmath136 \\\\\\vdots \\\\\\тильда h \\left [ r(\\theta_n)^t \\left ( p^k - x_n \\right ) \\right ] \\end{pmatrix}-\\begin{pmatrix } \\тильда h \\left [ r(\\hat \\theta_{n|n-1 } ) ^t \\left(\\hat p^1_{n|n-1}-\\hat x_{n|n-1 } \\справа ) \\right ] \\\\\\vdots \\\\\\тильда h \\left [ r(\\hat \\theta_{n|n-1 } ) ^t \\left ( \\hat p^k_{n|n-1}-\\hat x_{n|n-1 } \\справа ) \\right ] \\end{pmatrix}\\]] равно @xmath137. используя это @xmath138 $ ] и @xmath139 из, мы видим, что @xmath32 определен, как показано ниже. таким образом, линеаризованная модель системы (первого порядка) относительно альтернативной ошибки записывает @xmath140 с @xmath141 и @xmath142, где @xmath143 - это якобиан @xmath63, вычисленный в @xmath144. как и в стандартной методологии ekf, матрицы @xmath145 позволяют вычислить коэффициент усиления Калмана @xmath23 и ковариацию @xmath146. позволяя @xmath147 быть стандартно определенным нововведением (см. алгоритм [ algo::iekf_slam ] сразу после обновления \" ), @xmath148 является оценкой линеаризованной ошибки @xmath149, учитывающей наблюдение @xmath13, а @xmath27, как предполагается, кодирует дисперсию @xmath150. заключительным шагом стандартной методологии ekf является обновление оценочного состояния @xmath120 благодаря оценочной линеаризованной ошибке @xmath148. однако есть небольшая загвоздка: поскольку @xmath151 больше не определяется как простое различие @xmath121, простое добавление @xmath123 к @xmath152 было бы неуместным. наиболее естественным аналогом в нашей настройке было бы выбрать для @xmath152 значения @xmath153, сделав правильный элемент равным только что вычисленному @xmath123. однако теория iekf, упомянутая в приложении [gen : iekf ], предполагает обновление, которое приравнивает последнее к первому порядку, но чья нелинейная структура обеспечивает лучшие свойства @xcite. таким образом, состояние обновляется следующим образом @xmath154, при этом @xmath155 определяется @xmath156, где @xmath157. алгоритм [ algo::iekf_slam ] резюмирует различные этапы iekf slam. определите @xmath31 и @xmath32 как в. определите @xmath33, @xmath35 как в и. * распространение * для всех @xmath72 @xmath38 * обновление * @xmath73 \\\\\\vdots \\\\\\тильда h \\left [ r(\\hat \\theta_{n|n-1})^t \\left ( \\hat p^k_{n|n-1}- \\hat x_{n|n-1 } \\right ) \\right ] \\end{pmatrix}$ ] @xmath40, @xmath41 @xmath42p_{n|n-1 } $ ] в этом разделе мы показываем, что бесконечно малые вращения и перемещения глобального фрейма являются ненаблюдаемыми сдвигами в смысле определения [ def::non_obs_first_order ] независимо от точек линеаризации, используемых для вычисления матриц @xmath158 и @xmath32 уравнения, функция, резко контрастирующая с обычным ограничивающим условием для точек линеаризации. другими словами, мы показываем, что бесконечно малые повороты и перемещения глобального фрейма всегда являются ненаблюдаемыми сдвигами модели системы _ linearized _ относительно ошибки независимо от точки линеаризации, что резко контрастирует с предыдущими результатами (см. раздел [ sect::eks_slam8inconsistency ] и ссылки в нем). мы можем рассмотреть только одну функцию ( @xmath159 ) без потери общности. выражение линеаризованной системной модели стало намного проще, поскольку линеаризованная ошибка обладает замечательным свойством оставаться постоянной на этапе распространения в отсутствие шума, начиная с @xmath160 в -. сначала давайте определим влияние вариаций первого порядка, вытекающих из поворотов и перемещений глобального фрейма об ошибке, как определено, то есть об ошибке следующего вида @xmath161 [ prop::first_order_rotations_non_linear ] пусть @xmath162 будет оценкой состояния. возмущение первого порядка _линеаризованной _ ошибки оценки, определяемой примерно как 0, соответствующее _ бесконечно малому _ повороту на угол @xmath98 глобального кадра, считывается @xmath163 таким же образом, _ бесконечно малое _ перемещение глобального кадра с вектором @xmath101 подразумевает возмущение первого порядка из системы ошибок вида @xmath164 согласно предложению [ prop::first_order_rotations_prelim ] бесконечно малое вращение на угол @xmath165 истинного состояния соответствует преобразованию @xmath166. @xmath167 и @xmath168. что касается @xmath151 уравнения, то это соответствует вариации @xmath169 это направление пространства состояний рассматривается \"линеаризованной системой ошибок\" как вектор @xmath170. аналогично, преобразование вектора @xmath171 глобального фрейма приводит к преобразованию @xmath172. влияние на линеаризованную ошибку @xmath151, очевидно, является возмущением @xmath173, пренебрегающим условиями порядка @xmath174. теперь мы можем доказать первый важный результат настоящей статьи: бесконечно малые преобразования, возникающие в результате поворотов и перемещений рамки гобала, являются ненаблюдаемыми сдвигами для линеаризованной модели iekf. [ slam : thm : obs ] рассмотрим задачу slam, определяемую уравнениями и, и алгоритм iekf - slam [ algo::iekf_slam ]. пусть @xmath87 обозначает линейную комбинацию бесконечно малых вращений и перемещений @xmath175 всей системы, определенной следующим образом @xmath176 тогда @xmath87 - это ненаблюдаемый сдвиг линеаризованной модели системы - iekf slam в смысле определения [ def::non_obs_first_order ], и это независимо от последовательности истинных состояний и оценки @xmath177: сама структура iekf согласуется с рассматриваемой ненаблюдаемостью. обратите внимание, что определение [ def::non_obs_first_order ] включает распространяющееся возмущение @xmath85, но поскольку здесь @xmath158 - это @xmath178 : у нас есть @xmath179. таким образом, единственное, что нужно проверить, это: @xmath180, т.е. @xmath181. это простая замена @xmath87 на альтернативные @xmath182 и @xmath183. мы получили свойство согласованности, к которому стремились: линеаризованная модель корректно отражает ненаблюдаемость глобальных поворотов и перемещений. в качестве побочного продукта ненаблюдаемое, видимое фильтром, автоматически имеет соответствующий размер. стандартный ekf настроен таким образом, чтобы уменьшить ошибку оценки состояния @xmath184, определенную через исходные переменные состояния @xmath124 задачи. хотя последняя ошибка состояния идеально подходит для линейного случая, на самом деле у нее нет абсолютно никаких фундаментальных причин управлять процессом линеаризации в нелинейных условиях. основное различие при анализе ekf и iekf заключается в том, что * в стандартном ekf существует тривиальное соответствие между небольшим изменением истинного состояния и небольшим изменением ошибки оценки. но глобальные повороты кадра заставляют ошибку изменяться нетривиальным образом, как указано в разделе [ sec:2 ]. * в подходе iekf влияние небольшого поворота состояния на изменение ошибки оценки становится тривиальным, что обеспечивается предложением [ prop::first_order_rotations_non_linear ]. но ошибка нетривиально связана с состоянием, поскольку ее определение явно зависит от точки линеаризации @xmath116. многие проблемы с согласованностью ekf связаны с тем фактом, что обновленная ковариационная матрица @xmath27 вычисляется перед обновлением, а именно в прогнозируемом состоянии @xmath120, и, таким образом, не выполняется не учитывает значение обновленного состояния @xmath152, хотя предполагается, что оно отражает ковариацию обновленной ошибки. вот почему oc - ekf обычно стремится избежать линеаризации по последней, хотя и наилучшей оценке состояния, чтобы найти близкое состояние таким образом, чтобы ковариационная матрица, полученная в результате линеаризации, сохраняла размерность подпространства наблюдаемости. подход iekf совершенно иной: обновленная ковариация @xmath27 вычисляется по последней оценке @xmath120, которая сродни стандартной методологии ekf. но затем он косвенно адаптируется к обновленному состоянию, поскольку он _ интерпретируется _ как ковариация ошибки @xmath123. и, в отличие от стандартного случая, определение этой ошибки зависит от @xmath152. более интуитивно мы можем сказать, что эллипсоиды доверия, закодированные в @xmath27, привязаны к основа, которая определяетследовательно, при перемещении с @xmath120 на @xmath152 происходит преобразование, причем это преобразование привязано к ненаблюдаемым направлениям. это предотвращает ложное уменьшение ковариации по ненаблюдаемым сдвигам, которые не идентичны в @xmath120 и @xmath152. наконец, обратите внимание, что альтернативная ошибка почти искусственна: она естественным образом вытекает из структуры группы ли проблемы. это логично, поскольку рассматриваемая ненаблюдаемость на самом деле относится к инвариантности модели, то есть к проблеме slam, к глобальным перемещениям и ротациям. таким образом, неудивительно, что инвариантный подход, который приводит к ошибкам инвариантного состояния, которые кодируют саму симметрию проблемы, оказывается плодотворным (подробнее смотрите в приложении). наш подход может быть связан с предыдущей работой @xcite. действительно, согласно последней статье, неспособность зафиксировать правильное измерение подпространства наблюдаемости в линеаризованной модели приводит к `получению ложной информации по направлениям пространства состояний, где информация фактически недоступна\" и приводит к `неоправданному уменьшению оценок ковариации, основной причине несогласованности фильтра\". теорема [ slam : thm : obs ] доказывает, что бесконечно малые вращения и перемещения глобального фрейма, которые ненаблюдаемы в задаче slam, всегда `рассматриваются\" линеаризованной моделью iekf действительно как ненаблюдаемые направления, поэтому этот фильтр не страдает от проблем `ложной наблюдаемости\". это наш главный теоретический результат. тем не менее, результаты последнего раздела касаются системы с отключенным шумом и относятся к подходу автоматического управления к понятию наблюдаемости, как в @xcite. настоящий раздел скорее посвящен теоретико-оценочным следствиям теоремы [ slam : thm : obs]. мы действительно доказываем, что выходная ковариационная матрица iekf правильно отражает отсутствие `прироста информации\" по ненаблюдаемым направлениям, как упоминалось выше, но там, где информация теперь должна быть понята в смысл информации фишера. в качестве побочного продукта это позволяет соотнести наши результаты с несколько иным подходом к согласованности slam, который скорее фокусируется на информационной матрице Фишера, чем на матрице наблюдаемости, см., в частности, @xcite. изложение настоящего раздела основано на оригинальной статье @xcite. смотрите также @xcite о связанных идеях, примененных к slam. рассмотрим систему с выводом. определите набор векторов состояния и наблюдений на момент времени @xmath62 : @xmath185 совместное распределение вероятностей вектора @xmath186 @xmath187 и вектора @xmath188 @xmath189 равно @xmath190 байесовская информационная матрица Фишера (bifm) определяется как следующая матрица @xmath191, основанная на диаде градиента значений . логарифмическая вероятность : @xmath192[\\nabla_{\\tilde x_n } \\log p(\\tilde y_n,\\tilde x_n]^t)\\]]и обратите внимание, что для задачи slam это сводится к матрице @xcite. эта матрица представляет для нас интерес, поскольку она дает нижнюю границу точности, достижимой любым оценщиком, используемым для решения задачи фильтрации -. действительно, пусть @xmath193 определяется как _ обратный _ к @xmath194 правый нижний блок @xmath195^{-1}$ ]. эта матрица обеспечивает нижняя граница среднеквадратичной ошибки оценки @xmath84 по прошлым и настоящим измерениям @xmath189 и предшествующим @xmath196. действительно, для любой несмещенной оценки @xmath197 : @xmath198[t(\\tilde y_n)]^t)\\succeq j_n^{-1}\\ ] ] где @xmath199 означает, что @xmath200 является положительным полуопределенным. @xmath201 называется байесовской или апостериорной нижней границей Крамра - Рао для задачи фильтрации @xcite. самое интересное, что в случае, когда @xmath4 и @xmath7 линейны, априорное распределение является гауссовым, а шумы аддитивны и гауссовы, мы имеем @xmath202, где @xmath27 - ковариационная матрица, выводимая фильтром Калмана. таким образом, в линейном гауссовском случае @xmath203 отражает статистическую информацию, доступную в момент времени @xmath62 о состоянии @xmath84. в качестве расширения в литературе по slam @xmath203 часто упоминается просто как информационная матрица, также в нелинейных контекстах, например, при использовании расширенных информационных фильтров @xcite.      в последнем разделе мы напомнили, что в случае линейного Гаусса обратной величиной ковариационной матрицы, выводимой фильтром Калмана, является информация Фишера, доступная фильтру (это также указано в @xcite, стр. 304). в свете этих результатов естественно ожидать от любой вариант ekf, обратный выходной ковариационной матрице @xmath203, действительно отражает отсутствие прироста информации в ненаблюдаемых направлениях. если фильтру не удастся этого сделать, выходная ковариационная матрица будет слишком оптимистичной, то есть непоследовательной, и неправильные ковариации приведут к неправильному выигрышу @xcite. следующая теорема показывает, что линеаризованная системная модель iekf позволяет обеспечить желаемое свойство ковариационной матрицы. это наш второй важный результат. [ slam : big : thm ] рассмотрим задачу slam, определяемую уравнениями, и алгоритм iekf - slam [ algo::iekf_slam ]. пусть @xmath87 обозначает линейную комбинацию бесконечно малых вращений и перемещений @xmath175 всей системы, как определено в теореме [ slam : thm : obs ]. @xmath87, таким образом, является ненаблюдаемым сдвигом. если матрица @xmath27, выводимая iekf, остается обратимой, мы всегда имеем: @xmath204 как @xmath205 в, ненаблюдаемые сдвиги остаются фиксированными, т.е. @xmath206. на этапе распространения мы имеем: @xmath207, поскольку @xmath208 является положительным полуопределенным. и на этапе обновления (смотрите форму информационного фильтра Калмана в @xcite) мы имеем: @xmath209 \\delta x_0 = \\delta x_0^t p_{n|n-1}^{-1 } \\delta x_0\\ ] ] как @xmath210, как показано в доказательстве теоремы [ slam : thm : obs ]. таким образом, @xmath211 не увеличивается с течением времени @xmath62. обратите внимание, что доказательство доказывает, что если @xmath27 не обратимо, результаты теоремы все еще остаются в силе, записывая iekf в информационной форме. наш результат, по сути, означает, что линеаризованная модель iekf имеет структуру, которая гарантирует, что ковариационная матрица всегда отражает отсутствие \"ложного\" (байесовского фишера) прироста информации по направлениям, которые соответствуют ненаблюдаемым поворотам и перемещениям глобального фрейма. в этом разделе мы, с одной стороны, проверяем при моделировании заявленные свойства, а с другой - иллюстрируем поразительное улучшение консистенции, достигнутое с помощью iekf slam. с этой целью мы предлагаем рассмотреть аналогичный численный эксперимент, как в солидной работе @ xcite, посвященной несогласованности ekf и преимуществам oc - ekf. iekf сравнивается здесь со стандартным ekf, ukf, oc - ekf и идеальным ekf, который является неосуществимым вариантом ekf, где состояние линеаризовано относительно _ истинной_ траектории.       . мы видим, что показатель остается около 1 для iekf slam и oc - ekf slam в течение всего временного интервала, как и ожидалось при последовательном методе оценки. идеальный ekf, при котором система линеаризована по истинному значению состояния, дает аналогичные результаты. напротив, мы видим, что ekf непоследователен, и ukf также. ] огибающая неопределенности, вычисляемая фильтром. фильтры с теоретическими свойствами относительно ненаблюдаемых направлений (iekf, oc - ekf и идеальный ekf) устраняют эту проблему. ] . нижний график представляет собой масштабирование первых временных шагов. информация о бесконечно малом возмущении, соответствующем вращению всей системы, уменьшается для iekf slam, что является последовательным поведением, поскольку это возмущение ненаблюдаемо. идеальные ekf и ocekf дают схожие результаты, но ekf и ukf - нет. график также подтверждает, что ekf и ukf slam имеют тенденцию получать ложную информацию в этом ненаблюдаемом направлении.,title=\"fig : \" ]. нижний график представляет собой увеличение первых временных шагов. информация о бесконечно малом возмущении, соответствующем вращению всей системы, уменьшается для iekf slam, что является последовательным поведением, поскольку это возмущение ненаблюдаемо. идеальные ekf и ocekf дают схожие результаты, но ekf и ukf - нет. график также подтверждает, что ekf и ukf slam имеют тенденцию получать ложную информацию в этом ненаблюдаемом направлении.,title=\"рис. : \" ] выбранная нами настройка моделирования (намеренно) аналогична той, которая используется в @xcite (раздел 6.2). транспортное средство (или робот) проезжает петлю диаметром 15 м десять раз в двумерной плоскости, обнаружив на своем пути 20 неизвестных объектов, как показано на рисунке [ рис.::карта ]. скорость и угловая скорость постоянны (1 м/с и 9 град/с соответственно). относительное положение объектов в системе отсчета транспортного средства наблюдается раз в секунду ( где @xmath63 of - идентификатор ). стандартное отклонение @xmath212 измерения скорости на каждом колесе транспортного средства равно @xmath213 скорости. это дает стандартное отклонение @xmath214 результирующей линейной скорости и @xmath215 скорости вращения : @xmath216 и @xmath217, где @xmath218 - расстояние между ведущими колесами (см. @xcite ). объекты видны, если они находятся в пределах диапазона измерения 5 м, в этом случае они наблюдаются с изотропным шумом со стандартным отклонением 10 см. начальная неопределенность относительно местоположения и курса равна нулю, что доказывает недостаточность условия для предотвращения сбоя ekf. каждый раз, когда ориентир виден в первый раз, его положение инициализируется в кадре земли с использованием текущей предполагаемой позы робота, связанная с этим неопределенность устанавливается на очень высокое значение по сравнению с размером карты, затем выполняется обновление по Калману для корреляции положения нового объекта с другими переменными. каждую секунду все видимые ориентиры (т.е. те, которые находятся в радиусе 5 м) обрабатываются одновременно в сложенном векторе наблюдения. сравниваются пять алгоритмов: 1. классический ekf, описанный в алгоритме [ algo::ekf_slam_linear ]. 2. предлагаемый алгоритм iekf slam, описанный в алгоритме [ algo::iekf_slam ]. идеальный ekf, определенный в @xcite, т.е. классическая ekf, в которой уравнение Риккати вычисляется по истинной траектории системы вместо расчетной траектории. хотя последний и не используется на практике, он является хорошим ориентиром для сравнения, поскольку предполагается, что это ekf с последовательным поведением. oc - ekf, описанный в @xcite, который пока является единственным методом, гарантирующим, что ненаблюдаемое подпространство имеет соответствующую размерность. 5. фильтр Калмана без запаха (ukf), который, как известно, лучше справляется с нелинейностями, чем ekf.    прежде чем идти дальше, в следующем подразделе представлен индикатор nees, используемый в моделировании для измерения согласованности этих методов. классические критерии, используемые для оценки эффективности метода оценки, такие как среднеквадратичная ошибка (rms), не сообщают о согласованности, поскольку они не учитывают неопределенность, возвращаемую фильтром. этот момент решается с помощью нормализованного значения квадрата ошибки оценки (nees), которое вычисляет среднее квадратичное значение ошибки, нормализованное по ковариационной матрице ekf. для выборки @xmath219 значений ошибок, имеющих размерность @xmath220, каждое из которых с ковариационной матрицей @xmath221 размера @xmath222, nees определяется следующим образом: @xmath223 если каждое @xmath224 является гауссовым значением с нулевым средним с ковариационной матрицей @xmath221, то для большого @xmath225 у нас есть nees @xmath226. случай nees @xmath227 выявляет проблему несоответствия: фактическая неопределенность выше, чем вычисленная неопределенность. эта ситуация обычно возникает, когда фильтр настроен оптимистично, поскольку он полагает, что получил информацию в ненаблюдаемом направлении. индикатор nees будет использоваться, наряду с обычным rms, для иллюстрации нашего решения проблемы несоответствия slam в дальнейшем. на рисунке [ fig::nees ] отображается индикатор nees оценки положения транспортного средства (курс и позиция) с течением времени, рассчитанный для 50 прогонов эксперимента по методу Монте-Карло, описанного в разделе [ sect::exp_setting ]. как и ожидалось, профиль nees для классического ekf, идеального ekf и oc - ekf такой же, как и в предыдущей статье @xcite, которая вдохновила этот экспериментальный раздел. обратите внимание, что мы использовали здесь нормализованную версию nees, сделав ее значение размаха равным 1. мы также видим, что результат аналогичен для oc - ekf slam и идеального ekf slam: nees варьируется от 1 до 1,7, в отличие от ekf slam и ukf slam, которые демонстрируют большие несоответствия по времени. поза робота здесь мы видим, что iekf устраняет несогласованность, при этом значение nees остается близким к 1. Обратите внимание, что здесь он работает даже лучше, чем oc - ekf и ideal ekf (результаты которых очень близки друг к другу), с точки зрения согласованности. основное различие между iekf и этими фильтрами заключается в использовании или нет текущей оценки в качестве точки линеаризации. поскольку направления неопределенности сильно зависят от оценки, рисунок [ fig::nees ] предполагает, что они могут быть неправильно зафиксированы при вычислении в другой точке. другим аспектом оценки метода, подобного ekf, является производительность: независимо от релевантности ковариационной матрицы, возвращаемой фильтром (т.е. согласованности), чистая производительность может быть оценена с помощью среднеквадратичных значений ошибки заголовка и положения, значения которых с течением времени показаны на рисунке [ fig::heading_rms ]. они подтверждают ожидаемый результат: решение проблем согласованности повышает точность оценки в качестве побочного продукта, поскольку неправильные ковариации приводят к неправильному выигрышу @xcite.    выбрав \"одиночный запуск\", мы также можем проиллюстрировать проблему несоответствия с точки зрения ковариации и информации. на рисунке [ fig::ekf_enveloppe ] отображается ошибка заголовка для ekf, ukf, iekf, oc - ekf и ideal ekf slam, а также огибающая @xmath228, возвращаемая каждым фильтром. это иллюстрирует как проблему ложной наблюдаемости, так и возникающее в результате несоответствие ekf и ukf: неопределенность курса уменьшается с течением времени, в то время как ошибка оценки выходит за пределы диапазона @xmath228. напротив, поведение iekf, oc - ekf и ideal ekf является разумным. на рисунке [ fig::ekf_enveloppe2 ] показана карта и эллипсоиды неопределенности ориентиров @xmath228 : аналогично, как ekf, так и ukf не удается зафиксировать истинные положения ориентиров в эллипсоидах @xmath228, тогда как трем дополнительным фильтрам это удается. наконец, на рисунке [ fig::info_rot ] показана эволюция информации за сдвиг, соответствующий бесконечно малым вращениям, как определено в теореме [ slam : big : thm ], то есть эволюция величины @xmath229 во времени. теорема успешно проиллюстрирована: последняя величина всегда уменьшается для iekf, идеального ekf, oc - ekf, но не для ekf и (немного лучшего в этом отношении) ukf. эта работа доказывает, что алгоритм ekf для slam по своей сути не является противоречивым - по крайней мере, в отношении несогласованности, связанной с ненаблюдаемыми преобразованиями глобального фрейма, - но выбор правильных координат для процесса линеаризации имеет решающее значение. мы показали, что применение недавней теории iekf - варианта ekf (незначительного) - приводит к доказуемым свойствам, касающимся наблюдаемости и непротиворечивости. обширное моделирование методом Монте-Карло продемонстрировало согласованность нового метода и поразительное улучшение по сравнению с ekf, ukf, oc - ekf, а также, что более примечательно, с идеальным ekf, который является неосуществимым вариантом ekf, где система линеаризована относительно истинной траектории. обратите внимание, что подход iekf может оказаться актуальным не только для slam, но и для некоторых других задач в робототехнике, таких как автономная навигация (см. @xcite), и в сочетании с контроллерами, особенно для целей планирования движения, см. @xcite. в @xcite iekf доказал, что обладает свойствами глобальной асимптотической сходимости в простой задаче локализации колесного робота, что является сильным свойством. iekf также был запатентован для навигации с инерциальными датчиками @xcite. в настоящее время алгоритмы slam, основанные на нелинейной оптимизации, становятся популярными по сравнению с ekf slam, смотрите, например, @xcite для одной из первых статей на эту тему. мы все же ожидаем, что простой ekf slam со свойствами согласованности окажется полезным для исследовательского сообщества, поскольку от ekf slam отказались отчасти из-за его непоследовательности. общий ekf доказал свою полезность во многих промышленных приложениях, особенно в области наведения и навигации. его преимущества заключаются в том, что он, во-первых, рекурсивен, что позволяет избежать сохранения всей траектории, и, во-вторых, подходит для онлайновых приложений в режиме реального времени. более того, аэрокосмическая и оборонная промышленность накопила большой опыт для его промышленного внедрения и валидации. а iekf - это вариант, который, будучи во всех отношениях похожим на ekf, сохраняет все свои преимущества, но обладает дополнительными гарантированными свойствами. обратите также внимание, что все улучшения ekf для slam, такие как, например, slam @xcite и разреженные расширенные информационные фильтры @xcite, могут быть виртуально преобразованы в их инвариантный аналог. высокоразмерная оптимизационная формулировка задачи slam, склонная к локальным минимумам, имеющая точное начальное значение (т.е. небольшую начальную ошибку оценки), очень важна @xcite. таким образом, алгоритм slam iekf, предложенный в настоящей статье, может быть выгодно использован для инициализации этих методов в сложных ситуациях. кроме того, мы ожидаем, что наш подход, основанный на симметриях, может помочь улучшить методы оптимизации slam (по крайней мере, первого порядка). чтобы понять почему, для простоты предположим, что датчики не содержат помех. тогда перемещение траектории-кандидата по ненаблюдаемым направлениям не изменит функцию затрат, и эффективный алгоритм оптимизации должен учитывать это. и когда используется алгоритм градиентного спуска, рассматривается только разложение функции затрат первого порядка. наш подход группы ли позволит определить направления наиболее крутого спуска альтернативным геометрическим способом, который будет `придерживаться\" ненаблюдаемых направлений, и соответствующее обновление будет перемещаться по пространству состояний (группы ли) нелинейным, но релевантным образом. этот вопрос оставлен для будущей работы, но глубокое понимание интереса инвариантного подхода к ekf является первым шагом в этом направлении.      авторы хотели бы поблагодарить Сирила Джоли за его совет. в этом разделе мы приводим более подробную информацию о теории iekf о матричных группах ли и показываем, как базовая структура группы ли задачи slam действительно использовалась для построения алгоритма iekf slam [ algo::iekf_slam ]. мы также предоставляем уравнения iekf для 3d slam. для получения дополнительной информации о iekf смотрите @xcite и ссылки в нем. матричная группа ли @xmath230 является подмножеством квадратных обратимых @xmath231 матриц @xmath232, проверяющих следующие свойства : @xmath233, где @xmath234 - единичная матрица @xmath235. если @xmath236 - это кривая над @xmath230 с @xmath237, то ее производная в @xmath238 обязательно лежит в подмножестве @xmath239 из @xmath240. @xmath239 - это векторное пространство, и оно называется алгеброй ли @ xmath230. оно имеет ту же размерность @xmath241, что и @xmath230. благодаря линейному обратимому отображению, обозначаемому @xmath242, можно выгодно идентифицировать @xmath239 с @xmath243. кроме того, векторное пространство @xmath239 может быть сопоставлено матричной группе ли @xmath230 через классическую матричную экспоненту @xmath244. таким образом, @xmath245 может быть сопоставлен с @xmath230 через экспоненциальную карту ли, определенную @xmath246 для @xmath247. эта карта обратима для small @xmath151, и у нас есть @xmath248. хорошо известная формула Бейкера - Кэмпбелла - Хаусдорфа (bch) дает расширение серии для продукта @xmath249. в частности, это гарантирует @xmath250, где @xmath251 имеет порядок @xmath252. для любого @xmath253 сопряженная матрица @xmath254 определяется @xmath255 для всех @xmath256. теперь мы приводим явные формулы для двух групп, представляющих особый интерес для задачи slam. эта знаменитая группа в робототехнике может быть определена с использованием однородных матриц, т.е. @xmath258. @xmath259, затем @xmath260, где @xmath261 и @xmath262. у нас есть @xmath263. экспонента лжи записывает @xmath264 там, где @xmath157. у нас есть @xmath265. теперь мы представляем простое расширение @xmath257, вдохновленное предварительными замечаниями в @xcite. для @xmath267 и @xmath268 рассмотрим отображение @xmath269, определенное @xmath270 \\vdots & \\\\[-0.5ex ] 0_{1,2 } & \\end{array } \\right)\\ ] ] и пусть @xmath271 определяется @xmath272 и обозначим его @xmath273. Обратите внимание, что мы восстановите @xmath257 для @xmath159, т.е. @xmath274. включение @xmath261 и @xmath275 приводит к @xmath276 \\vdots & \\\\[-0.5ex ] 0_{1,2 } & \\end{array } \\right)$ ] и @xmath277. оказывается, расширяя результаты @xmath257, что существует замкнутая форма для экспоненты ли @xmath278, которая записывает @xmath279 с помощью @xmath157. @xmath280 также легко выводится расширением @xmath257, но для экономии места мы отображаем его только один раз: @xmath281 определяется как матрица @xmath282 уравнения. этот раздел представляет собой краткое изложение методологии iekf @xcite. пусть @xmath230 - матричная группа ли. рассмотрим общую динамическую систему @xmath283 в группе, связанную с последовательностью наблюдений @xmath1, со следующими уравнениями: @xmath284 @xmath285, где @xmath286 - входная матрица, которая кодирует смещение в соответствии с эволюционной моделью, @xmath287 - вектор, кодирующий шум модели, @xmath288 - входная матрица, которая кодирует смещение в соответствии с эволюционной моделью. функция наблюдения и @xmath289 шум измерения. iekf распространяет оценку, полученную после предыдущего наблюдения @xmath10, через детерминированную часть : @xmath290 чтобы обновить @xmath291, используя новое наблюдение @xmath13, необходимо учитывать ошибку оценки, которая является _ четко определенной _ в группе. в этой статье мы будем использовать следующие правоинвариантные ошибки @xmath292, которые равны @xmath234 при @xmath293. терминология проистекает из того факта, что они инвариантны к правым умножениям, то есть преобразованиям вида @xmath294 с @xmath253. Обратите внимание, что в качестве альтернативы можно было бы рассмотреть левоинвариантные ошибки, но это оказывается менее плодотворным для slam.      обновление iekf основано на расширении нелинейной системы первого порядка, связанной с ошибками вокруг @xmath234. сначала вычислите полную эволюцию ошибки @xmath295 Обратите внимание, что термин @xmath296 исчез! это ключевое свойство для успеха подхода инвариантной фильтрации @xcite. чтобы линеаризовать это уравнение, мы определяем @xmath297 вокруг @xmath234 через @xmath298 как в стандартной методологии ekf без аддитивного шума @xcite все члены порядка @xmath299 считаются малыми и ими пренебрегают. используя формулу bch и пренебрегая последними членами, мы получаем @xmath300 используя локальную обратимость @xmath301 вокруг @xmath302, мы получаем следующую линеаризованную эволюцию ошибок в @xmath243: @xmath303, где @xmath304 и @xmath305.    чтобы линеаризовать ошибку вывода, мы теперь немного адаптируем теорию iekf @ xcite для учета общей формы вывода. обратите внимание, что @xmath306. поскольку @xmath149 предполагается малым, а @xmath307, разложение Тейлора первого порядка в @ xmath247 произвольное, позволяет определить @ xmath32 следующим образом @xmath308 как в стандартной теории, матрица усиления Калмана @xmath23 позволяет вычислить оценку линеаризованной ошибки после наблюдения от @xmath13 до @xmath309, где @xmath310. напомним, что ошибки оценки состояния, определенные с помощью -, имеют вид @xmath311, то есть @xmath312. таким образом, оценка @xmath313 после наблюдения @xmath13, которая согласуется с -, получается с помощью следующего аналога группы ли линейного обновления @xmath314 уравнения фильтра подробно описаны в алгоритме [ algo::iekf ]. выберите начальный @xmath315 и @xmath316 [ algo::iekf ] определите @xmath32 как в и пусть @xmath317 и @xmath318. определите @xmath33 как @xmath34 и @xmath35 как @xmath36. * распространение * @xmath319 @xmath320 * обновление * @xmath321 @xmath322, @xmath41 @xmath42p_{n|n-1 } $ ] группа ли, лежащая в основе проблемы slam, - это @xmath273, представленная в приложении [раздел::tuto_se23 ]. давайте применим общую теорию iekf к эта группа. чтобы определить аналог группы ли @xmath313 состояния @xmath84, определенного с помощью, мы разрешаем @xmath323. уравнения модели записывают @xmath324 с помощью @xmath325. на этапе распространения iekf распространяет оценку через соответствующие детерминированные уравнения @xmath326 с @xmath327. простое матричное умножение показывает, что @xmath328, где @xmath329 \\\\ p ^ 1_n-[r \\left ( \\theta_n -{\\hat \\theta}_{n|n-1}\\справа ) \\шляпа p^1_{n|n-1 } ] \\\\\\vdots \\\\ p^k_n- [ r \\слева ( \\theta_n -{\\шляпа \\тета}_{n|n-1}\\справа ) \\шляпа p^k_{n|n-1 } ] \\end{pmatrix}\\]] и где @xmath330 определяется аналогично. линеаризованная ошибка определяется, то есть, @xmath331. поскольку членами порядка @xmath332 в линеаризованных уравнениях следует пренебречь, достаточно вычислить приближение первого порядка @xmath333. сначала обратите внимание, что @xmath149, определенный с помощью, является линейным приближением к @xmath334, то есть @xmath335. это легко подразумевает, что @xmath336отзыв @xmath337, который мы видим, является первым приближением @xmath333, как определено в indeed. способ распространения линеаризованной ошибки уже вычислен и состоит из, который совпадает с первым уравнением. это точно соответствует тому, что можно ожидать от общей теории, то есть от уравнения, напоминая, что @ xmath282 действительно является отображением @xmath338 группы @xmath273.              распространяя group @ xmath266 на трехмерный случай и применяя общую теорию iekf раздела [gen : iekf ], мы выводим в настоящем разделе iekf для 3d slam. из-за ограниченности пространства и поскольку это не является основной целью настоящей статьи, мы стремимся к предельной краткости изложения. смотрите также @xcite. обратите внимание, что, хотя уравнения 3d slam используют матрицы вращения, на самом деле они полностью встроены: при использовании кватернионов (рекомендуется) или углов Эйлера (не рекомендуется) они записываются так же, как группа @xmath342, которую мы вводим, на самом деле не зависит от конкретного представления вращений. уравнения робота в 3d и в непрерывном времени записываются следующим образом: @xmath343, где @xmath344 - матрица вращения, представляющая ориентацию робота во времени @xmath345, @xmath346 обозначает угловую скорость робота, измеренную гирометром или одометрией (в сочетании с моделью одноколесного велосипеда для наземного транспортного средства ), @xmath347 - скорость в кадре робота, а @xmath348 - положение ориентира @xmath47, и где @xmath349 для @xmath350 обозначает кососимметричную матрицу @xmath351, такую, что для любого @xmath352 мы имеем @xmath353. наконец, @xmath354 и @xmath355 обозначают (соответственно) шум на угловой и линейной скоростях. хотя теория iekf вполне могла бы быть применена непосредственно к этой динамике непрерывного времени, как в @ xcite, мы применяем ее здесь к дискретизированной модели, чтобы соответствовать остальной части статьи. хотя точная дискретизация зашумленной модели в группе недоступна @xcite, позволяя @xmath356 быть временным шагом, широко используется следующая схема интегрирования первого порядка: @xmath357\\omega_n, \\quad x_n = x_{n-1}+r_{n-1 } ( v_n+ w_n^v ), \\\\ p_n^j & = p_{n-1}^j,\\quad 1\\leq j\\leq k \\end{выровнено}\\ ] ] где приращения @xmath358 получены путем решения начальных условий без помех на @xmath62-м временном шаге с начальным условием @xmath359, и где следующий дискретный шум @xmath360 получается путем интегрирования соответствующих белых шумов. обратите внимание, что эта схема точна для терминов первого порядка в @xmath356. общее ориентировочное наблюдение в кадре автомобиля гласит: @xmath361+v_n ^ 1 \\\\ \\vdots \\\\\\тильда h \\left [ r_n^t \\left ( p^k - x_n \\right ) \\right]+v_n^k \\end{pmatrix}\\ ] ] где @xmath362 (или @xmath363 для монокулярного визуального шлема) - это наблюдение объектов на временном шаге @xmath62, а @xmath8 - шум наблюдения. мы позволяем выходной ковариационной матрице шума быть @xmath364 (не путать с вращением @xmath35). группа ли, лежащая в основе проблемы, - это группа @xmath365, которую мы вводим следующим образом. для @xmath366 и @xmath367 пусть @xmath368 \\vdots & \\\\[-0.5ex ] 0_{1,3 } & \\end{array } \\right)\\ ] ] и пусть @xmath369 определяется как @xmath370 и обозначается через @xmath365. тогда у нас есть @xmath371 \\vdots & \\\\[-0.5ex ] 0_{1,3 } & \\end{array } \\right)$ ] и @xmath372. для @xmath373, расширяя результаты @xmath374, мы имеем закрытую форму : @xmath375, где @xmath376. как легко увидеть по аналогии с @xmath374@xmath377 \\vdots & \\\\[-0.5ex ] ( p^k)_\\times r & \\end{array } \\right)\\end{выровнено}\\ ] ] пусть состояние будет @xmath378, а @xmath379 пусть будет @xmath380, и пусть @xmath116 и @xmath381 будут их предполагаемыми аналогами. легко видеть, что вплоть до терминов, которые в любом случае исчезнут в процессе линеаризации, модель для состояния сопоставляется через @xmath382, определенный в, с моделью формы.          используя матричный логарифм, определим @xmath384 как решение @xmath385 = r \\ hat r ^ {t} $ ]. пренебрегая условиями порядка @xmath386, мы получаем @xmath387. идентификация первого порядка, как в приложении [ lnz : sec ], таким образом, дает @xmath388 в качестве вектора, который удовлетворяет определению @xmath389 с точностью до порядка @xmath390). как и в стандартной теории ekf, iekf распространяет оценку, полученную после предыдущего наблюдения @xmath10, через детерминированную часть или эквивалентно в матричной форме. таким образом, уравнение распространения задается через where @xmath391 и @xmath392 как прямое применение теории. пусть @xmath391, @xmath32, как в, @xmath396, используя define @xmath33 by. @xmath397 - это уровень шума наблюдения. распространение * для всех @xmath72 @xmath38 * обновление * @xmath398 \\\\\\vdots \\\\\\тильда h \\left [r_{n|n-1}^t \\left ( \\hat p^k_{n|n-1}- \\hat x_{n|n-1 } \\right ) \\right ] \\end{pmatrix}$ ] @xmath399, @xmath41 @xmath42p_{n|n-1 } $ ]       

в этой статье мы рассматриваем несогласованность алгоритма slam на основе ekf, которая проистекает из ненаблюдаемости начала координат и ориентации глобальной системы отсчета. мы доказываем на нелинейных двумерныхионная проблема с точечными ориентирами показала, что этот тип несоответствия устраняется с помощью инвариантного ekf, недавно представленного варианта ekf, предназначенного для учета симметрий пространства состояний. обширные прогоны по методу Монте-карло иллюстрируют теоретические результаты.