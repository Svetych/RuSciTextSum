квантовые биты, или кубиты @xcite, были реализованы с использованием, например, сверхпроводящих цепей @xcite, квантовых точек @xcite, захваченных ионов @xcite, одиночных примесей в кремнии @xcite и центров вакансий азота @xcite. на состояние кубита влияют различные источники ошибок, такие как конечное время жизни кубита, несовершенства измерений, неидеальная инициализация и неточное внешнее управление. при условии, что эти ошибки ниже определенного порога, они могут быть исправлены с помощью квантовых кодов коррекции ошибок @xcite, которые кодируют информацию логического кубита в ансамбль физических кубитов. поверхностные коды @xcite, коды исправления ошибок с самыми высокими известными пороговыми значениями, могут потребовать тысячи физических кубитов для каждого отказоустойчивого логического кубита. управление таким большим ансамблем кубитов потребляет большое количество энергии, что делает управление нагревом в регистре кубитов важной задачей. энергопотребление квантового процессора может быть уменьшено за счет реализации более точных физических кубитов, что приводит к созданию меньших ансамблей, формирующих логические кубиты. однако известно, что ошибки затвора также возникают из-за квантово-механических неопределенностей в управляющем импульсе @xcite. в случае резонансного одноразового управляющего импульса этот тип ошибки обратно пропорционален энергии импульса и, следовательно, представляет собой компромисс в управлении питанием квантового компьютера. даже при отсутствии всех других типов ошибок этот результат подразумевает такой высокий уровень рассеиваемой мощности при температуре чипа, что он бросает вызов коммерчески доступному криогенному оборудованию, как мы оцениваем в приложении [appa ] для типичного сверхпроводящего квантового компьютера, использующего поверхностный код для разложения на множители 2000-битного целого числа.    в этой работе мы выводим наибольшую нижнюю границу ошибки затвора в рамках резонансной модели Джейнса Каммингса @ xcite. неизбежная ошибка возникает из-за квантовой природы режима возбуждения и становится доминирующей в режиме низкой мощности возбуждения. в отличие от предыдущей работы @ xcite, наш конструктивный вывод не требует предположения о каком-либо конкретном состоянии системы и применим к поворотам кубита на произвольные углы. в дополнение к самой нижней границе наш метод естественным образом находит бозонные квантовые состояния импульса, которые достигают границы. мы явно показываем, что вращения с одним кубитом оптимально реализуются путем применения определенного сжатия к когерентным состояниям. оптимальные состояния сами по себе не решают вышеупомянутую проблему рассеивания тепла, но мы дополнительно обнаруживаем, что вызванные обратным действием корреляции между управляющим импульсом и управляемым кубитом могут быть переданы вспомогательным кубитам (см. также ссылки. таким образом, мы предлагаем протокол управления, в котором несколько вентилей генерируются с помощью одного управляющего импульса, который часто обновляется с использованием вспомогательных кубитов. в то время как предыдущие исследования показывают, что невозможно сэкономить энергию за счет повторного использования управляющих импульсов без ущерба для минимальной точности затвора @xcite, наш метод демонстрирует на порядки меньшее энергопотребление без снижения средней точности затвора. эта статья организована следующим образом. в сек. [ sec: полуклассический ], мы кратко суммируем формализм, используемый для описания вращений кубитов, и обсуждаем ошибки затворов в полуклассической модели. в разделе. [ sec : оптимизация ] мы выводим квантовый предел ошибки затворов. протокол обновления сконструирован и изучен в разделе. [ sec : протокол ], а ключевые результаты обобщены и обсуждаются далее в разделе.  [ sec : обсуждение ]. давайте сначала рассмотрим полуклассический формализм управления одним кубитом и возникающие в результате ошибки затвора. состояние кубита может быть представлено в виде вектора Блоха, ограниченного внутри единичной сферы, см. рис. однокубитные логические элементы @xmath0, реализованные с использованием, например, микроволновых импульсов, поворачивают вектор Блоха на @xmath1 вокруг оси @xmath2. предполагая, что управляющий импульс представляет собой классическую форму волны, находящуюся в резонансе с энергией перехода кубита @xmath3, система может быть описана во вращающейся системе отсчета с использованием полуклассического гамильтониана взаимодействия вида @xcite @xmath4, где @xmath5 и @xmath6 обозначают основное и возбужденное состояния кубита, соответственно, @xmath7 представляет классическую амплитуду @xmath8 и фазу @xmath9 управляющего поля, @xmath10 - константа связи, включающая огибающую импульса, а @xmath11 - приведенная постоянная Планка. элемент @xmath0 реализуется путем выбора времени взаимодействия @xmath12 и огибающей импульса таким образом, чтобы они удовлетворяли @xmath13. например, установив @xmath14 и @xmath2 вдоль оси @xmath15, оператор временной эволюции @xmath16 $ ] становится @xmath17, где @xmath18 - это оператор Паули @xmath19. таким образом, с точностью до избыточного глобального фазового коэффициента взаимодействие реализует идеальный элемент not @xmath20.     модельная система. (а ) идеальная двухуровневая система (внизу), взаимодействующая с гармоническим генератором (вверху). ( b ) блоховское векторное представление состояния кубита @xmath21 и пример вращения @xmath20. ] мы оцениваем ошибки затвора, используя ошибку преобразования состояния @xmath22, где начальное состояние кубита задается @xmath23, а @xmath24 является желаемым затвором. как правило, состояние кубита неизвестно во время вычисления, и поэтому мы предпочитаем не ограничивать наш анализ каким-либо конкретным состоянием. вместо этого мы изучаем среднее значение заданной меры погрешности @xmath25 по равномерному распределению состояний на сфере Блоха, обычно задаваемое @xmath26 полуклассически, источник ошибки затвора возникает из-за неопределенностей в фазе и числе фотонов @xmath27, которые при малых фазовых флуктуациях принципиально ограничены квантовой механика с помощью соотношения минимальной неопределенности @xcite @xmath28. таким образом, мы рассматриваем управляющий импульс со средним значением @xmath29 фотонов и минимальными неопределенностями @xmath30 и @xmath31, где @xmath32 - параметр свободного сжатия. эти неопределенности распространяются на оператор временной эволюции @xmath33, и мы находим из уравнения.   что средняя ошибка затвора становится обратно пропорциональной числу фотонов. например, для элемента @xmath20 мы получаем среднюю ошибку элемента @xmath34 в пределе @xmath35. интересно, что ошибка сведена к минимуму при ненулевом параметре сжатия @xmath36, результат также получен при полной квантовой обработке за секунду. [ метод минимизации ]. альтернативной величиной ошибки, не зависящей от кубита, является максимальная ошибка затвора, заданная @xmath37, которая подчиняется аналогичной @xmath38-зависимости @xcite. давайте перейдем к полной квантовой обработке, где работа затвора возникает в результате квантово-механического взаимодействия между кубитом и единственной бозонной модой, называемой приводом. использование такого квантового привода @xcite позволяет нам учитывать изменения в его состоянии, возникающие в результате взаимодействия с кубитом. на практике кубиты также управляются распространяющимися фотонами, описываемыми континуумом мод, но такие устройства не экономят энергию по сравнению с хорошо контролируемым одиночным режимом. следовательно, ожидается, что приведенное ниже описание даст фундаментальную нижнюю границу энергии, необходимой для управления одним кубитом с заданной точностью. в отличие от полуклассической модели, эволюция кубита не является унитарной. после взаимодействия состояние кубита извлекается путем частичного отслеживания степеней свободы привода как @xmath39,\\ ] ] где @xmath40 и @xmath41 обозначают произвольный оператор начальной плотности и оператор эволюции системы привода кубита, соответственно. ошибка, или несоответствие, между целевым и результирующим состоянием кубита здесь определяется как @xmath42=1-\\m{tr}\\left [ \\hat{\\chi}(t)\\hat{k}\\hat{\\chi}_{0}\\hat{k}^{\\dagger}\\right ], \\label{eq : errortraces}\\ ] ], который можно рассматривать как обобщение eq. . динамика системы привода кубитов в целом описывается моделью Джейнса Каммингса @ xcite, которая включает приближение вращающейся волны. предполагая резонансное взаимодействие, система управляется гамильтонианом взаимодействия @xmath43, где @xmath44 - оператор бозонной аннигиляции режима возбуждения. без потери общности мы предполагаем огибающую включения - выключения, такую, что @xmath45 для @xmath46 и @xmath47 в противном случае. большинство функций полуклассической модели восстанавливаются, если @xmath48 и привод находятся в согласованном состоянии @xmath49, где @xmath50 - это @xmath27-е состояние fock. например, принимая математическое ожидание @xmath51 в состоянии @xmath52, получаем полуклассический гамильтониан в уравнении. ( [ eq : classicalh ] ). таким образом, когерентное состояние приблизительно индуцирует элемент @xmath0, если выполняется условие синхронизации @xmath53. если начальное состояние объединенной системы является разделяемым, @xmath54, где @xmath55 и @xmath56 обозначают начальное состояние кубита и состояние привода соответственно, ошибку затвора уравнения.   индуцированное взаимодействием Джейнса Каммингса может быть записано в общей форме @xmath57 здесь @xmath58 обозначает либо ошибку преобразования @xmath59 конкретного состояния кубита, среднюю ошибку затвора @xmath60 [ eq. ], либо максимальную ошибку затвора @xmath61. информация о желаемом шлюзе и выбранном времени взаимодействия содержится в соответствующем операторе @xmath62, который обозначается либо @xmath63, @xmath64, либо @xmath65, соответственно. аналитическое выражение для @xmath63 и @xmath64 можно найти для любых вентилей, тогда как выражение для @xmath65 существует, по крайней мере, для вращений @xmath66, где ось вращения @xmath67 ограничена плоскостью @xmath68 сферы Блоха. выводы и подробные выражения приведены в приложении [ appb ]. оптимальные состояния привода и результирующая ошибка. ( a ) численно решенные начальные состояния привода @xmath69, которые минимизируют среднюю ошибку поворотов @xmath70 и @xmath20 в виде распределений Вигнера выше и ниже пунктирной линии соответственно. функция Вигнера определяется как @xmath71 $ ], где @xmath72 - оператор смещения. время взаимодействия для каждой операции @xmath0 равно @xmath73, что, как ожидается, приведет к получению состояний с @xmath74. ( b ) ошибка затвора для операции @xmath20 как функция среднего числа фотонов @xmath75 управляющего импульса, который инициализируется либо в когерентном состоянии (красный цвет), либо в сжатом состоянии cat (синий цвет). выделенные области указывают диапазон погрешности в зависимости от начального состояния кубита, а сплошные линии показывают ошибку, усредненную по состояниям кубита, равномерно распределенным по сфере Блоха, @xmath60. на вставке показана разница @xmath76 между численно рассчитанными ошибками и их аналитическими приближениями первого порядка (таблица [ tab_1 ] ), пунктирными линиями указана разница в максимальных ошибках. ] [ bt ! ] [ cols=\"^,^,^,^,^,^,^,^,^ \", ] мы вычисляем состояния привода, которые минимизируют среднюю или максимальную ошибку затвора для заданного времени взаимодействия и желаемого поворота @xmath77. с этой целью достаточно рассматривать только чистые состояния @xcite, и, следовательно, мы можем использовать формы, заданные уравнением . , состояния, минимизирующие ошибки, - это собственные состояния операторов @xmath62, которые соответствуют наибольшему собственному значению @xmath78, @xmath79 по определению, оптимальные состояния @xmath80 обеспечивают фундаментальная нижняя граница для ошибки @xmath58. мы решаем это уравнение на собственные значения численно. примеры решений, оптимальных по точности, показаны на рис. [ рис. 2]a с использованием функции псевдовероятности Вигнера @xcite. численно полученные состояния могут быть точно описаны с использованием сжатых когерентных состояний @xmath81, где @xmath82 и @xmath83 являются операторами смещения и сжатия, соответственно @xcite. важно отметить, что численные решения обладают правильной амплитудой и фазой, чтобы удовлетворять временному условию @xmath53 и задавать желаемое направление оси вращения, не навязывая их явно. кроме того, средние ошибки, а также оптимальные параметры сжатия равны полученным при полуклассическом подходе в сек. [ сек. : полуклассический ].    в конкретном случае @xmath84-поворотов сумма двух собственных векторов, т.е. сжатое состояние cat @xcite @xmath85, где положительная константа @xmath86 обеспечивает нормализацию, является состоянием, которое минимизирует как среднюю, так и максимальную ошибку одновременно (см. приложение [ appb ] ). Сравнение полученных ошибок по такому состоянию и когерентное состояние представлено на фиг. [рис. 2]б. численный подход для решения собственных состояний @xmath62 имеет недостаток, заключающийся в усечении бесконечномерного вектора состояния до конечного вектора длины @xmath87, что может исказить или исключить некоторые из возможных решений. однако на полученные гауссоподобные решения не влияют изменения порогового значения для @xmath88. повышение порогового значения показывает более энергичные решения, но они соответствуют импульсам, которые реализуют выбранный вентиль после целого числа ненужных @xmath89 вращений. как правило, для элементов @xmath90 мы находим решения с ошибками, которые равны нулю как @xmath38 в пределе @xmath35, как показано в приложении [ appc ]. нижние границы вместе с ошибками, вызванными несжатыми когерентными состояниями, показаны в таблице [ tab_1 ]. другие элементы, такие как pauli - z гейт и гейт Адамара могут быть сконструированы как последовательности гейтов @xmath90. недавно было показано, что сжатие также улучшает точность фазового затвора в дисперсионном режиме @xcite. принципиальная схема протокола обновления привода. в течение одного цикла циркулирующий управляющий импульс (красный) индуцирует выбранное вращение @xmath91 на одном из кубитов @xmath92 в регистре и затем обновляется последовательными взаимодействиями @xmath20 с каждым вспомогательным кубитом \\{@xmath93}. в идеальных условиях каждый вспомогательный модуль подготавливается точно к состоянию @xmath94 и сбрасывается после каждого цикла. на практике кубиты вспомогательного модуля изначально находятся в своих основных состояниях, и их подготовка и сброс осуществляются циркулирующим коррекционным импульсом (зеленый). ] все фундаментальные нижние границы, полученные выше, обратно пропорциональны среднему числу фотонов. интуитивно понятно, что привод с большим числом фотонов должен быть способен индуцировать несколько вентилей без существенных изменений, таким образом уменьшая требуемое количество энергии на вентиль при почти равном уровне ошибок. ниже мы покажем, что повторное использование привода эффективно снижает потребление энергии значительно ниже нижней границы средней ошибки затвора для одноразовых импульсов. кроме того, привод может корректироваться между последовательными затворами таким образом, что потребление снижается без существенного снижения средней точности затвора.    в нашем протоколе перемещающийся управляющий привод циклически взаимодействует с регистром резонансных кубитов и вспомогательных кубитов, см. рис. цикл начинается с того, что привод, первоначально находящийся в подходящем сжатом когерентном состоянии, применяет выбранную операцию затвора с минимальной ошибкой к кубиту регистра. следовательно, состояние привода изменяется из-за квантового обратного воздействия. чтобы отменить это, привод настроен на последовательное взаимодействие с корректирующими вспомогательными кубитами, инициализированными в суперпозиции основного и возбужденного состояний, в течение времени, соответствующего @xmath84-вращению. в результате чистота, энергия и фаза привода восстанавливаются при последовательных взаимодействиях (см. приложение [ appd ] ). в конце цикла вспомогательные кубиты сбрасываются, и обновленный привод можно использовать для другого высокоточного вентиля.    с увеличением числа вспомогательных кубитов время выполнения полного цикла увеличивается, и, таким образом, один блуждающий импульс реже применяет вентиль к регистру. чтобы компенсировать это, можно было бы добавить еще один управляющий импульс для каждого вспомогательного элемента в массиве и синхронизировать время их прохождения таким образом, чтобы каждый кубит взаимодействовал с одним из импульсов в данный момент времени. такая система применяла бы столько вентилей в регистре за цикл, сколько находится в обращении блуждающих импульсов. однако мы ограничиваем наш анализ одним импульсом.     эволюция вспомогательного состояния во время цикла обновления: (i ) подготовка из основного состояния в состояние @xmath95, ( ii ) обновление привода в результате основного вращения (красный) и ( iii ) сброс вспомогательного состояния. мы либо предполагаем, что подготовительные этапы (i) и (iii) являются идеальными, либо индуцируются коррекционным импульсом, как показано на фиг. [ рис. 3 ]. ] обновление с помощью вспомогательных взаимодействий можно понять, рассмотрев путь, пройденный вектором Блоха вспомогательного кубита, как показано на фиг. привод, испытывающий недостаток энергии, вращает вектор с меньшей угловой частотой, в результате чего вспомогательный элемент слегка смещается в основное состояние и в процессе получает энергию. аналогичным образом, избыточная энергия в приводе передается вспомогательному элементу из-за его приближения к возбужденному состоянию. гильбертово пространство этой системы формально является составным пространством пространства фока @xmath96 привода и двухуровневых пространств @xmath97 регистровых и вспомогательных кубитов, @xmath98 привод взаимодействует только с одним кубитом за раз, и поэтому каждое взаимодействие может быть вычислено в подпространстве соответствующего кубит и привод, предполагая, что кубиты не коррелированы. после взаимодействия состояние привода извлекается путем трассировки по соответствующему пространству кубитов. а именно, @xmath99-я итерация состояния диска задается @xmath100, \\label{eq : nextstate}\\ ] ] где @xmath101 действует в подпространстве диска, а @xmath99-й кубит - в последовательностях протокола, описанных в следующих разделах. рассмотрим сначала случай, когда вспомогательные кубиты полностью сбрасываются во время каждого цикла, и логический элемент, который мы хотим применить к каждому кубиту регистра, равен @xmath102. протокол выполняется со следующими шагами: 1. состояние привода инициализируется в @xmath103-минимизирующее состояние @xmath104. новый кубит регистра инициализируется в случайном чистом состоянии, равномерно выбранном из сферы Блоха. привод взаимодействует с кубитом регистра в течение времени взаимодействия @xmath105 [ например. . вспомогательные кубиты @xmath106 инициализируются значением @xmath95. привод взаимодействует с вспомогательным кубитом в течение времени взаимодействия @xmath105. повторите для всех вспомогательных устройств. оцените среднюю ошибку @xmath60 гипотетического элемента @xmath20 с помощью эквалайзеров.   и используя текущее состояние привода. продолжайте с шага (ii).    для вентилей, отличных от @xmath102, фазы привода и вспомогательных устройств, а также время взаимодействия на шаге (iii), но не на шаге (v), будут соответственно сдвинуты. средняя ошибка @xmath60 элементов @xmath20, сгенерированных блуждающим управляющим импульсом, который изначально имел среднее число фотонов @xmath75 и достиг устойчивого состояния из-за обновления вспомогательного устройства. привод настроен на взаимодействие с @xmath106 идеальными вспомогательными устройствами ( @xmath95 ) за цикл, как указано, что приводит к эффективному обновлению состояния привода. пунктирная линия указывает нижнюю границу погрешности, которая достигается либо при одноразовом оптимальном импульсе, либо при импульсе, обновляемом бесконечно большим количеством идеальных вспомогательных устройств. на вставке показана средняя ошибка затвора как функция @xmath106 для @xmath107. ] мы численно моделируем эволюцию привода и оцениваем среднюю ошибку затвора @xmath20 для кубита регистра после каждого цикла. во время работы протокола средняя ошибка @xmath60 будет увеличиваться по сравнению с ее первоначальным значением нижней границы с различной скоростью в зависимости от рандомизированных состояний кубитов регистра. мы обнаружили, что после многих циклов привод достигает устойчивого состояния, которое генерирует желаемые вентили с предсказуемой средней погрешностью. при 13 вспомогательных элементах за цикл средняя ошибка достигает насыщения после ста циклов; при десяти или более вспомогательных элементах насыщение занимает менее десяти циклов. если корректирующие вспомогательные устройства не используются, средняя ошибка в конечном итоге достигает @xmath108. на рисунке [ рис. 5 ] показано, как конечный уровень ошибки зависит от количества фотонов и вспомогательных устройств. средняя ошибка затвора приближается к своей теоретической нижней границе, в пределе многих вспомогательных кубитов, обновляющих привод. при меньших углах поворота получаются качественно аналогичные результаты с более медленно накапливающейся ошибкой. таким образом, один блуждающий импульс привода, снабженный идеальными состояниями вспомогательных кубитов, может генерировать iконечное число высокоточных вентилей.      в предыдущем разделе предполагалось, что кубиты в регистре по существу некоррелированы, чтобы оправдать частичное отслеживание каждого кубита после соответствующего взаимодействия. здесь мы демонстрируем полезную производительность нашего метода в случае, когда регистровые кубиты максимально запутаны. мы инициализируем регистр кубитов @xmath109 в состоянии Гринбергера Хорна Цайлингера (ГГц) @xmath110. протокол управления физически такой же, как и в предыдущем разделе: привод взаимодействует только с одним кубитом за раз для реализации однокубитного вентиля @xmath24 и обновляется с помощью @xmath106 идеально подготовленных вспомогательных устройств между каждым таким вентилем. таким образом, целевой операцией в регистре является @xmath111. из-за запутанного регистра операторы временной эволюции должны вычисляться в гильбертовом пространстве @xmath112 или @xmath113 для взаимодействий между приводом и кубитом регистра или приводом и вспомогательным устройством @xmath114, соответственно. частичная трассировка по какому-либо регистровому кубиту не выполняется. после того, как привод один раз взаимодействовал с каждым кубитом регистра, состояние регистра преобразовалось в @xmath115, а общая ошибка преобразования вычисляется как @xmath116.\\ ] ] мы делим эту ошибку на количество кубитов, чтобы получить эффективную ошибку для каждого элемента, @xmath117.     ошибка подготовки состояния для каждого кубита @xmath118 для регистра из @xmath109 кубитов, изначально находящихся в состоянии ГГц. целевой элемент - это вращение @xmath119 для всех кубитов по отдельности, реализуемое сжатым состоянием @xmath120 фотонов ( @xmath121 ), которое обновляется @xmath106 идеальными вспомогательными устройствами за цикл. кружки представляют данные, в то время как цветные линии расширяют линейные сегменты между первыми двумя точками данных, чтобы различать отклонения от линейного поведения. черная пунктирная линия представляет ошибку, полученную при использовании одноразовых импульсов @xmath109 с постоянным числом фотонов @xmath120. пунктирная линия - это ошибка, вызванная одноразовыми импульсами постоянной полной энергии @xmath122. ] результаты моделирования для вентиля @xmath119 с начальным состоянием привода @xmath123 показаны на рис. поведение, аналогичное фиг.  наблюдается [ рис. 5 ]: при достаточном количестве дополнительных исправлений между элементами регистра ошибка, создаваемая перемещающимся приводом, может быть уменьшена до уровня, заданного отдельными импульсами. рисунок также показывает, что даже без корректировок повторное использование накопителя определенной энергии на практике более выгодно, чем разделение того же количества фотонов на отдельные, более слабые одноразовые импульсы. таким образом, мы приходим к выводу, что независимо от состояния регистра обновление управляющего импульса, вероятно, служит для улучшения соотношения между ошибкой затвора и требуемой энергией. приведенный выше случай запутанных кубитов также дает возможность сравнить наши результаты с предыдущей работой gea - banacloche и ozawa @xcite, где они изучали регистр в состоянии ГГц, который управлялся приводом из @xmath75 фотонов в среднем. они показали, что максимальная ошибка элемента @xmath119 в этой системе масштабируется как @xmath124 на кубит. это масштабирование использовалось для утверждения, что импульс со средним числом фотонов @xmath125 не может превзойти отдельные импульсы со средним числом фотонов @xmath109, хотя их производительность явно не сравнивалась. ключевыми отличиями здесь являются то, что ссылка. @xcite не рассматривает возможность использования вспомогательных кубитов и что в нем используется определение ошибки, которое также учитывает неверность состояния привода. наши результаты показывают, что, несмотря на то, что ошибки, связанные как с повторно используемыми, так и с одноразовыми импульсами одинаковой суммарной энергии, увеличиваются почти линейно с @xmath109, предиктор первого намного меньше и может быть значительно улучшен с помощью протокола обновления. средняя ошибка затворов как функция общего среднего числа исходных фотонов, @xmath127 для @xmath128 и @xmath75 для @xmath129, деленная на количество сгенерированных регистровых затворов @xmath20. вспомогательные состояния неидеально подготавливаются импульсом корректора, первоначально находящимся в состоянии @xmath130. во время выполнения протокола кривая перемещается справа налево, и результаты усредняются по нескольким моделям. пунктирная линия указывает нижнюю границу погрешности, которая достигается либо при одноразовом оптимальном импульсе, либо при импульсе, обновляемом бесконечно большим количеством идеальных вспомогательных средств. ] общее энергопотребление протокола может быть достоверно оценено только в том случае, если указан метод и затраты энергии на приготовление вспомогательных средств. с этой целью мы предлагаем подготавливать вспомогательные устройства с помощью циркулирующего импульса корректора, показанного на рис. [ рис. 3 ]. в полном протоколе кубиты вспомогательных устройств сначала подготавливаются в их основном состоянии, а затем контролируются импульсом корректора от цикла к циклу. при противоположной фазе и вдвое меньшем времени взаимодействия по сравнению с приводом корректирующий импульс применяет элемент @xmath131 на вспомогательном устройстве до и после элемента @xmath20, введенного импульсом привода. для простоты мы предполагаем, что состояние реестра разделимо. полный протокол задается следующими шагами: 1. состояние привода инициализируется значением @xmath132, корректирующий импульс - значением @xmath133, а все вспомогательные устройства @xmath106 - в основное состояние. новый кубит регистра инициализируется в случайном чистом состоянии. привод взаимодействует с регистровым кубитом со временем взаимодействия @xmath105 [пример. . 4. вспомогательный кубит последовательно взаимодействует с корректором, приводом и снова корректором со временем взаимодействия @xmath134, @xmath12 и @xmath134, соответственно. повторите для всех остальных вспомогательных устройств. 5. оцените среднюю ошибку @xmath60 гипотетического элемента @xmath20 с помощью эквалайзеров.   и используя текущее состояние привода. продолжайте с шага (ii). в дополнение к вычислению состояния привода после каждого взаимодействия, состояние взаимодействующего кубита также извлекается для последующего использования путем частичной трассировки по степеням свободы привода. это оправдано, если вспомогательные кубиты не становятся сильно коррелированными в процессе эволюции. это приближение тем точнее, чем ближе управляющие импульсы к классическим импульсам, которые не вызывают запутывания. поскольку все вспомогательные кубиты подготовлены к основному состоянию, потребление энергии полностью зависит от импульсов возбуждения и корректора, оба из которых имеют начальную среднюю энергию @xmath135. таким образом, среднее потребление энергии на элемент регистра равно @xmath136, где @xmath109 - количество прошедших циклов, или поровну сгенерированных элементов. в случае, когда протокол обновления диска не используется, @xmath129, у нас есть @xmath137. результаты нескольких симуляций усреднены и показаны на рис. в отличие от идеального случая, система накапливает ошибку в течение повторяющихся циклов, и средняя ошибка элемента не насыщается. тем не менее, мы обнаруживаем, что при достаточном количестве взаимодействий вспомогательных кубитов между элементами регистра средняя ошибка остается почти постоянной для большого числа последовательных элементов. протокол может быть остановлен до того, как ошибка достигнет желаемого порога. это показывает, что общие затраты энергии на один регистровый элемент эффективно снижаются на порядки ниже нижней границы для одноразовых импульсов. фактически, рис. [рис. 7 ] предполагает, что теоретически погрешность затвора может быть уменьшена до бесконечности без увеличения энергопотребления за счет использования более энергичных импульсов. в этой работе мы вывели наибольшую нижнюю границу погрешности однокубитного затвора, реализованного с одним резонансным режимом управления определенной средней энергией. в отличие от предыдущей работы, наш метод получения границы не ограничен каким-либо конкретным элементом или состоянием системы управления кубитами. метод также может быть использован для нахождения квантового состояния режима возбуждения, которое минимизирует среднюю ошибку затвора, или, альтернативно, ошибку преобразования для выбранного начального состояния кубита. в частности, мы обнаружили, что нижние границы для поворотов вокруг осей в плоскости @xmath68 достигаются путем сжатия квантового состояния когерентного управляющего импульса на величину, которая зависит от целевого затвора. вместе с недавним результатом о том, что сжатие также значительно улучшает фазовый затвор в дисперсионном режиме @ xcite, наши результаты предполагают, что сжатие в целом может привести к полезным улучшениям в различных схемах управления. это требует экспериментальных исследований по повышению эффективности широко используемого когерентного состояния. важно отметить, что наши результаты также устанавливают нижнюю границу энергопотребления кубитов с индивидуальным управлением. обеспечение требуемой мощности на уровне кубита, возможно, с помощью серии аттенюаторов, подразумевает проблемы управления теплом, которые должны быть решены в будущих крупномасштабных квантовых компьютерах. в качестве решения мы внедрили конкретный протокол, в котором блуждающий управляющий импульс используется для генерации нескольких вентилей и обновляется между ними, чтобы избежать потери точности работы вентилей. процесс обновления также может оказаться полезным для исправления ошибок фазы и амплитуды зашумленного управляющего импульса. наш протокол, возможно, может быть реализован в той или иной форме с будущими микроволновыми компонентами с низкими потерями, такими как фотонные маршрутизаторы @xcite, циркуляторы и наноэлектромеханические системы @xcite. технические ограничения в качестве этих устройств на практике приведут к компромиссу между достижимой точностью работы затвора и рассеиваемой мощностью. в будущем наша работа может быть расширена до определения границ ошибок для 2-кубитных вентилей, сохранения состояния, усиления импульсов и распространения управляющих импульсов, состоящих из континуума бозонных мод. мы благодарим Паоло Солинаса и Бенджамина Хьюарда за полезные обсуждения. эта работа была поддержана Европейским исследовательским советом в рамках гранта для начинающих независимых исследователей № 278117 (singleout) и консолидирующего гранта № 681311 (quess). мы также отмечаем финансирование со стороны академии Финляндии в рамках ее программы центров передового опыта (гранты № 251748 и 284621) и грант (№ 286215), а также от финского культурного фонда. мы оцениваем мощность, требуемую квантовым компьютером на основе сверхпроводника, решающим 2000-битную задачу факторизации, стабилизированную поверхностным кодом. для этого папри точных вычислениях необходимое количество физических кубитов было оценено Фаулером @xcite как @xmath138. мы предполагаем, что физические кубиты управляются типичными когерентными микроволновыми импульсами и что элементы @xmath139 завершаются за равное время и с меньшей мощностью, чем элементы @xmath84. средняя мощность, необходимая в течение одного цикла кода surface, рассчитывается путем подсчета частоты измерений, операций @xmath140, @xmath141 и cnot, а также путем получения средневзвешенного по продолжительности значения соответствующих мощностей. время работы зависит от реализации. используя время работы, указанное в исх. @xcite, @xmath142 нс, @xmath143 нс и @xmath144 нс, для @xmath84-поворотов, управляемых фазовых вентилей и измерений, соответственно, и предполагая, что наш код выполняет как можно больше операций параллельно, средняя мощность на физический кубит составляет приблизительно @xmath145, где @xmath146 с обозначьте среднюю мощность привода для вышеупомянутых операций. для простоты мы пренебрегаем двухкубитными вентилями и измерениями и используем @xmath147. типичная мощность чипа составляет порядка 148 Вт после генерации при комнатной температуре и ослабления на десятки децибел на пути к базовой температуре примерно 10 мк. при использовании только @xmath149 дБ ослабления при базовой температуре общая рассеиваемая мощность здесь составляет @xmath150 МВт. такой уровень мощности намного выше, чем типичная мощность охлаждения @xmath151 Вт в современных холодильниках для разбавления при 10 мк. Обратите внимание, что при использовании открытой линии передачи ожидается потребление большей мощности, чем требуется в однорежимном случае, рассмотренном в разделе. [ сек. : оптимизация ]. средняя плотность энергии в линии передачи задается @xmath152, где @xmath153 - емкость на единицу длины, а @xmath154 - среднеквадратичное значение напряжения. в интервале времени @xmath155 распространяющийся управляющий импульс продвигается на расстояние @xmath156, эффективно передавая мощность @xmath157, где @xmath158 - длина волны фотона. для сравнения рассмотрим резонатор @xmath159, который используется для подачи @xmath154 на кубит в течение равного времени работы. резонатору требуется мощность @xmath160, а при типичной частоте кубита @xmath161 ГГц соотношение между мощностями составляет @xmath162. таким образом, управление кубитами с использованием распространяющихся фотонов в линии передачи, по-видимому, приводит к на порядки большему энергопотреблению, чем в нашем одномодовом случае. однако для получения точных оценок требуется более всестороннее исследование с использованием квантования линии передачи. мы оставляем такое исследование для будущих исследований. наконец, давайте рассмотрим нижнюю границу мощности для управления кубитами с использованием одноразовых импульсов. минимальное количество фотонов (см. раздел.  [ метод минимизации ] ) для получения ошибки затвора @xmath163, используемой Фаулером в ссылке. @xcite - это @xmath164 фотона на уровне кубита. при частоте @xmath161 ГГц соответствующие мощности равны @xmath165 Вт и @xmath166 Вт. это говорит о том, что нижняя граница для размера проблемы в нашем примере находится на границе, где текущее холодильное оборудование не обеспечивает требуемую мощность охлаждения, и, следовательно, значительное увеличение размера проблемы или неидеальная реализация предлагаемого привода. методы требуют изобретательских решений возникающей проблемы управления теплом. способом избежать затухания при базовой температуре было бы генерирование управляющих импульсов на уровне чипа. однако, насколько нам известно, ни один существующий источник фотонов на уровне чипа не способен генерировать импульсы, которые были бы достаточно точными и интенсивными, чтобы индуцировать квантовые вентили высокой точности. кроме того, эффективность работы таких устройств должна быть достаточно высокой, чтобы они могли стать существенной альтернативой. как правило, внутренние источники микроволнового излучения рассеивают гораздо больше энергии, чем их максимальная выходная мощность. предполагая, что система управления кубитами изначально находится в чистом состоянии, @xmath167, уравнение сводится к @xmath168\\hat{k}\\c_{0}\\hat{k}^{\\dagger}\\right\\ } \\nonumber \\\\ \\quad\\;=1-\\sum_{k=0}^{\\infty}\\left|\\b{\\chi_{0},k}(\\hat{k}^{\\dagger}\\otimes\\hat{\\mathbb{i}})\\hat{u}(t)\\k{\\chi_{0},\\sigma_{0}}\\right|^{2 }, \\label{eq : err1}\\end{собрано}\\ ] ] где @xmath24 - желаемый элемент, @xmath12 - время взаимодействия, @xmath41 - оператор временной эволюции, а @xmath169 - фотон числовые состояния. мы представляем базис кубитного пространства, используя векторы @xmath170 и @xmath171, и явно записываем @xmath172 в этом базисе, @xmath173, а @xmath41 задается @xmath174 с сокращенными обозначениями @xmath175, @xmath176 и @xmath177. используя приведенные выше выражения, матричный элемент в уравнении. может быть структурирован как @xmath178, где @xmath179,\\nonumber \\\\gamma_{01}^{k}(\\vartheta,\\varphi ) & = & -is_{k}\\left[k_{12}^{*}\\sin^{2}\\left(\\frac{\\vartheta}{2}\\right)+k_{11}^{*}\\frac{1}{2}\\sin\\left(\\vartheta\\right)\\e{i\\varphi}\\right],\\nonumber \\\\gamma_{10}^{k}(\\vartheta,\\varphi ) & = & -is_{k+1}\\left[k_{21}^{*}\\cos^{2}\\left(\\frac{\\vartheta}{2}\\right)+k_{22}^{*}\\frac{1}{2}\\sin\\left(\\vartheta\\right)\\e{-i\\varphi}\\right],\\nonumber \\\\gamma_{11}^{k}(\\vartheta,\\varphi ) & = & c_{k+1}\\left[k_{22}^{*}\\sin^{2}\\left(\\frac{\\vartheta}{2}\\right)+k_{21}^{*}\\frac{1}{2}\\sin\\left(\\vartheta\\right)\\e{я\\varphi}\\прав].\\nonumber\\end{выровнено}\\ ] ] таким образом, ошибка задается @xmath180. Мы можем определить оператор преобразования через его матричные элементы в базе чисел фотонов как @xmath181, где @xmath182 и @xmath183 - дельта Кронекера, равная нулю для любого отрицательного индекса. таким образом, уравнение приводится к виду, приведенному в уравнении , то есть @xmath184 с использованием уравнения, средняя ошибка и соответствующий ей оператор могут быть структурированы аналогичным образом. определяя элементы матрицы оператора @xmath185 как @xmath186, средняя ошибка также принимает форму уравнения. . как показано в ссылке. @xcite, средняя ошибка, интегрированная по сфере Блоха, равна среднему арифметическому ошибки шести так называемых осевых состояний. это обеспечивает альтернативное выражение для оператора @xmath185, а именно @xmath187.\\end{выровнено}\\ ] ] мы можем оптимизировать максимальную ошибку, если существует начальное состояние кубита, которое выдает наибольшую ошибку независимо от состояния привода, т.е. @xmath188. специально для гейтов @xmath66, вычисляющих градиенты @xmath189 относительно @xmath190 и @xmath191 показывают, что максимальная точка практически не зависит от состояния привода и что максимальная погрешность получается при использовании @xmath192 и @xmath193, или, что эквивалентно, @xmath194, где @xmath9 - угол между горизонтальной осью вращения @xmath67 и осью вращения двигателя. @xmath15-ось. из-за симметрии начальное состояние привода, которое оптимизирует @xmath61, является собственным вектором @xmath195, который соответствует средней ошибке этих двух состояний. оказывается, что элементы коммутатора @xmath196 $ ] уменьшаются по мере увеличения @xmath197. таким образом, из этого следует, что собственные векторы @xmath185, т.е. сжатые состояния cat, заданные уравнением, одновременно минимизируют как @xmath61, так и @xmath60 в пределе @xmath35. в этом разделе показано, как можно аналитически аппроксимировать ошибку элемента управления для конкретного элемента управления. в качестве примера мы выбираем @xmath60 для элемента управления @xmath20. используя @xmath198, легко вычислить интегралы в уравнении , и, следовательно, средняя ошибка [ уравнение.   становится @xmath199\\right. \\nonumber \\\\ & & \\left. + 2s_{n}(t)s_{n+1}(t)\\m{re}\\слева(c_{n+1}c_{n-1}^{*}\\справа)\\справа\\}. \\label{eq : exactaverageerror}\\end{выровнено}\\ ] ] ошибка затем получается путем вставки коэффициентов @xmath200 желаемого состояния привода: когерентного, сжатого cat или какого-либо другого состояния. мы выбираем сжатое состояние cat @xmath201, где @xmath32 - неизвестный параметр сжатия, а амплитуда, удовлетворяющая @xmath202, является реальной. в пределе высокой энергии числа занятых в сжатом состоянии @xmath203 подчиняются нормальному распределению @xmath204,\\ ] ] со средним значением @xmath205 и стандартным отклонением @xmath206. амплитуды сжатого состояния cat @xmath207 получены путем разрешения занимать либо четные (либо нечетные) состояния, такие как @xmath208,\\ ] ], если @xmath27 четное (нечетное), и @xmath209 в противном случае. вставка этих коэффициентов в уравнение. выдает @xmath210, где @xmath211 \\left[\\sin^{2}\\left(\\frac{\\pi}{2}\\sqrt{2m\\alpha^{-2}}\\right)+\\sin^{2}\\left(\\frac{\\pi}{2}\\sqrt{\\left(2m+1\\right)\\alpha^{-2}}\\right)\\right],\\ ] ] и @xmath212^{2}+\\left(2m\\alpha^{-1}-\\alpha\\right)^{2}\\right\\ } \\right ) \\sin\\left[\\frac{\\pi}{2}\\sqrt{\\left(2m+1\\right)\\alpha^{-2}}\\right]\\sin\\left[\\frac{\\pi}{2}\\sqrt{\\left(2m+2\\справа)\\альфа^{-2}}\\справа].\\ ] ] суммы могут быть вычислены путем изменения переменных @xmath213 и обработки бесконечной суммы @xmath214 как интеграла @xmath215, что оправдано в пределе @xmath216, где функции довольно гладкие и поддерживают область, намного более широкую, чем единица. аппроксимация результата к наименьшему порядку в @xmath217 в конечном итоге приводит к @xmath218 это выражение минимизируется при выборе параметра сжатия @xmath36, независимо от @xmath219. таким образом, мы имеем @xmath220. приблизительные средние ошибки для элементов @xmath119, @xmath221 и @xmath222, реализованных различными состояниями привода, такими как когерентное состояние, могут быть вычислены аналогичным образом. этот подход также работает с максимальной ошибкой для поворотов @xmath84. выражения, полученные таким образом, перечислены в таблице [ tab_1 ]. чтобы построить наш протокол, мы сначала ищем начальные состояния вспомогательных устройств и привода таким образом, чтобы каждое взаимодействие вспомогательного устройства с приводом приводило привод в стабильное состояние. чтобы протокол работал, должны выполняться следующие условия: 1. в окрестности стабильного состояния привод способен индуцировать высокоточные вентили на кубите регистра. взаимодействие с вспомогательным приводом увеличивает чистоту состояния привода, определяемого здесь как @xcite @xmath223. взаимодействия с регистровыми кубитами в рандомизированных состояниях, как правило, снижают чистоту привода, делая его менее полезным для последующих вентилей. таким образом, повышение чистоты эффективно переносит энтропию с накопителя на вспомогательные кубиты. вспомогательный накопительэлектронное взаимодействие направляет амплитуду или, в равной степени, энергию привода к его установившемуся значению. это необходимо, поскольку мы хотим генерировать вентили с фиксированным временем взаимодействия. взаимодействие направляет относительную фазу привода к ее первоначальному значению. изменение чистоты состояния накопителя из-за взаимодействия со вспомогательным кубитом, инициализированным в состоянии @xmath224. показанное изменение - это @xmath225, усредненное по нескольким моделированиям, где @xmath226 является результатом эволюции @xmath227. нечистое начальное состояние привода @xmath228 было получено путем взаимодействия сжатого когерентного состояния @xmath229 с @xmath230 с 10 кубитами в случайно выбранных начальных состояниях. время взаимодействия соответствует повороту @xmath84. ] условие (i ) предполагает, что наиболее многообещающими кандидатами на начальное состояние привода являются когерентное состояние @xmath231 и его сжатый вариант @xmath232. мы изучаем условие (ii), вычисляя изменение чистоты @xmath233, где @xmath234 задается уравнением. . рисунок [ рис. 8 ] показывает, что чистота состояния привода увеличивается, если вспомогательный модуль инициализирован близко к состоянию @xmath95. из рисунка также следует, что протокол работает, даже если при подготовке вспомогательного устройства в этом состоянии возникает какая-либо ошибка. изменение среднего числа фотонов @xmath235 в начальном состоянии возбуждения @xmath236 в зависимости от отклонения @xmath237. изменение является результатом взаимодействия фиксированного времени @xmath238 со вспомогательным кубитом, подготовленным в состоянии @xmath239. ] кроме того, изменения в заполнении фотонами @xmath240 при различных начальных энергиях привода показаны на фиг. [ рис. 9 ] что это вспомогательное состояние также обеспечивает отрицательную обратную связь по среднему числу фотонов, удовлетворяя условию (iii). наше исследование вигнеровского представления состояния возбуждения после последовательных взаимодействий вспомогательного состояния показывает, что условие (iv) также выполняется.    для протокола, генерирующего только элементы @xmath140, сжатое состояние cat @xmath241 также было протестировано в качестве начального состояния привода. к сожалению, в этом случае условия (ii) и (iii) не выполняются для любого выбора вспомогательного состояния, поскольку состояние cat не поворачивает вектор блоха вспомогательного устройства в определенном направлении, что важно для механизма обратной связи, изображенного на рис. [ рис. 4 ] 

в ближайшем будущем основной задачей квантовых вычислений станет масштабирование надежных прототипов кубитов до размеров практических задач и внедрение комплексной коррекции ошибок для повышения точности вычислений. из-за неизбежных квантовых неопределенностей в резонансных управляющих импульсах повышение точности квантовых вентилей связано с увеличением энергопотребления. следовательно, мощность, рассеиваемая вблизи процессора в хорошо работающем крупномасштабном квантовом компьютере, кажется неприемлемо большой в типичных системах, требующих низких рабочих температур. здесь мы представляем метод управления кубитами и показываем, что он служит для уменьшения ошибки однокубитного затвора без увеличения средней мощности, рассеиваемой на затвор. ранее считалось, что ошибка однокубитного затвора, вызванная режимом бозонного привода, обратно пропорциональна энергии управляющего импульса, но мы обходим это ограничение, повторно используя и корректируя блуждающие управляющие импульсы. таким образом, наша работа предполагает, что рассеивание тепла представляет собой не фундаментальное ограничение, а необходимую практическую проблему в будущих реализациях крупномасштабных квантовых компьютеров.